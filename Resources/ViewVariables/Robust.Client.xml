<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Robust.Client</name>
    </assembly>
    <members>
        <member name="T:Robust.Client.Animations.Animation">
            <summary>
                A animation represents a way to animate something, using keyframes and such.
            </summary>
            <remarks>
                An animation is a collection of <see cref="P:Robust.Client.Animations.Animation.AnimationTracks"/>, which are all executed in sync.
            </remarks>
            <seealso cref="T:Robust.Client.GameObjects.AnimationPlayerComponent"/>
        </member>
        <member name="T:Robust.Client.Animations.AnimationPlaybackShared">
            <summary>
                Infrastructure to handle playback of animations.
            </summary>
        </member>
        <member name="T:Robust.Client.Animations.AnimationPlaybackShared.AnimationPlayback">
            <summary>
                Represents an "active" playback of an animation.
            </summary>
        </member>
        <member name="F:Robust.Client.Animations.AnimationPlaybackShared.AnimationPlayback.Animation">
            <summary>
                The animation being played.
            </summary>
        </member>
        <member name="T:Robust.Client.Animations.AnimationTrack">
            <summary>
                A single track of an <see cref="T:Robust.Client.Animations.Animation"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.Animations.AnimationTrack.InitPlayback">
            <summary>
                Return the values necessary to initialize a playback.
            </summary>
            <returns>
                A tuple containing the new key frame the animation track is on and the new time left in said key frame.
            </returns>
        </member>
        <member name="M:Robust.Client.Animations.AnimationTrack.AdvancePlayback(System.Object,System.Int32,System.Single,System.Single)">
            <summary>
                Advance this animation track's playback.
            </summary>
            <param name="context">The object this animation track is being played on, e.g. an entity.</param>
            <param name="prevKeyFrameIndex">The key frame this animation track is on.</param>
            <param name="prevPlayingTime">The amount of time this keyframe has been running.</param>
            <param name="frameTime">The amount of time to increase.</param>
            <returns>
                A tuple containing the new key frame the animation track is on and the current time on said key frame.
            </returns>
        </member>
        <member name="T:Robust.Client.Animations.AnimationTrackPlaySound">
            <summary>
                An animation track that plays a sound as keyframes.
            </summary>
        </member>
        <member name="P:Robust.Client.Animations.AnimationTrackPlaySound.KeyFrames">
            <summary>
                A list of key frames for when to fire flicks.
            </summary>
        </member>
        <member name="F:Robust.Client.Animations.AnimationTrackPlaySound.KeyFrame.Resource">
            <summary>
                The RSI state to play when this keyframe gets triggered.
            </summary>
        </member>
        <member name="F:Robust.Client.Animations.AnimationTrackPlaySound.KeyFrame.AudioParamsFunc">
            <summary>
                A function that returns the audio parameter to be used.
                The reason this is a function is so that this can return
                an AudioParam with different parameters each time, such as random pitch.
            </summary>
        </member>
        <member name="F:Robust.Client.Animations.AnimationTrackPlaySound.KeyFrame.KeyTime">
            <summary>
                The time between this keyframe and the last.
            </summary>
        </member>
        <member name="T:Robust.Client.Animations.AnimationTrackProperty">
            <summary>
                Animation that changes the value of a property based on keyframes.
            </summary>
        </member>
        <member name="P:Robust.Client.Animations.AnimationTrackProperty.InterpolationMode">
            <summary>
                How to interpolate values when between two keyframes.
            </summary>
        </member>
        <member name="F:Robust.Client.Animations.AnimationTrackProperty.KeyFrame.Value">
            <summary>
                The value of the property at this keyframe.
            </summary>
        </member>
        <member name="F:Robust.Client.Animations.AnimationTrackProperty.KeyFrame.KeyTime">
            <summary>
                The time between this keyframe and the previous.
            </summary>
        </member>
        <member name="T:Robust.Client.Animations.AnimationTrackSpriteFlick">
            <summary>
                An animation track that plays RSI state animations manually, so they can be precisely controlled etc.
            </summary>
        </member>
        <member name="P:Robust.Client.Animations.AnimationTrackSpriteFlick.KeyFrames">
            <summary>
                A list of key frames for when to fire flicks.
            </summary>
        </member>
        <member name="P:Robust.Client.Animations.AnimationTrackSpriteFlick.LayerKey">
            <summary>
                The layer key of the layer to flick on.
            </summary>
        </member>
        <member name="F:Robust.Client.Animations.AnimationTrackSpriteFlick.KeyFrame.State">
            <summary>
                The RSI state to play when this keyframe gets triggered.
            </summary>
        </member>
        <member name="F:Robust.Client.Animations.AnimationTrackSpriteFlick.KeyFrame.KeyTime">
            <summary>
                The time between this keyframe and the last.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.AudioManager.LogALError(Robust.Client.Audio.AudioManager.ALErrorInterpolatedStringHandler,System.String,System.Int32)">
            <summary>
            Like _checkAlError but allows custom data to be passed in as relevant.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.AudioManager.GetAttenuationGain(System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioManager.SetVelocity(System.Numerics.Vector2)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.Audio.AudioManager.SetPosition(System.Numerics.Vector2)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.Audio.AudioManager.SetRotation(Robust.Shared.Maths.Angle)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.Audio.AudioManager.LoadAudioOggVorbis(System.IO.Stream,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.Audio.AudioManager.LoadAudioWav(System.IO.Stream,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.Audio.AudioManager.LoadAudioRaw(System.ReadOnlySpan{System.Int16},System.Int32,System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.Audio.AudioManager.Robust#Client#Audio#IAudioInternal#CreateBufferedAudioSource(System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.Audio.AudioManager.StopAllAudio">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.Audio.AudioOverlay">
            <summary>
            Debug overlay for audio.
            </summary>
        </member>
        <member name="T:Robust.Client.Audio.AudioStream">
            <summary>
            Has the metadata for a particular audio stream as well as the relevant internal handle to it.
            </summary>
        </member>
        <member name="F:Robust.Client.Audio.AudioSystem._streams">
            <summary>
            Per-tick cache of relevant streams.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.SetMasterVolume(System.Single)">
            <summary>
            Sets the volume for the entire game.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.GetOcclusion(Robust.Shared.Map.MapCoordinates,System.Numerics.Vector2,System.Single,System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Gets the audio occlusion from the target audio entity to the listener's position.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayPredicted(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayGlobal(System.String,System.Nullable{Robust.Shared.Audio.AudioParams},System.Boolean)">
            <summary>
                Play an audio file globally, without position.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="audioParams"></param>
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayGlobal(Robust.Client.Audio.AudioStream,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
                Play an audio stream globally, without position.
            </summary>
            <param name="stream">The audio stream to play.</param>
            <param name="audioParams"></param>
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayEntity(System.String,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams},System.Boolean)">
            <summary>
                Play an audio file following an entity.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="entity">The entity "emitting" the audio.</param>
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayEntity(Robust.Client.Audio.AudioStream,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
                Play an audio stream following an entity.
            </summary>
            <param name="stream">The audio stream to play.</param>
            <param name="entity">The entity "emitting" the audio.</param>
            <param name="audioParams"></param>
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayStatic(System.String,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams},System.Boolean)">
            <summary>
                Play an audio file at a static position.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="coordinates">The coordinates at which to play the audio.</param>
            <param name="audioParams"></param>
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayStatic(Robust.Client.Audio.AudioStream,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
                Play an audio stream at a static position.
            </summary>
            <param name="stream">The audio stream to play.</param>
            <param name="coordinates">The coordinates at which to play the audio.</param>
            <param name="audioParams"></param>
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayGlobal(System.String,Robust.Shared.Player.Filter,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayEntity(System.String,Robust.Shared.Player.Filter,Robust.Shared.GameObjects.EntityUid,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayStatic(System.String,Robust.Shared.Player.Filter,Robust.Shared.Map.EntityCoordinates,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayGlobal(System.String,Robust.Shared.Player.ICommonSession,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayGlobal(System.String,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayEntity(System.String,Robust.Shared.Player.ICommonSession,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayEntity(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayStatic(System.String,Robust.Shared.Player.ICommonSession,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.PlayStatic(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.AudioSystem.ApplyAudioParams(Robust.Shared.Audio.AudioParams,Robust.Shared.Audio.Sources.IAudioSource)">
            <summary>
            Applies the audioparams to the underlying audio source.
            </summary>
        </member>
        <member name="T:Robust.Client.Audio.Effects.AudioEffect">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.Density">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.Diffusion">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.Gain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.GainHF">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.GainLF">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.DecayTime">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.DecayHFRatio">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.DecayLFRatio">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.ReflectionsGain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.ReflectionsDelay">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.ReflectionsPan">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.LateReverbGain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.LateReverbDelay">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.LateReverbPan">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.EchoTime">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.EchoDepth">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.ModulationTime">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.ModulationDepth">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.AirAbsorptionGainHF">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.HFReference">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.LFReference">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.RoomRolloffFactor">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Effects.AudioEffect.DecayHFLimit">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.Audio.Effects.AuxiliaryAudio">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.Effects.AuxiliaryAudio.SetEffect(Robust.Shared.Audio.Effects.IAudioEffect)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.Audio.HeadlessAudioManager">
            <summary>
            Headless client audio.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.InitializePostWindowing">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.Shutdown">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.FlushALDisposeQueues">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.CreateAudioSource(Robust.Client.Audio.AudioStream)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.CreateBufferedAudioSource(System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.SetVelocity(System.Numerics.Vector2)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.SetPosition(System.Numerics.Vector2)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.SetRotation(Robust.Shared.Maths.Angle)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.SetMasterGain(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.SetAttenuation(Robust.Shared.Audio.Attenuation)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.StopAllAudio">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.SetZOffset(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager._checkAlError(System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.HeadlessAudioManager.GetAttenuationGain(System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.Audio.IAudioInternal">
            <summary>
            Handles clientside audio.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.IAudioInternal.FlushALDisposeQueues">
            <summary>
            Flushes all pending queues for disposing of AL sources.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.IAudioInternal.CreateBufferedAudioSource(System.Int32,System.Boolean)">
            <summary>
            Returns a buffered audio source.
            </summary>
            <returns>null if unable to create the source.</returns>
        </member>
        <member name="M:Robust.Client.Audio.IAudioInternal.SetVelocity(System.Numerics.Vector2)">
            <summary>
            Sets the velocity for the audio listener.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.IAudioInternal.SetPosition(System.Numerics.Vector2)">
            <summary>
            Sets position for the audio listener.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.IAudioInternal.SetRotation(Robust.Shared.Maths.Angle)">
            <summary>
            Sets rotation for the audio listener.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.IAudioInternal.StopAllAudio">
            <summary>
            Stops all audio from playing.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.IAudioInternal.SetZOffset(System.Single)">
            <summary>
            Sets the Z-offset for the audio listener.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.IAudioInternal.GetAttenuationGain(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Manually calculates the specified gain for an attenuation source with the specified distance.
            </summary>
        </member>
        <member name="T:Robust.Client.Audio.IAudioManager">
            <summary>
            Public audio API for stuff that can't go through <see cref="T:Robust.Client.Audio.AudioSystem"/>
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiManager.Renderers">
            <summary>
                A read-only list of all existing MIDI Renderers.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiManager.IsAvailable">
            <summary>
                If true, MIDI support is available.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiManager.Gain">
            <summary>
                Gain of audio.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiManager.GetNewRenderer(System.Boolean)">
            <summary>
                This method tries to return a midi renderer ready to be used.
                You only need to set the <see cref="P:Robust.Client.Audio.Midi.IMidiRenderer.MidiProgram"/> afterwards.
            </summary>
            <remarks>
                This method can fail if MIDI support is not available.
            </remarks>
            <returns>
                <c>null</c> if MIDI support is not available.
            </returns>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiManager.FromFluidEvent(NFluidsynth.MidiEvent,System.UInt32)">
            <summary>
                Creates a <see cref="T:Robust.Shared.Audio.Midi.RobustMidiEvent"/> given a <see cref="T:NFluidsynth.MidiEvent"/> and a sequencer tick.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiManager.ToSequencerEvent(Robust.Shared.Audio.Midi.RobustMidiEvent)">
            <summary>
                Creates a <see cref="T:NFluidsynth.SequencerEvent"/> given a <see cref="T:Robust.Shared.Audio.Midi.RobustMidiEvent"/>.
                Be sure to dispose of the result after you've used it.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiManager.FromSequencerEvent(NFluidsynth.SequencerEvent,System.UInt32)">
            <summary>
                Creates a <see cref="T:Robust.Shared.Audio.Midi.RobustMidiEvent"/> given a <see cref="T:NFluidsynth.SequencerEvent"/> and a sequencer tick.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiManager.FrameUpdate(System.Single)">
            <summary>
                Method called every frame.
                Should be used to update positional audio.
            </summary>
            <param name="frameTime"></param>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.Source">
            <summary>
                The buffered audio source of this renderer.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.Disposed">
            <summary>
                Whether this renderer has been disposed or not.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.LoopMidi">
            <summary>
                This controls whether the midi file being played will loop or not.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.VolumeBoost">
            <summary>
                This increases all note on velocities to 127.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.MidiProgram">
            <summary>
                The midi program (instrument) the renderer is using.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.MidiBank">
            <summary>
                The instrument bank the renderer is using.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.MidiSoundfont">
            <summary>
                The soundfont currently selected by the renderer.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.Status">
            <summary>
                The current status of the renderer.
                "None" if the renderer isn't playing from input or a midi file.
                "Input" if the renderer is playing from midi input.
                "File" if the renderer is playing from a midi file.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.Mono">
            <summary>
                Whether the sound will play in stereo or mono.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.DisablePercussionChannel">
            <summary>
                Whether to drop messages on the percussion channel.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.DisableProgramChangeEvent">
            <summary>
            Whether to drop messages for program change events.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.PlayerTotalTick">
            <summary>
                Gets the total number of ticks possible for the MIDI player.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.PlayerTick">
            <summary>
                Gets or sets (seeks) the current tick of the MIDI player.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.SequencerTick">
            <summary>
                Gets the current tick of the sequencer.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.SequencerTimeScale">
            <summary>
                Gets the Time Scale of the sequencer in ticks per second. Default is 1000 for 1 tick per millisecond.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.Master">
            <summary>
                Whether this renderer will subscribe to another and copy its events.
                See <see cref="P:Robust.Client.Audio.Midi.IMidiRenderer.FilteredChannels"/> to filter specific channels.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.FilteredChannels">
            <summary>
                Allows you to filter out note events from certain channels.
                Only NoteOn will be filtered.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.VelocityOverride">
            <summary>
                Allows you to override all NoteOn velocities. Set to null to disable.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.OpenInput">
            <summary>
                Start listening for midi input.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.OpenMidi(System.ReadOnlySpan{System.Byte})">
            <summary>
                Start playing a midi file.
            </summary>
            <param name="buffer">Bytes of the midi file</param>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.CloseInput">
            <summary>
                Stops listening for midi input.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.CloseMidi">
            <summary>
                Stops playing midi files.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.StopAllNotes">
            <summary>
                Stops all notes being played currently.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.SystemReset">
            <summary>
                Reset renderer back to a clean state.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.ClearAllEvents">
            <summary>
            Clears all scheduled events.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.Render">
            <summary>
                Render and play MIDI to the audio source.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.LoadSoundfont(System.String,System.Boolean)">
            <summary>
                Loads a new soundfont into the renderer.
            </summary>
        </member>
        <member name="E:Robust.Client.Audio.Midi.IMidiRenderer.OnMidiEvent">
            <summary>
                Invoked whenever a new midi event is registered.
            </summary>
        </member>
        <member name="E:Robust.Client.Audio.Midi.IMidiRenderer.OnMidiPlayerFinished">
            <summary>
                Invoked when the midi player finishes playing a song.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.TrackingEntity">
            <summary>
                The entity whose position will be used for positional audio.
                This is only used if <see cref="P:Robust.Client.Audio.Midi.IMidiRenderer.Mono"/> is set to True.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Midi.IMidiRenderer.TrackingCoordinates">
            <summary>
                The position that will be used for positional audio.
                This is only used if <see cref="P:Robust.Client.Audio.Midi.IMidiRenderer.Mono"/> is set to True
                and <see cref="P:Robust.Client.Audio.Midi.IMidiRenderer.TrackingEntity"/> is null.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.SendMidiEvent(Robust.Shared.Audio.Midi.RobustMidiEvent,System.Boolean)">
            <summary>
                Send a midi event for the renderer to play.
            </summary>
            <param name="midiEvent">The midi event to be played</param>
            <param name="raiseEvent">Whether to raise an event for this event.</param>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.ScheduleMidiEvent(Robust.Shared.Audio.Midi.RobustMidiEvent,System.UInt32,System.Boolean)">
            <summary>
                Schedule a MIDI event to be played at a later time.
            </summary>
            <param name="midiEvent">the midi event in question</param>
            <param name="time"></param>
            <param name="absolute"></param>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.ApplyState(Robust.Client.Audio.Midi.MidiRendererState,System.Boolean)">
            <summary>
                Apply a certain state to the renderer.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.IMidiRenderer.InternalDispose">
            <summary>
                Actually disposes of this renderer. Do NOT use outside the MIDI thread.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.MidiManager.ThreadUpdate">
            <summary>
                Main method for the thread rendering the midi audio.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.MidiManager.SequencerEventToString(NFluidsynth.SequencerEvent)">
            <summary>
                Internal method to get a human-readable representation of a <see cref="T:NFluidsynth.SequencerEvent"/>.
            </summary>
        </member>
        <member name="T:Robust.Client.Audio.Midi.MidiManager.ResourceLoaderCallbacks">
            <summary>
                This class is used to load soundfonts.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Midi.MidiRenderer.Robust#Client#Audio#Midi#IMidiRenderer#InternalDispose">
            <inheritdoc />
        </member>
        <member name="F:Robust.Client.Audio.Sources.AudioSource._sourceStream">
            <summary>
            Underlying stream to the audio.
            </summary>
        </member>
        <member name="P:Robust.Client.Audio.Sources.AudioSource.Position">
            <inheritdoc />
        </member>
        <member name="F:Robust.Client.Audio.Sources.BaseAudioSource.SourceHandle">
            <summary>
            Handle to the AL source.
            </summary>
        </member>
        <member name="F:Robust.Client.Audio.Sources.BaseAudioSource.FilterHandle">
            <summary>
            Source to the EFX filter if applicable.
            </summary>
        </member>
        <member name="F:Robust.Client.Audio.Sources.BaseAudioSource._gain">
            <summary>
            Prior gain that was set.
            </summary>
        </member>
        <member name="M:Robust.Client.Audio.Sources.BaseAudioSource.Pause">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.Sources.BaseAudioSource.StartPlaying">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.Sources.BaseAudioSource.StopPlaying">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Audio.Sources.BaseAudioSource.Restart">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.Playing">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.Looping">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.Global">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.Position">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.Pitch">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.Volume">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.Gain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.MaxDistance">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.RolloffFactor">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.ReferenceDistance">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.Occlusion">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.PlaybackPosition">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BaseAudioSource.Velocity">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Audio.Sources.BufferedAudioSource.Playing">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.Commands.ShowAudioCommand">
            <summary>
            Shows a debug overlay for audio sources.
            </summary>
        </member>
        <member name="T:Robust.Client.BaseClient">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.BaseClient.DefaultPort">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.BaseClient.RunLevel">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.BaseClient.GameInfo">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.BaseClient.PlayerNameOverride">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.BaseClient.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.BaseClient.ConnectToServer(System.Net.DnsEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.BaseClient.DisconnectFromServer(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.BaseClient.StartSinglePlayer">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.BaseClient.StopSinglePlayer">
            <inheritdoc />
        </member>
        <member name="E:Robust.Client.BaseClient.RunLevelChanged">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.BaseClient.OnPlayerJoinedServer(Robust.Shared.Player.ICommonSession)">
            <summary>
                Player session is fully built, player is an active member of the server. Player is prepared to start
                receiving states when they join the lobby.
            </summary>
            <param name="session">Session of the player.</param>
        </member>
        <member name="M:Robust.Client.BaseClient.OnPlayerJoinedGame(Robust.Shared.Player.ICommonSession)">
            <summary>
                Player is joining the game
            </summary>
            <param name="session">Session of the player.</param>
        </member>
        <member name="T:Robust.Client.ClientRunLevel">
            <summary>
                Enumeration of the run levels of the BaseClient.
            </summary>
            <seealso cref="T:Robust.Client.ClientRunLevelExt"/>
        </member>
        <member name="F:Robust.Client.ClientRunLevel.Initialize">
            <summary>
                The client has not started connecting to a server (on main menu).
            </summary>
        </member>
        <member name="F:Robust.Client.ClientRunLevel.Connecting">
            <summary>
                The client started connecting to the server, and is in the process of building the session.
            </summary>
        </member>
        <member name="F:Robust.Client.ClientRunLevel.Connected">
            <summary>
                The client has successfully finished connecting to the server.
            </summary>
        </member>
        <member name="F:Robust.Client.ClientRunLevel.InGame">
            <summary>
                The client is now in the game, moving around.
            </summary>
        </member>
        <member name="F:Robust.Client.ClientRunLevel.SinglePlayerGame">
            <summary>
                The client is now in singleplayer mode, in-game.
            </summary>
        </member>
        <member name="T:Robust.Client.ClientRunLevelExt">
            <summary>
            Helper functions for working with <see cref="T:Robust.Client.ClientRunLevel"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.ClientRunLevelExt.IsInGameLike(Robust.Client.ClientRunLevel)">
            <summary>
            Check if a <see cref="T:Robust.Client.ClientRunLevel"/> is <see cref="F:Robust.Client.ClientRunLevel.InGame"/>
            or <see cref="F:Robust.Client.ClientRunLevel.SinglePlayerGame"/>.
            </summary>
        </member>
        <member name="T:Robust.Client.PlayerEventArgs">
            <summary>
                Event arguments for when something changed with the player.
            </summary>
        </member>
        <member name="P:Robust.Client.PlayerEventArgs.Session">
            <summary>
                The session that triggered the event.
            </summary>
        </member>
        <member name="M:Robust.Client.PlayerEventArgs.#ctor(Robust.Shared.Player.ICommonSession)">
            <summary>
                Constructs a new instance of the class.
            </summary>
        </member>
        <member name="T:Robust.Client.RunLevelChangedEventArgs">
            <summary>
                Event arguments for when the RunLevel has changed in the BaseClient.
            </summary>
        </member>
        <member name="P:Robust.Client.RunLevelChangedEventArgs.OldLevel">
            <summary>
                RunLevel that the BaseClient switched from.
            </summary>
        </member>
        <member name="P:Robust.Client.RunLevelChangedEventArgs.NewLevel">
            <summary>
                RunLevel that the BaseClient switched to.
            </summary>
        </member>
        <member name="M:Robust.Client.RunLevelChangedEventArgs.#ctor(Robust.Client.ClientRunLevel,Robust.Client.ClientRunLevel)">
            <summary>
                Constructs a new instance of the class.
            </summary>
        </member>
        <member name="T:Robust.Client.ServerInfo">
            <summary>
                Info about the server and player that is sent to the client while connecting.
            </summary>
        </member>
        <member name="P:Robust.Client.ServerInfo.ServerName">
            <summary>
                Current name of the server.
            </summary>
        </member>
        <member name="P:Robust.Client.ServerInfo.ServerMaxPlayers">
            <summary>
                Max number of players that are allowed in the server at one time.
            </summary>
        </member>
        <member name="T:Robust.Client.ClientWarmup">
            <summary>
            Logic for "warming up" things like slow static constructors concurrently.
            </summary>
        </member>
        <member name="M:Robust.Client.ComponentTrees.LightTreeComponent.InternalCopy(Robust.Client.ComponentTrees.LightTreeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.LightTreeComponent.Copy(Robust.Client.ComponentTrees.LightTreeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.LightTreeComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.LightTreeComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.LightTreeComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.LightTreeComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.LightTreeComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.SpriteTreeComponent.InternalCopy(Robust.Client.ComponentTrees.SpriteTreeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.SpriteTreeComponent.Copy(Robust.Client.ComponentTrees.SpriteTreeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.SpriteTreeComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.SpriteTreeComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.SpriteTreeComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.SpriteTreeComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.ComponentTrees.SpriteTreeComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Configuration.ClientNetConfigurationManager.SetCVar(System.String,System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Configuration.ClientNetConfigurationManager.GetClientCVar``1(Robust.Shared.Network.INetChannel,System.String)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.Configuration.IClientNetConfigurationManager">
            <summary>
            A networked configuration manager that controls the replication of
            console variables between client and server.
            </summary>
        </member>
        <member name="M:Robust.Client.Configuration.IClientNetConfigurationManager.SyncWithServer">
            <summary>
            Synchronize the CVars marked with <see cref="F:Robust.Shared.Configuration.CVar.REPLICATED"/> with the server.
            This needs to be called once when connecting.
            </summary>
        </member>
        <member name="M:Robust.Client.Configuration.IClientNetConfigurationManager.ClearReceivedInitialNwVars">
            <summary>
                Clears internal flag for <see cref="E:Robust.Client.Configuration.IClientNetConfigurationManager.ReceivedInitialNwVars"/>.
                Must be called upon disconnect.
            </summary>
        </member>
        <member name="T:Robust.Client.Console.ClientConsoleHost">
            <inheritdoc cref="T:Robust.Client.Console.IClientConsoleHost" />
        </member>
        <member name="M:Robust.Client.Console.ClientConsoleHost.Initialize">
            <inheritdoc />
        </member>
        <member name="E:Robust.Client.Console.ClientConsoleHost.AddString">
            <inheritdoc />
        </member>
        <member name="E:Robust.Client.Console.ClientConsoleHost.AddFormatted">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Console.ClientConsoleHost.AddFormattedLine(Robust.Shared.Utility.FormattedMessage)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Console.ClientConsoleHost.WriteError(Robust.Shared.Player.ICommonSession,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Console.ClientConsoleHost.ExecuteCommand(Robust.Shared.Player.ICommonSession,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Console.ClientConsoleHost.RemoteExecuteCommand(Robust.Shared.Player.ICommonSession,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Console.ClientConsoleHost.WriteLine(Robust.Shared.Player.ICommonSession,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Console.ClientConsoleHost.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Console.ClientConsoleHost.SendServerCommandRequest">
            <summary>
            Requests remote commands from server.
            </summary>
        </member>
        <member name="T:Robust.Client.Console.ClientConsoleHost.ServerDummyCommand">
            <summary>
            These dummies are made purely so list and help can list server-side commands.
            </summary>
        </member>
        <member name="M:Robust.Client.Console.IClientConsoleHost.Initialize">
            <summary>
            Initializes the console into a useable state.
            </summary>
        </member>
        <member name="T:Robust.Client.Console.IScriptClient">
            <summary>
                Client manager for server side scripting.
            </summary>
        </member>
        <member name="T:Robust.Client.Credits.CreditsManager">
            <summary>
                Contains credits information about the engine.
            </summary>
        </member>
        <member name="M:Robust.Client.Credits.CreditsManager.GetLicenses">
            <summary>
                Gets a list of open source software used in the engine and their license.
            </summary>
        </member>
        <member name="M:Robust.Client.Credits.CreditsManager.GetLicenses(Robust.Shared.ContentPack.IResourceManager)">
            <summary>
                Gets a list of open source software used in the engine and their license.
            </summary>
        </member>
        <member name="P:Robust.Client.Credits.CreditsManager.LicenseEntry.Name">
            <summary>
                Name of the software used.
            </summary>
        </member>
        <member name="P:Robust.Client.Credits.CreditsManager.LicenseEntry.License">
            <summary>
                The full license text of the project.
            </summary>
        </member>
        <member name="T:Robust.Client.Debugging.DebugDrawingSystem">
            <summary>
            A collection of visual debug overlays for the client game.
            </summary>
        </member>
        <member name="P:Robust.Client.Debugging.DebugDrawingSystem.DebugPositions">
            <summary>
            Toggles the visual overlay of the local origin for each entity on screen.
            </summary>
        </member>
        <member name="P:Robust.Client.Debugging.DebugDrawingSystem.DebugRotations">
            <summary>
            Toggles the visual overlay of the local rotation.
            </summary>
        </member>
        <member name="F:Robust.Client.Debugging.PhysicsDebugFlags.ContactPoints">
            <summary>
            Shows the world point for each contact in the viewport.
            </summary>
        </member>
        <member name="F:Robust.Client.Debugging.PhysicsDebugFlags.ContactNormals">
            <summary>
            Shows the world normal for each contact in the viewport.
            </summary>
        </member>
        <member name="F:Robust.Client.Debugging.PhysicsDebugFlags.Shapes">
            <summary>
            Shows all physics shapes in the viewport.
            </summary>
        </member>
        <member name="F:Robust.Client.Debugging.PhysicsDebugFlags.COM">
            <summary>
            Shows Center of Mass for all bodies in the viewport.
            </summary>
        </member>
        <member name="F:Robust.Client.Debugging.PhysicsDebugFlags.Distance">
            <summary>
            Shows nearest edge from target to player.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Robust.Client.GameControllerOptions.Sandboxing" -->
        <member name="P:Robust.Client.GameControllerOptions.MountOptions">
            <summary>
                Lists of mount options to mount.
            </summary>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.UserDataDirectoryName">
            <summary>
                Name the userdata directory will have.
            </summary>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.ConfigFileName">
            <summary>
                Name of the configuration file in the user data directory.
            </summary>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.DefaultWindowTitle">
            <summary>
                Default window title.
            </summary>
            <remarks>
            Defaults to <c>RobustToolbox</c> if unset.
            </remarks>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.ContentModulePrefix">
            <summary>
                Assemblies with this prefix will be loaded.
            </summary>
            <remarks>
            Defaults to <c>Content.</c> if unset.
            </remarks>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.ContentBuildDirectory">
            <summary>
                Name of the content build directory, for game pack mounting purposes.
            </summary>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.AssemblyDirectory">
            <summary>
                Directory to load all assemblies from.
            </summary>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.PrototypeDirectory">
            <summary>
                Directory to load all prototypes from.
            </summary>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.WindowIconSet">
            <summary>
            Directory resource path containing window icons to load.
            </summary>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.SplashLogo">
            <summary>
            Resource path for splash image to show when the game starts up.
            </summary>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.ResourceMountDisabled">
            <summary>
                Whether to disable mounting the "Resources/" folder on FULL_RELEASE.
            </summary>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.LoadContentResources">
            <summary>
                Whether to mount content resources when not on FULL_RELEASE.
            </summary>
        </member>
        <member name="P:Robust.Client.GameControllerOptions.LoadConfigAndUserData">
            <summary>
                Whether to load config and user data.
            </summary>
        </member>
        <member name="M:Robust.Client.GameController.KeyDown(Robust.Client.Input.KeyEventArgs)">
            <summary>
                Invoked when a key on the keyboard or a mouse button is pressed down.
            </summary>
        </member>
        <member name="M:Robust.Client.GameController.KeyUp(Robust.Client.Input.KeyEventArgs)">
            <summary>
                Invoked when a key on the keyboard or a mouse button is released.
            </summary>
        </member>
        <member name="M:Robust.Client.GameController.MouseMove(Robust.Client.Input.MouseMoveEventArgs)">
            <summary>
                Invoked when the mouse is moved inside the game window.
            </summary>
        </member>
        <member name="M:Robust.Client.GameController.MouseWheel(Robust.Client.Input.MouseWheelEventArgs)">
            <summary>
                Invoked when the mouse wheel is moved.
            </summary>
        </member>
        <member name="M:Robust.Client.GameController.CreateModuleLoadContext(System.String)">
            <summary>
            Creates an <see cref="T:System.Runtime.Loader.AssemblyLoadContext"/> that loads from an engine module directory.
            </summary>
        </member>
        <member name="T:Robust.Client.GameObjects.ClientEntityManager">
            <summary>
            Manager for entities -- controls things like template loading and instantiation
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.DirtyEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.Dirty(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.Dirty``1(Robust.Shared.GameObjects.Entity{``0},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.Dirty``2(Robust.Shared.GameObjects.Entity{``0,``1},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.Dirty``3(Robust.Shared.GameObjects.Entity{``0,``1,``2},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.Dirty``4(Robust.Shared.GameObjects.Entity{``0,``1,``2,``3},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.RaiseSharedEvent``1(``0,System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.RaiseSharedEvent``1(``0,Robust.Shared.Player.ICommonSession)">
            <inheritdoc />
        </member>
        <member name="E:Robust.Client.GameObjects.ClientEntityManager.ReceivedSystemMessage">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.SetupNetworking">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.SendSystemNetworkMessage(Robust.Shared.GameObjects.EntityEventArgs,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.ClientEntityManager.SendSystemNetworkMessage(Robust.Shared.GameObjects.EntityEventArgs,Robust.Shared.Network.INetChannel)">
            <inheritdoc />
        </member>
        <member name="F:Robust.Client.GameObjects.ClientEntityManager.PendingNetEntityStates">
            <summary>
            If the client fails to resolve a NetEntity then during component state handling or the likes we
            flag that comp state as requiring re-running if that NetEntity comes in.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Robust.Client.GameObjects.AnimationPlayerComponent">
            <summary>
                Plays back <see cref="T:Robust.Client.Animations.Animation"/>s on entities.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.AnimationPlayerComponent.InternalCopy(Robust.Client.GameObjects.AnimationPlayerComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.AnimationPlayerComponent.Copy(Robust.Client.GameObjects.AnimationPlayerComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.AnimationPlayerComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.AnimationPlayerComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.AnimationPlayerComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.AnimationPlayerComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.AnimationPlayerComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Client.GameObjects.GenericVisualizerComponent">
            <summary>
                This component can be used to apply generic changes to an entity's sprite component as a result of appearance
                data changes.
            </summary>
        </member>
        <member name="F:Robust.Client.GameObjects.GenericVisualizerComponent.Visuals">
             <summary>
                 This is a nested dictionary that maps appearance data keys -> sprite layer keys -> appearance data values -> layer data.
                 While somewhat convoluted, this enables the sprite layer data to be completely modified using only yaml.
            
                 In most instances, each of these dictionaries will probably only have a single entry.
             </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.GenericVisualizerComponent.InternalCopy(Robust.Client.GameObjects.GenericVisualizerComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.GenericVisualizerComponent.Copy(Robust.Client.GameObjects.GenericVisualizerComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.GenericVisualizerComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.GenericVisualizerComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.GenericVisualizerComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.GenericVisualizerComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.GenericVisualizerComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Client.GameObjects.IconComponent">
            <summary>
            This component can be used to give an entity a simple texture which can be used for displaying the entity in some
            UI elements. The texture must be specified as an RSI state, and will correspond to the first frame of the
            south-direction. To actually resolve the texture, you can use <see cref="M:Robust.Client.GameObjects.SpriteSystem.GetIcon(Robust.Client.GameObjects.IconComponent)"/>
            </summary>
            <remarks>
            This is texture is useful displaying entities that have non-trivial sprites that require some sort of set up in
            order to display. E.g., entities that randomize their colour by modulating a simple base sprite will look odd if
            shown directly, and spawning a client-side entity would lead to the colour being randomized each time the UI is
            updated.
            </remarks>
        </member>
        <member name="M:Robust.Client.GameObjects.IconComponent.InternalCopy(Robust.Client.GameObjects.IconComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IconComponent.Copy(Robust.Client.GameObjects.IconComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IconComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IconComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IconComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IconComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IconComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Client.GameObjects.InputComponent">
            <summary>
                Defines data fields used in the <see cref="T:Robust.Client.GameObjects.InputSystem"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.InputComponent.ContextName">
            <summary>
                The context that will be made active for a client that attaches to this entity.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.InputComponent.InternalCopy(Robust.Client.GameObjects.InputComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.InputComponent.Copy(Robust.Client.GameObjects.InputComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.InputComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.InputComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.InputComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.InputComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.InputComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Robust.Client.GameObjects.PointLightComponent.TreeUid">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.GameObjects.PointLightComponent.Tree">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.GameObjects.PointLightComponent.AddToTree">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.GameObjects.PointLightComponent.TreeUpdateQueued">
            <inheritdoc />
        </member>
        <member name="F:Robust.Client.GameObjects.PointLightComponent.Mask">
            <summary>
                Set a mask texture that will be applied to the light while rendering.
                The mask's red channel will be linearly multiplied.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.PointLightComponent.InternalCopy(Robust.Client.GameObjects.PointLightComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.PointLightComponent.Copy(Robust.Client.GameObjects.PointLightComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.PointLightComponent.Copy(Robust.Shared.GameObjects.SharedPointLightComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.PointLightComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.PointLightComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.PointLightComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.PointLightComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IRenderableComponent.InternalCopy(Robust.Client.GameObjects.IRenderableComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IRenderableComponent.Copy(Robust.Client.GameObjects.IRenderableComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IRenderableComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IRenderableComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IRenderableComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.IRenderableComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Robust.Client.GameObjects.ISpriteLayer.PixelSize">
            <summary>
                Layer size in pixels.
                Don't account layer scale or sprite world transform.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.ISpriteLayer.CalculateBoundingBox">
            <summary>
                Calculate layer bounding box in sprite local-space coordinates.
            </summary>
            <returns>Bounding box in sprite local-space coordinates.</returns>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent.DirectionBias">
            <summary>
                See <see cref="!:CVars.RenderSpriteDirectionBias"/>.
            </summary>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent.GranularLayersRendering">
            <summary>
                Whether the layers have independant drawing strategies, e.g some may snap to cardinals while others won't.
                The sprite should still set its global rendering method (e.g NoRot or SnapCardinals), this only gives finer control over how layers are rendered internally.
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.SpriteComponent.DrawDepth">
            <summary>
                Z-index for drawing.
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.SpriteComponent.Scale">
            <summary>
                A scale applied to all layers.
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.SpriteComponent.Offset">
            <summary>
                Offset applied to all layers.
            </summary>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent.OverrideContainerOcclusion">
            <summary>
                Should this entity show up in containers regardless of whether the container can show contents?
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.SpriteComponent.Bounds">
            <summary>
                The bounds of the sprite. This does factor in the sprite's <see cref="P:Robust.Client.GameObjects.SpriteComponent.Scale"/> but not the
                <see cref="P:Robust.Client.GameObjects.SpriteComponent.Rotation"/> and <see cref="P:Robust.Client.GameObjects.SpriteComponent.Offset"/>
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.SpriteComponent.PostShader">
            <summary>
                Shader instance to use when drawing the final sprite to the world.
            </summary>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent._getScreenTexture">
            <summary>
                Whether or not to pass the screen texture to the <see cref="P:Robust.Client.GameObjects.SpriteComponent.PostShader"/>.
            </summary>
            <remarks>
                Should be false unless you really need it.
            </remarks>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent.RaiseShaderEvent">
            <summary>
                If true, this raise a entity system event before rendering this sprite, allowing systems to modify the
                shader parameters. Usually this can just be done via a frame-update, but some shaders require
                information about the viewport / eye.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.CopyFrom(Robust.Client.GameObjects.SpriteComponent)">
            <summary>
            Update this sprite component to visibly match the current state of other at the time
            this is called. Does not keep them perpetually in sync.
            This does some deep copying thus exerts some gc pressure, so avoid this for hot code paths.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.LayerMapSet(System.Object,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.LayerMapRemove(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.LayerMapGet(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.LayerMapTryGet(System.Object,System.Int32@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.AddLayer(Robust.Shared.GameObjects.PrototypeLayerData,System.Nullable{System.Int32})">
            <summary>
                Add a new layer based on some <see cref="T:Robust.Shared.GameObjects.PrototypeLayerData"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.LayerSetData(System.Int32,Robust.Shared.GameObjects.PrototypeLayerData)">
            <summary>
                Fills in a layer's values using some <see cref="T:Robust.Shared.GameObjects.PrototypeLayerData"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.LayerGetState(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.GameObjects.SpriteComponent.SnapCardinals">
            <summary>
            If the sprite only has 1 direction should it snap at cardinals if rotated.
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.SpriteComponent.NoRotation">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.CalculateRotatedBoundingBox(System.Numerics.Vector2,Robust.Shared.Maths.Angle,Robust.Shared.Maths.Angle)">
            <inheritdoc/>
        </member>
        <member name="T:Robust.Client.GameObjects.SpriteComponent.DirectionOffset">
            <summary>
                Enum to "offset" a cardinal direction.
            </summary>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent.DirectionOffset.None">
            <summary>
                No offset.
            </summary>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent.DirectionOffset.Clockwise">
            <summary>
                Rotate direction clockwise. (North -> East, etc...)
            </summary>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent.DirectionOffset.CounterClockwise">
            <summary>
                Rotate direction counter-clockwise. (North -> West, etc...)
            </summary>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent.DirectionOffset.Flip">
            <summary>
                Rotate direction 180 degrees, so flip. (North -> South, etc...)
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.SpriteComponent.Layer.Reversed">
            <summary>
            Is the animation currently playing in reverse.
            </summary>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent.Layer.Cycle">
            <summary>
            If every animation delay finishes do we reverse it.
            </summary>
            <remarks>
            Only applies if the state is auto-animated.
            </remarks>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteComponent.Layer.RenderingStrategy">
            <summary>
               Whether the current layer have a specific rendering method (e.g no rotation or snap to cardinal)
               The sprite GranularLayersRendering var must be set to true for this to have any effect.
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.SpriteComponent.Layer.PixelSize">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.Layer.CalculateBoundingBox">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.Layer.UpdateActualState">
            <summary>
                Update Cached RSI state. State is cached to avoid calling this every time an entity gets drawn.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Client.GameObjects.SpriteComponent.Layer.GetLayerDrawMatrix(Robust.Shared.Graphics.RSI.RsiDirection,System.Numerics.Matrix3x2@)" -->
        <member name="M:Robust.Client.GameObjects.SpriteComponent.Layer.GetDirection(Robust.Shared.Graphics.RSI.RsiDirectionType,Robust.Shared.Maths.Angle)">
            <summary>
                Converts an angle (between 0 and 2pi) to an RSI direction. This will slightly bias the angle to avoid flickering for
                4-directional sprites.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.Layer.Render(Robust.Client.Graphics.DrawingHandleWorld,System.Numerics.Matrix3x2@,Robust.Shared.Maths.Angle,System.Nullable{Robust.Shared.Maths.Direction})">
            <summary>
                Render a layer. This assumes that the input angle is between 0 and 2pi.
            </summary>
        </member>
        <member name="T:Robust.Client.GameObjects.SpriteComponent.CopyToShaderParameters">
            <summary>
            Instantiated version of <see cref="T:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters"/>.
            Has <see cref="F:Robust.Client.GameObjects.SpriteComponent.CopyToShaderParameters.LayerKey"/> actually resolved to a a real key.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.CopyToShaderParameters.#ctor(System.Object)">
            <summary>
            Instantiated version of <see cref="T:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters"/>.
            Has <see cref="F:Robust.Client.GameObjects.SpriteComponent.CopyToShaderParameters.LayerKey"/> actually resolved to a a real key.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.InternalCopy(Robust.Client.GameObjects.SpriteComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.Copy(Robust.Client.GameObjects.SpriteComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.InternalCopy(Robust.Shared.GameObjects.IComponentDebug@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.Copy(Robust.Shared.GameObjects.IComponentDebug@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.GameObjects.AnimationPlayerSystem.Play(Robust.Shared.GameObjects.EntityUid,Robust.Client.Animations.Animation,System.String)">
            <summary>
                Start playing an animation.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.AnimationPlayerSystem.Play(Robust.Client.GameObjects.AnimationPlayerComponent,Robust.Client.Animations.Animation,System.String)">
            <summary>
                Start playing an animation.
            </summary>
        </member>
        <member name="T:Robust.Client.GameObjects.AnimationCompletedEvent">
            <summary>
            Raised whenever an animation stops, either due to running its course or being stopped manually.
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.AnimationCompletedEvent.Finished">
            <summary>
            If true, the animation finished by getting to its natural end.
            If false, it was removed prematurely via <see cref="M:Robust.Client.GameObjects.AnimationPlayerSystem.Stop(Robust.Client.GameObjects.AnimationPlayerComponent,System.String)"/> or similar overloads.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.AppearanceSystem.CloneAppearanceData(System.Collections.Generic.Dictionary{System.Enum,System.Object})">
            <summary>
                Take in an appearance data dictionary and attempt to clone it.
            </summary>
            <remarks>
                As some appearance data values are not simple value-type objects, this is not just a shallow clone.
            </remarks>
        </member>
        <member name="T:Robust.Client.GameObjects.AppearanceChangeEvent">
            <summary>
                Raised whenever the appearance data for an entity changes.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.ClientOccluderSystem.Initialize">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.GameObjects.ClientOccluderSystem.OccluderDirectionsEvent">
            <summary>
            Raised by occluders when trying to get occlusion directions.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.EyeSystem.FrameUpdate(System.Single)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.GameObjects.EyeAttachedEvent">
            <summary>
            Raised on an entity when it is attached to one with an <see cref="T:Robust.Shared.GameObjects.EyeComponent"/>
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.EyeAttachedEvent.#ctor(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EyeComponent)">
            <summary>
            Raised on an entity when it is attached to one with an <see cref="T:Robust.Shared.GameObjects.EyeComponent"/>
            </summary>
        </member>
        <member name="T:Robust.Client.GameObjects.GenericVisualizerSystem">
            <summary>
                A generic visualizer system that modifies sprite layer data.
            </summary>
        </member>
        <member name="T:Robust.Client.GameObjects.InputSystem">
            <summary>
                Client-side processing of all input commands through the simulation.
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.InputSystem.CmdStates">
            <summary>
                Current states for all of the keyFunctions.
            </summary>
        </member>
        <member name="P:Robust.Client.GameObjects.InputSystem.Predicted">
            <summary>
            If the input system is currently predicting input.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.InputSystem.HandleInputCommand(Robust.Shared.Player.ICommonSession,Robust.Shared.Input.BoundKeyFunction,Robust.Shared.Input.IFullInputCmdMessage,System.Boolean)">
            <summary>
                Inserts an Input Command into the simulation.
            </summary>
            <param name="session">Player session that raised the command. On client, this is always the LocalPlayer session.</param>
            <param name="function">Function that is being changed.</param>
            <param name="message">Arguments for this event.</param>
            <param name="replay">if true, current cmd state will not be checked or updated - use this for "replaying" an
            old input that was saved or buffered until further processing could be done</param>
        </member>
        <member name="M:Robust.Client.GameObjects.InputSystem.PredictInputCommand(Robust.Shared.Input.IFullInputCmdMessage)">
            <summary>
            Handle a predicted input command.
            </summary>
            <param name="inputCmd">Input command to handle as predicted.</param>
        </member>
        <member name="M:Robust.Client.GameObjects.InputSystem.SetEntityContextActive">
            <summary>
                Sets the active context to the defined context on the attached entity.
            </summary>
        </member>
        <member name="T:Robust.Client.GameObjects.SpriteSystem">
            <summary>
            Updates the layer animation for every visible sprite.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteSystem.SetAutoAnimateSync(Robust.Client.GameObjects.SpriteComponent,System.Double)">
            <summary>
            Resets the sprite's animated layers to align with a given time (in seconds).
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteSystem.SetAutoAnimateSync(Robust.Client.GameObjects.SpriteComponent,Robust.Client.GameObjects.SpriteComponent.Layer,System.Double)">
            <summary>
            Resets the layer's animation to align with a given time (in seconds).
            </summary>
        </member>
        <member name="F:Robust.Client.GameObjects.SpriteSystem._queuedFrameUpdate">
            <summary>
                Entities that require a sprite frame update.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteSystem.FrameUpdate(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteSystem.ForceUpdate(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Force update of the sprite component next frame
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteSystem.GetFrame(Robust.Shared.Utility.SpriteSpecifier,System.TimeSpan,System.Boolean)">
            <summary>
            Gets the specified frame for this sprite at the specified time.
            </summary>
            <param name="loop">Should we clamp on the last frame and not loop</param>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteSystem.GetSpriteWorldPosition(Robust.Shared.GameObjects.Entity{Robust.Client.GameObjects.SpriteComponent,Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Gets an entity's sprite position in world terms.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteSystem.GetSpriteScreenCoordinates(Robust.Shared.GameObjects.Entity{Robust.Client.GameObjects.SpriteComponent,Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Gets an entity's sprite position in screen coordinates.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteSystem.GetPrototypeIcon(System.String)">
            <summary>
                Returns an icon for a given <see cref="T:Robust.Shared.Prototypes.EntityPrototype"/> ID, or a fallback in case of an error.
                This method caches the result based on the prototype identifier.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.SpriteSystem.GetPrototypeIcon(Robust.Shared.Prototypes.EntityPrototype)">
            <summary>
                Returns an icon for a given <see cref="T:Robust.Shared.Prototypes.EntityPrototype"/> ID, or a fallback in case of an error.
                This method does NOT cache the result.
            </summary>
        </member>
        <member name="T:Robust.Client.GameObjects.BeforePostShaderRenderEvent">
            <summary>
                This event gets raised before a sprite gets drawn using it's post-shader.
            </summary>
        </member>
        <member name="T:Robust.Client.GameObjects.TransformSystem">
            <summary>
                Handles interpolation of transform positions.
            </summary>
        </member>
        <member name="T:Robust.Client.GameObjects.VisualizerSystem`1">
            <summary>
                An abstract entity system inheritor for systems that deal with appearance data.
            </summary>
        </member>
        <member name="M:Robust.Client.GameObjects.IClientEntityManager.DispatchReceivedNetworkMsg(Robust.Shared.GameObjects.EntityEventArgs)">
            <summary>
                Raises a networked message as if it had arrived from the sever.
            </summary>
        </member>
        <member name="T:Robust.Client.GameStates.ClientDirtySystem">
            <summary>
            Tracks dirty entities on the client for the purposes of gamestatemanager.
            </summary>
        </member>
        <member name="T:Robust.Client.GameStates.ClientGameStateManager">
            <inheritdoc />
        </member>
        <member name="F:Robust.Client.GameStates.ClientGameStateManager.FullStateTimeout">
            <summary>
            If we are waiting for a full game state from the server, we will automatically re-send full state requests
            if they do not arrive in time. Ideally this should never happen, this here just in case a client gets
            stuck waiting for a full state that the server doesn't know the client even wants.
            </summary>
        </member>
        <member name="P:Robust.Client.GameStates.ClientGameStateManager.MinBufferSize">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.GameStates.ClientGameStateManager.TargetBufferSize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.GetApplicableStateCount">
            <inheritdoc />
        </member>
        <member name="F:Robust.Client.GameStates.ClientGameStateManager._pvsDetachBudget">
            <summary>
                Maximum number of entities that are sent to null-space each tick due to leaving PVS.
            </summary>
        </member>
        <member name="E:Robust.Client.GameStates.ClientGameStateManager.GameStateApplied">
            <inheritdoc />
        </member>
        <member name="F:Robust.Client.GameStates.ClientGameStateManager.DropStates">
            <summary>
            If true, this will cause received game states to be ignored. Used by integration tests.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.Reset">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.ApplyGameState">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.MergeImplicitData(System.Collections.Generic.IEnumerable{Robust.Shared.GameObjects.NetEntity})">
            <summary>
                Infer implicit state data for newly created entities.
            </summary>
            <remarks>
                Whenever a new entity is created, the server doesn't send full state data, given that much of the data
                can simply be obtained from the entity prototype information. This function basically creates a fake
                initial server state for any newly created entity. It does this by simply using the standard <see
                cref="M:Robust.Shared.GameObjects.IEntityManager.GetComponentState(Robust.Shared.GameObjects.IEventBus,Robust.Shared.GameObjects.IComponent,Robust.Shared.Player.ICommonSession,Robust.Shared.Timing.GameTick)"/>.
            </remarks>
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.PartialStateReset(Robust.Shared.GameStates.GameState,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.ResetEntCommand(Robust.Shared.Console.IConsoleShell,System.String,System.String[])">
            <summary>
                Reset an entity to the most recently received server state. This will also reset entities that have been detached to null-space.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.DetachEntCommand(Robust.Shared.Console.IConsoleShell,System.String,System.String[])">
            <summary>
                Detach an entity to null-space, as if it had left PVS range.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.LocalDeleteEntCommand(Robust.Shared.Console.IConsoleShell,System.String,System.String[])">
            <summary>
                Deletes an entity. Unlike the normal delete command, this is CLIENT-SIDE.
            </summary>
            <remarks>
                Unless the entity is a client-side entity, this will likely cause errors.
            </remarks>
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.ResetAllEnts(Robust.Shared.Console.IConsoleShell,System.String,System.String[])">
            <summary>
                Resets all entities to the most recently received server state. This only impacts entities that have not been detached to null-space.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.ClientGameStateManager.ResetEnt(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent,System.Boolean)">
            <summary>
                Reset a given entity to the most recent server state.
            </summary>
        </member>
        <member name="T:Robust.Client.GameStates.GameStateProcessor">
            <inheritdoc />
        </member>
        <member name="F:Robust.Client.GameStates.GameStateProcessor._lastStateFullRep">
            <summary>
            This dictionary stores the full most recently received server state of any entity. This is used whenever predicted entities get reset.
            </summary>
        </member>
        <member name="P:Robust.Client.GameStates.GameStateProcessor.MinBufferSize">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.GameStates.GameStateProcessor.TargetBufferSize">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.GameStates.GameStateProcessor.Interpolation">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.GameStates.GameStateProcessor.BufferSize">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.GameStates.GameStateProcessor.Logging">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameStates.GameStateProcessor.#ctor(Robust.Client.GameStates.IClientGameStateManager,Robust.Client.Timing.IClientGameTiming,Robust.Shared.Log.ISawmill)">
            <summary>
                Constructs a new instance of <see cref="T:Robust.Client.GameStates.GameStateProcessor"/>.
            </summary>
            <param name="timing">Timing information of the current state.</param>
            <param name="clientGameStateManager"></param>
        </member>
        <member name="M:Robust.Client.GameStates.GameStateProcessor.AddNewState(Robust.Shared.GameStates.GameState)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameStates.GameStateProcessor.TryGetServerState(Robust.Shared.GameStates.GameState@,Robust.Shared.GameStates.GameState@)">
            <summary>
                Attempts to get the current and next states to apply.
            </summary>
            <remarks>
                If the processor is not currently waiting for a full state, the states to apply depends on <see
                cref="!:IGameTiming.LastProcessedTick"/>.
            </remarks>
            <returns>Returns true if the states should be applied.</returns>
        </member>
        <member name="M:Robust.Client.GameStates.GameStateProcessor.Reset">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.GameStates.IClientGameStateManager">
            <summary>
                Engine service that provides processing and management of game states.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Robust.Client.GameStates.IClientGameStateManager.MinBufferSize" -->
        <member name="P:Robust.Client.GameStates.IClientGameStateManager.TargetBufferSize">
            <summary>
                The number of states the system is trying to keep in the buffer. This will always
                be greater or equal to <see cref="P:Robust.Client.GameStates.IClientGameStateManager.MinBufferSize"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.GetApplicableStateCount">
            <summary>
                Number of applicable game states currently in the state buffer.
            </summary>
        </member>
        <member name="P:Robust.Client.GameStates.IClientGameStateManager.StateCount">
            <summary>
                Total number of game states currently in the state buffer.
            </summary>
        </member>
        <member name="P:Robust.Client.GameStates.IClientGameStateManager.StateBufferMergeThreshold">
            <summary>
                If the buffer size is this many states larger than the target buffer size,
                apply the overflow of states in a single tick.
            </summary>
        </member>
        <member name="P:Robust.Client.GameStates.IClientGameStateManager.IsPredictionEnabled">
            <summary>
            Whether prediction is currently enabled on the client entirely.
            This is NOT equal to <see cref="P:Robust.Shared.Timing.IGameTiming.InPrediction"/> or <see cref="P:Robust.Shared.Timing.IGameTiming.IsFirstTimePredicted"/>.
            </summary>
            <remarks>This is effectively an alias of <see cref="F:Robust.Shared.CVars.NetPredict"/>.</remarks>
        </member>
        <member name="E:Robust.Client.GameStates.IClientGameStateManager.GameStateApplied">
            <summary>
                This is called after the game state has been applied for the current tick.
            </summary>
        </member>
        <member name="E:Robust.Client.GameStates.IClientGameStateManager.PvsLeave">
            <summary>
                This is invoked whenever a pvs-leave message is received.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.Initialize">
            <summary>
                One time initialization of the service.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.Reset">
            <summary>
                Resets the service back to its initial state.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.ApplyGameState">
            <summary>
                Applies the game state for this tick.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.ApplyGameState(Robust.Shared.GameStates.GameState,Robust.Shared.GameStates.GameState)">
            <summary>
                Applies a given set of game states.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.ResetPredictedEntities">
            <summary>
                Resets any entities that have changed while predicting future ticks.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.InputCommandDispatched(Robust.Shared.Input.ClientFullInputCmdMessage,Robust.Shared.Input.FullInputCmdMessage)">
            <summary>
                An input command has been dispatched.
            </summary>
            <param name="message">Message being dispatched.</param>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.RequestFullState(System.Nullable{Robust.Shared.GameObjects.NetEntity},System.Nullable{Robust.Shared.Timing.GameTick})">
            <summary>
                Requests a full state from the server. This should override even implicit entity data.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.UpdateFullRep(Robust.Shared.GameStates.GameState,System.Boolean)">
            <summary>
                Updates the cached game sates that are used to reset predicted entities.
            </summary>
            <param name="cloneDelta">If true, this will clone old states while applying delta states, rather than
            modifying them directly. Useful if they are still cached elsewhere (e.g., replays).</param>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.GetFullRep">
            <summary>
            Returns the full collection of cached game states that are used to reset predicted entities.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.PartialStateReset(Robust.Shared.GameStates.GameState,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            This will perform some setup in order to reset the game to an earlier state. To fully reset the state
            <see cref="M:Robust.Client.GameStates.IClientGameStateManager.ApplyGameState"/> still needs to be called separately.
            </summary>
            <remarks>
            This function will delete any networked entities that are not present in the given game state. Any child
            entities that are in the state will simply be sent to null-space. This will also reset
            <see cref="P:Robust.Shared.GameObjects.MetaDataComponent.LastStateApplied"/> to zero, so that <see cref="M:Robust.Client.GameStates.IClientGameStateManager.ApplyGameState"/> will
            actually apply the state.
            </remarks>
            <param name="state">
            The state to reset to.
            </param>
            <param name="resetAllEntities">
            Whether or not to reset <see cref="P:Robust.Shared.GameObjects.MetaDataComponent.LastStateApplied"/> for all entities, or only those
            that have been modified some after the states <see cref="F:Robust.Shared.GameStates.GameState.ToSequence"/>. This effectively
            determines whether we should do a full-state reset, or only reset recently modified entities.
            </param>
            <param name="deleteClientEntities">
            Whether to delete all client-side entities (which are never part of the networked game state).
            </param>
            <param name="deleteClientChildren">
            Whether to delete client-side entities that are parented to networked that are about to be deleted during
            the partial reset. E.g., if this is true, then a client-side muzzle flash effect entity that is parented to
            a networked gun entity will get deleted if that gun is about to be deleted. If false, the entity will
            simply be detached to nullspace. This option has no effect if <see cref="!:deleteClientEntities"/> is true.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Client.GameStates.IClientGameStateManager.QueuePvsDetach(System.Collections.Generic.List{Robust.Shared.GameObjects.NetEntity},Robust.Shared.Timing.GameTick)" -->
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.DetachImmediate(System.Collections.Generic.List{Robust.Shared.GameObjects.NetEntity})">
            <summary>
            Immediately detach several entities.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IClientGameStateManager.ClearDetachQueue">
            <summary>
            Clears the PVS detach queue.
            </summary>
        </member>
        <member name="T:Robust.Client.GameStates.IGameStateProcessor">
            <summary>
                Holds a collection of game states and calculates which ones to apply at a given game tick.
                It also stores a copy of all the last entity states from the server,
                allowing the game to be reset to a server-like condition at any point.
            </summary>
        </member>
        <member name="P:Robust.Client.GameStates.IGameStateProcessor.MinBufferSize">
            <summary>
                Minimum number of states needed in the buffer for everything to work.
            </summary>
            <remarks>
                With interpolation enabled minimum is 2 states in buffer for the system to work (cur, next).
                Without interpolation enabled minimum is 2 states in buffer for the system to work (cur).
            </remarks>
        </member>
        <member name="P:Robust.Client.GameStates.IGameStateProcessor.TargetBufferSize">
            <summary>
                The number of states the system is trying to keep in the buffer. This will always
                be greater or equal to <see cref="P:Robust.Client.GameStates.IGameStateProcessor.MinBufferSize"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.GameStates.IGameStateProcessor.Interpolation">
            <summary>
                Is frame interpolation turned on?
            </summary>
        </member>
        <member name="P:Robust.Client.GameStates.IGameStateProcessor.BufferSize">
            <summary>
                The target number of states to keep in the buffer for network smoothing.
            </summary>
            <remarks>
                For Lan, set this to 0. For Excellent net conditions, set this to 1. For normal network conditions,
                set this to 2. For worse conditions, set it higher.
            </remarks>
        </member>
        <member name="P:Robust.Client.GameStates.IGameStateProcessor.Logging">
            <summary>
                Is debug logging enabled? This will dump debug info about every state to the log.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IGameStateProcessor.AddNewState(Robust.Shared.GameStates.GameState)">
            <summary>
                Adds a new state into the processor. These are usually from networking or replays.
            </summary>
            <param name="state">Newly received state.</param>
            <returns>Returns true if the state was accepted and should be acknowledged</returns>
        </member>
        <member name="M:Robust.Client.GameStates.IGameStateProcessor.TryGetServerState(Robust.Shared.GameStates.GameState@,Robust.Shared.GameStates.GameState@)">
            <summary>
                Calculates the current and next state to apply for a given game tick.
            </summary>
            <param name="curTick">Tick to get the states for.</param>
            <param name="curState">Current state for the given tick. This can be null.</param>
            <param name="nextState">Current state for tick + 1. This can be null.</param>
            <returns>Was the function able to correctly calculate the states for the given tick?</returns>
        </member>
        <member name="M:Robust.Client.GameStates.IGameStateProcessor.Reset">
            <summary>
                Resets the processor back to its initial state.
            </summary>
        </member>
        <member name="M:Robust.Client.GameStates.IGameStateProcessor.MergeImplicitData(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.NetEntity,System.Collections.Generic.Dictionary{System.UInt16,Robust.Shared.GameObjects.IComponentState}})">
            <summary>
                Merges entity data into the full copy of the server states.
            </summary>
            <remarks>
                This is necessary because the server does not send data
                that can be inferred from entity creation on new entity states.
                This data thus has to be re-constructed client-side and merged with this method.
            </remarks>
            <param name="data">
                The data to merge.
                It's a dictionary of entity ID -> (component net ID -> ComponentState)
            </param>
        </member>
        <member name="M:Robust.Client.GameStates.IGameStateProcessor.GetLastServerStates(Robust.Shared.GameObjects.NetEntity)">
            <summary>
                Get the last state data from the server for an entity.
            </summary>
            <returns>Dictionary (net ID -> ComponentState)</returns>
        </member>
        <member name="M:Robust.Client.GameStates.IGameStateProcessor.GetApplicableStateCount(System.Nullable{Robust.Shared.Timing.GameTick})">
            <summary>
                Calculate the number of applicable states in the game state buffer from a given tick.
                This includes only applicable states. If there is a gap, future buffers are not included.
            </summary>
            <param name="fromTick">The tick to calculate from.</param>
        </member>
        <member name="T:Robust.Client.GameStates.NetEntityOverlay">
            <summary>
            A network entity report that lists all entities as they are updated through game states.
            https://developer.valvesoftware.com/wiki/Networking_Entities#cl_entityreport
            </summary>
        </member>
        <member name="P:Robust.Client.GameStates.NetEntityOverlay.Space">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.GameStates.NetGraphOverlay">
            <summary>
                Visual debug overlay for the network diagnostic graph.
            </summary>
        </member>
        <member name="P:Robust.Client.GameStates.NetGraphOverlay.Space">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.GameStates.NetGraphOverlay.FrameUpdate(Robust.Shared.Timing.FrameEventArgs)">
            <inheritdoc />
        </member>
        <member name="F:Robust.Client.GameStates.NetInterpOverlay.Delay">
            <summary>
            When an entity stops lerping the overlay will continue to draw a box around the entity for this amount of time.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.AtlasTexture">
            <summary>
                Represents a sub region of another texture.
                This can be a useful optimization in many cases.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.AtlasTexture.SourceTexture">
            <summary>
                The texture this texture is a sub region of.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.AtlasTexture.SubRegion">
            <summary>
                Our sub region within our source, in pixel coordinates.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.EyeManager">
            <inheritdoc />
        </member>
        <member name="F:Robust.Client.Graphics.EyeManager.PixelsPerMeter">
            <summary>
            Default scaling for the projection matrix.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.EyeManager.CurrentEye">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Graphics.EyeManager.CurrentMap">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Graphics.EyeManager.GetWorldViewport">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Graphics.EyeManager.GetWorldViewbounds">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Graphics.EyeManager.WorldToScreen(System.Numerics.Vector2)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Graphics.EyeManager.GetScreenProjectionMatrix(System.Numerics.Matrix3x2@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Graphics.EyeManager.CoordinatesToScreen(Robust.Shared.Map.EntityCoordinates)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Graphics.EyeManager.ScreenToMap(Robust.Shared.Map.ScreenCoordinates)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Graphics.EyeManager.ScreenToMap(System.Numerics.Vector2)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Graphics.EyeManager.PixelToMap(Robust.Shared.Map.ScreenCoordinates)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Graphics.EyeManager.PixelToMap(System.Numerics.Vector2)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.Graphics.FixedEye">
            <summary>
                A fixed eye is an eye which is fixed to one point, its position.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.IEyeManager">
            <summary>
            Keeps a reference to the current eye (camera) that the client is seeing though, and provides
            utility functions for the current eye.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Robust.Client.Graphics.IEyeManager.CurrentEye" -->
        <member name="M:Robust.Client.Graphics.IEyeManager.GetWorldViewport">
            <summary>
            A world-space box that is at LEAST the area covered by the main viewport.
            May be larger due to say rotation.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IEyeManager.GetWorldViewbounds">
            <summary>
            A world-space box of the area visible in the main viewport.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IEyeManager.GetScreenProjectionMatrix(System.Numerics.Matrix3x2@)">
            <summary>
            Calculates the projection matrix to transform a point from camera space
            to UI screen space.
            </summary>
            <param name="projMatrix"></param>
        </member>
        <member name="M:Robust.Client.Graphics.IEyeManager.WorldToScreen(System.Numerics.Vector2)">
            <summary>
            Projects a point from world space to UI screen space using the main viewport.
            </summary>
            <param name="point">Point in world to transform.</param>
            <returns>Corresponding point in UI screen space.</returns>
        </member>
        <member name="M:Robust.Client.Graphics.IEyeManager.CoordinatesToScreen(Robust.Shared.Map.EntityCoordinates)">
            <summary>
            Projects a point from world space to UI screen space using the current camera.
            </summary>
            <param name="point">Point in world to transform.</param>
            <returns>Corresponding point in UI screen space.</returns>
        </member>
        <member name="M:Robust.Client.Graphics.IEyeManager.ScreenToMap(Robust.Shared.Map.ScreenCoordinates)">
            <summary>
            Unprojects a point from UI screen space to world space using the viewport under the screen coordinates.
            </summary>
            <remarks>
            The game exists on the 2D X/Y plane, so this function returns a point o the plane
            instead of a line segment.
            </remarks>
            <param name="point">Point on screen to transform.</param>
            <returns>Corresponding point in the world.</returns>
        </member>
        <member name="M:Robust.Client.Graphics.IEyeManager.ScreenToMap(System.Numerics.Vector2)">
            <summary>
            Unprojects a point from UI screen space to world space using the main viewport.
            </summary>
            <remarks>
            The game exists on the 2D X/Y plane, so this function returns a point o the plane
            instead of a line segment.
            </remarks>
            <param name="point">Point on screen to transform.</param>
            <returns>Corresponding point in the world.</returns>
        </member>
        <member name="M:Robust.Client.Graphics.IEyeManager.PixelToMap(Robust.Shared.Map.ScreenCoordinates)">
            <summary>
            Similar to <see cref="M:Robust.Client.Graphics.IEyeManager.ScreenToMap(Robust.Shared.Map.ScreenCoordinates)"/>, except it should compensate for the effects of shaders on viewports.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IEyeManager.PixelToMap(System.Numerics.Vector2)">
            <summary>
            Similar to <see cref="M:Robust.Client.Graphics.IEyeManager.ScreenToMap(System.Numerics.Vector2)"/>, except it should compensate for the effects of shaders on viewports.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde">
            <summary>
                Responsible for most things rendering on OpenGL mode.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.Clyde.Clyde._erroredGridOverlays">
            <summary>
            To avoid spamming errors we'll just log it once and move on.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.Clyde.Clyde.PostShadeScale">
            <summary>
                Some shaders that enlarge the final sprite, like emission or highlight effects, need to use a slightly larger render target.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.CopyScreenTexture(Robust.Client.Graphics.Clyde.Clyde.RenderTexture)">
            <summary>
               Sends SCREEN_TEXTURE to all overlays in the given OverlaySpace that request it.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.SetupVAOLayout">
            <summary>
                Sets up VAO layout for Vertex2D for base and raw shader types.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Client.Graphics.Clyde.Clyde.DrawOcclusionDepth(System.Numerics.Vector2,System.Int32,System.Single,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Robust.Client.Graphics.Clyde.Clyde.RenderHandle.DrawTextureScreen(Robust.Client.Graphics.Texture,System.Numerics.Vector2,System.Numerics.Vector2,System.Numerics.Vector2,System.Numerics.Vector2,Robust.Shared.Maths.Color@,System.Nullable{Robust.Shared.Maths.UIBox2}@)" -->
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.RenderHandle.DrawTextureWorld(Robust.Client.Graphics.Texture,System.Numerics.Vector2,System.Numerics.Vector2,System.Numerics.Vector2,System.Numerics.Vector2,Robust.Shared.Maths.Color,System.Nullable{Robust.Shared.Maths.UIBox2}@)">
            <summary>
            Draws a sprite to the world. The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.Clyde.Clyde.DrawSetModelTransform(System.Numerics.Matrix3x2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="texture">Texture to draw.</param>
            <param name="bl">Bottom left vertex of the quad in object space.</param>
            <param name="br">Bottom right vertex of the quad in object space.</param>
            <param name="tl">Top left vertex of the quad in object space.</param>
            <param name="tr">Top right vertex of the quad in object space.</param>
            <param name="modulate">A color to multiply the texture by when shading.</param>
            <param name="subRegion">The four corners of the texture sub region in px.</param>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.RenderHandle.ExtractTexture(Robust.Client.Graphics.Texture,System.Nullable{Robust.Shared.Maths.UIBox2}@,Robust.Shared.Maths.UIBox2@)">
            <summary>
            Converts a subRegion (px) into texture coords (0-1) of a given texture (cells of the textureAtlas).
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.RenderHandle.DrawEntity(Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2,System.Numerics.Vector2,System.Nullable{Robust.Shared.Maths.Angle},Robust.Shared.Maths.Angle,System.Nullable{Robust.Shared.Maths.Direction},Robust.Client.GameObjects.SpriteComponent,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.SharedTransformSystem)">
            <summary>
            Draws an entity.
            </summary>
            <param name="entity">The entity to draw</param>
            <param name="position">The local pixel position where the entity should be drawn.</param>
            <param name="scale">Scales the drawn entity</param>
            <param name="worldRot">The world rotation to use when drawing the entity.
            This impacts the sprites RSI direction. Null will retrieve the entity's actual rotation.
            </param>
            <param name="eyeRot">The effective "eye" angle.
            This will cause the entity to be rotated, and may also affect the RSI directions.
            Draws the entity at some given angle.</param>
            <param name="overrideDirection">RSI direction override.</param>
            <param name="sprite">The entity's sprite component</param>
            <param name="xform">The entity's transform component.
            Only required if <see cref="!:overrideDirection"/> is null.</param>
            <param name="xformSystem">The transform system</param>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.RenderHandle.DrawingHandleScreenImpl.DrawEntity(Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2,System.Numerics.Vector2,System.Nullable{Robust.Shared.Maths.Angle},Robust.Shared.Maths.Angle,System.Nullable{Robust.Shared.Maths.Direction},Robust.Client.GameObjects.SpriteComponent,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.SharedTransformSystem)">
            <summary>
            Draws an entity.
            </summary>
            <param name="entity">The entity to draw</param>
            <param name="position">The local pixel position where the entity should be drawn.</param>
            <param name="scale">Scales the drawn entity</param>
            <param name="worldRot">The world rotation to use when drawing the entity.
            This impacts the sprites RSI direction. Null will retrieve the entity's actual rotation.
            </param>
            <param name="eyeRot">The effective "eye" angle.
            This will cause the entity to be rotated, and may also affect the RSI directions.
            Draws the entity at some given angle.</param>
            <param name="overrideDirection">RSI direction override.</param>
            <param name="sprite">The entity's sprite component</param>
            <param name="xform">The entity's transform component.
            Only required if <see cref="!:overrideDirection"/> is null.</param>
            <param name="xformSystem">The transform system</param>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.RenderHandle.DrawingHandleWorldImpl.DrawTextureRectRegion(Robust.Client.Graphics.Texture,Robust.Shared.Maths.Box2,System.Nullable{Robust.Shared.Maths.Color},System.Nullable{Robust.Shared.Maths.UIBox2})">
            <summary>
            Draws a sprite to the world. The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.Clyde.Clyde.DrawSetModelTransform(System.Numerics.Matrix3x2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="texture">Texture to draw.</param>
            <param name="quad">The four vertices of the quad in object space (or world if the transform is identity.).</param>
            <param name="modulate">A color to multiply the texture by when shading.</param>
            <param name="subRegion">The four corners of the texture sub region in px.</param>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.RenderHandle.DrawingHandleWorldImpl.DrawTextureRectRegion(Robust.Client.Graphics.Texture,Robust.Shared.Maths.Box2Rotated@,System.Nullable{Robust.Shared.Maths.Color},System.Nullable{Robust.Shared.Maths.UIBox2})">
            <summary>
            Draws a sprite to the world. The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.Clyde.Clyde.DrawSetModelTransform(System.Numerics.Matrix3x2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="texture">Texture to draw.</param>
            <param name="quad">The four vertices of the quad in object space (or world if the transform is identity.).</param>
            <param name="modulate">A color to multiply the texture by when shading.</param>
            <param name="subRegion">The four corners of the texture sub region in px.</param>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde._updateUniformConstants(Robust.Shared.Maths.Vector2i@)">
            <summary>
                Updates uniform constants shared to all shaders, such as time and pixel size.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.FlushRenderQueue">
            <summary>
                Flushes the render handle, processing and re-pooling all the command lists.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.DrawTexture(Robust.Client.Graphics.ClydeHandle,System.Numerics.Vector2,System.Numerics.Vector2,System.Numerics.Vector2,System.Numerics.Vector2,Robust.Shared.Maths.Color@,Robust.Shared.Maths.Box2@)">
            <summary>
            Draws a texture quad to the screen.
            </summary>
            <param name="texture">Texture to draw.</param>
            <param name="bl">Bottom left vertex of the quad in object space.</param>
            <param name="br">Bottom right vertex of the quad in object space.</param>
            <param name="tl">Top left vertex of the quad in object space.</param>
            <param name="tr">Top right vertex of the quad in object space.</param>
            <param name="modulate">A color to multiply the texture by when shading. Non-linear.</param>
            <param name="texCoords">The four corners of the texture coordinates, matching the four vertices.</param>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.EnsureBatchState(Robust.Client.Graphics.ClydeHandle,System.Boolean,Robust.Client.Graphics.Clyde.Clyde.BatchPrimitiveType,Robust.Client.Graphics.ClydeHandle)">
            <summary>
                Ensures that batching metadata matches the current batch.
                If not, the current batch is finished and a new one is started.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.BreakBatch">
            <summary>
                Renderer state that cannot be changed mid-batch has been modified and a new batch will have to be started.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Client.Graphics.Clyde.Clyde.ProcessSprites(Robust.Shared.Utility.RefList{Robust.Client.Graphics.Clyde.Clyde.SpriteData},System.Int32,System.Int32,Robust.Client.Graphics.Clyde.Clyde.BatchData@)" -->
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.TransformCenteredBox(Robust.Shared.Maths.Box2@,System.Single,System.Numerics.Vector2@,System.Numerics.Vector2@)">
            <summary>
            This is effectively a specialized combination of a <see cref="!:Matrix3.TransformBox(in Box2Rotated)"/> and <see cref="M:Robust.Shared.Maths.Box2Rotated.CalcBoundingBox"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.FlipClone``1(SixLabors.ImageSharp.Image{``0})">
            <summary>
                Makes a clone of the image that is also flipped.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde.GLContextAngle">
            <summary>
                Explicit ANGLE GL context with manual DXGI/D3D device and swap chain management.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde.GLContextBase">
            <summary>
            Manages OpenGL contexts for the windowing system.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde.GLContextEgl">
            <summary>
            Context manager that uses EGL directly so that we get better control over multi-window management.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde.GLContextWindow">
            <summary>
                GL Context(s) provided by the windowing system (GLFW, SDL2...)
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde.GLBuffer">
            <summary>
                Represents an OpenGL buffer object.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.GLBuffer.WriteSubData``1(System.Int32,System.Span{``0})">
            <summary>
                <c>glBufferSubData</c>
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.GLBuffer.WriteSubData``1(System.Span{``0})">
            <summary>
                <c>glBufferSubData</c>
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.GLBuffer.WriteSubData``1(``0@)">
            <summary>
                <c>glBufferSubData</c>
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.GLBuffer.Reallocate``1(System.Span{``0})">
            <summary>
                <c>glBufferData</c>
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.GLBuffer.Reallocate``1(``0@)">
            <summary>
                <c>glBufferData</c>
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.GLBuffer.Reallocate(System.Int32)">
            <summary>
                <c>glBufferData</c>
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde.GLBuffer`1">
            <inheritdoc />
            <summary>
                Subtype of buffers so that we can have a generic constructor.
                Functionally equivalent to <see cref="T:Robust.Client.Graphics.Clyde.Clyde.GLBuffer"/> otherwise.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde.GLHandle">
            <summary>
                Basically just a handle around the integer object handles returned by OpenGL.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde.GLShaderProgram">
            <summary>
                This is an utility class. It does not check whether the OpenGL state machine is set up correctly.
                You've been warned:
                using things like <see cref="M:Robust.Client.Graphics.Clyde.Clyde.GLShaderProgram.SetUniformTexture(System.String,OpenToolkit.Graphics.OpenGL4.TextureUnit)" /> if this buffer isn't bound WILL mess things up!
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde.IAppliableUniformSet">
            <summary>
                Represents some set of uniforms that can be backed by a uniform buffer or by regular uniforms.
                Implies you're using this on a properly setup struct.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.IAppliableUniformSet.Apply(Robust.Client.Graphics.Clyde.Clyde,Robust.Client.Graphics.Clyde.Clyde.GLShaderProgram)">
            <summary>
                Applies the uniform set directly to a program.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Clyde.GLUniformBuffer`1">
            <summary>
                Represents some set of uniforms that can be backed by a uniform buffer or by regular uniforms.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.Clyde.Clyde.GLUniformBuffer`1._implUBO">
            <summary>
                GPU Buffer (only used when uniform buffers are available)
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.Clyde.Clyde.GLUniformBuffer`1._implMirror">
            <summary>
                Mirror (only used when uniform buffers are unavailable)
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.GLUniformBuffer`1.Reallocate(`0@)">
            <summary>
                Updates the buffer contents.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Clyde.Clyde.GLUniformBuffer`1.Apply(Robust.Client.Graphics.Clyde.Clyde.GLShaderProgram)">
            <summary>
                This is important for use on GLES2 - it ensures the uniforms in the specific program are up-to-date.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.ClydeHeadless">
            <summary>
                Hey look, it's Clyde's evil twin brother!
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Clyde.Egl">
            <summary>
                Minimal ANGLE EGL API P/Invokes.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.DrawingHandleBase">
            <summary>
                Used for doing direct drawing without sprite components, existing GUI controls, etc...
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.DrawingHandleBase.Modulate">
            <summary>
                Drawing commands that do NOT receive per-vertex modulation get modulated by this.
                Specifically, *DrawPrimitives w/ DrawVertexUV2DColor IS NOT AFFECTED BY THIS*.
                The only code that should ever be setting this is UserInterfaceManager.
                It's absolutely evil statefulness.
                I understand it's existence and operation.
                I understand that removing it would require rewriting all the UI controls everywhere.
                I still wish it a prolonged death - it's a performance nightmare. - 20kdc
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleBase.DrawPrimitives(Robust.Client.Graphics.DrawPrimitiveTopology,System.Collections.Generic.List{System.Numerics.Vector2},Robust.Shared.Maths.Color)">
            <summary>
                Draws arbitrary geometry primitives with a flat color.
            </summary>
            <param name="primitiveTopology">The topology of the primitives to draw.</param>
            <param name="vertices">The list of vertices to render.</param>
            <param name="color">The color to draw with.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleBase.DrawPrimitives(Robust.Client.Graphics.DrawPrimitiveTopology,System.ReadOnlySpan{System.Numerics.Vector2},Robust.Shared.Maths.Color)">
            <summary>
                Draws arbitrary geometry primitives with a flat color.
            </summary>
            <param name="primitiveTopology">The topology of the primitives to draw.</param>
            <param name="vertices">The set of vertices to render.</param>
            <param name="color">The color to draw with.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleBase.DrawPrimitives(Robust.Client.Graphics.DrawPrimitiveTopology,System.ReadOnlySpan{System.UInt16},System.ReadOnlySpan{System.Numerics.Vector2},Robust.Shared.Maths.Color)">
            <summary>
                Draws arbitrary indexed geometry primitives with a flat color.
            </summary>
            <param name="primitiveTopology">The topology of the primitives to draw.</param>
            <param name="indices">The indices into <paramref name="vertices"/> to render.</param>
            <param name="vertices">The set of vertices to render.</param>
            <param name="color">The color to draw with.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleBase.DrawPrimitives(Robust.Client.Graphics.DrawPrimitiveTopology,Robust.Client.Graphics.Texture,System.ReadOnlySpan{Robust.Client.Graphics.DrawVertexUV2D},System.Nullable{Robust.Shared.Maths.Color})">
            <summary>
                Draws arbitrary geometry primitives with a texture.
            </summary>
            <param name="primitiveTopology">The topology of the primitives to draw.</param>
            <param name="texture">The texture to render with.</param>
            <param name="vertices">The set of vertices to render.</param>
            <param name="color">The color to draw with.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleBase.DrawPrimitives(Robust.Client.Graphics.DrawPrimitiveTopology,Robust.Client.Graphics.Texture,System.ReadOnlySpan{System.UInt16},System.ReadOnlySpan{Robust.Client.Graphics.DrawVertexUV2D},System.Nullable{Robust.Shared.Maths.Color})">
            <summary>
                Draws arbitrary geometry primitives with a texture.
            </summary>
            <param name="primitiveTopology">The topology of the primitives to draw.</param>
            <param name="texture">The texture to render with.</param>
            <param name="vertices">The set of vertices to render.</param>
            <param name="indices">The indices into <paramref name="vertices"/> to render.</param>
            <param name="color">The color to draw with.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleBase.DrawPrimitives(Robust.Client.Graphics.DrawPrimitiveTopology,Robust.Client.Graphics.Texture,System.ReadOnlySpan{Robust.Client.Graphics.DrawVertexUV2DColor})">
            <summary>
                Draws arbitrary geometry primitives with a texture.
                Be aware that this ignores the Modulate property! Apply it yourself if necessary.
            </summary>
            <param name="primitiveTopology">The topology of the primitives to draw.</param>
            <param name="texture">The texture to render with.</param>
            <param name="vertices">The set of vertices to render.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleBase.DrawPrimitives(Robust.Client.Graphics.DrawPrimitiveTopology,Robust.Client.Graphics.Texture,System.ReadOnlySpan{System.UInt16},System.ReadOnlySpan{Robust.Client.Graphics.DrawVertexUV2DColor})">
            <summary>
                Draws arbitrary geometry primitives with a flat color.
                Be aware that this ignores the Modulate property! Apply it yourself if necessary.
            </summary>
            <param name="primitiveTopology">The topology of the primitives to draw.</param>
            <param name="texture">The texture to render with.</param>
            <param name="indices">The indices into <paramref name="vertices"/> to render.</param>
            <param name="vertices">The set of vertices to render.</param>
        </member>
        <member name="T:Robust.Client.Graphics.DrawVertexUV2D">
            <summary>
                2D Vertex that contains both position and UV coordinates.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.DrawVertexUV2DColor">
            <summary>
                2D Vertex that contains position and UV coordinates, and a modulation colour (Linear!!!)
                NOTE: This is directly cast into Clyde Vertex2D!!!!
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.DrawVertexUV2DColor.Color">
            <summary>
                Modulation colour for this vertex.
                Note that this color is in linear space.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.DrawVertexUV2DColor.#ctor(System.Numerics.Vector2,System.Numerics.Vector2,Robust.Shared.Maths.Color)">
            <param name="position">The location.</param>
            <param name="uv">The texture coordinate.</param>
            <param name="col">Modulation colour (In linear space, use Color.FromSrgb if needed)</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawVertexUV2DColor.#ctor(System.Numerics.Vector2,Robust.Shared.Maths.Color)">
            <param name="position">The location.</param>
            <param name="col">Modulation colour (In linear space, use Color.FromSrgb if needed)</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawVertexUV2DColor.#ctor(Robust.Client.Graphics.DrawVertexUV2D,Robust.Shared.Maths.Color)">
            <param name="b">The existing position/UV pair.</param>
            <param name="col">Modulation colour (In linear space, use Color.FromSrgb if needed)</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleScreen.DrawDottedLine(System.Numerics.Vector2,System.Numerics.Vector2,Robust.Shared.Maths.Color,System.Single,System.Single,System.Single)">
            <summary>
            Simialr to DrawLine but has dashes interspersed.
            </summary>
            <param name="offset">Offset from the start of the line.</param>
            <param name="dashSize">How long a dash is.</param>
            <param name="gapSize">How long the gap between dashes is.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleScreen.DrawString(Robust.Client.Graphics.Font,System.Numerics.Vector2,System.String,Robust.Shared.Maths.Color)">
            <summary>
                Draw a simple string to the screen at the specified position.
            </summary>
            <remarks>
                This method is primarily intended for debug purposes and does not handle things like UI scaling.
            </remarks>
            <returns>
                The space taken up (horizontal and vertical) by the text.
            </returns>
            <param name="font">The font to render with.</param>
            <param name="pos">The top-left corner to start drawing text at.</param>
            <param name="str">The text to draw.</param>
            <param name="color">The color of text to draw.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleScreen.DrawString(Robust.Client.Graphics.Font,System.Numerics.Vector2,System.String)">
            <summary>
                Draw a simple string to the screen at the specified position.
            </summary>
            <remarks>
                This method is primarily intended for debug purposes and does not handle things like UI scaling.
            </remarks>
            <returns>
                The space taken up (horizontal and vertical) by the text.
            </returns>
            <param name="font">The font to render with.</param>
            <param name="pos">The top-left corner to start drawing text at.</param>
            <param name="str">The text to draw.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleScreen.DrawEntity(Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2,System.Numerics.Vector2,System.Nullable{Robust.Shared.Maths.Angle},Robust.Shared.Maths.Angle,System.Nullable{Robust.Shared.Maths.Direction},Robust.Client.GameObjects.SpriteComponent,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.SharedTransformSystem)">
            <summary>
            Draws an entity.
            </summary>
            <param name="entity">The entity to draw</param>
            <param name="position">The local pixel position where the entity should be drawn.</param>
            <param name="scale">Scales the drawn entity</param>
            <param name="worldRot">The world rotation to use when drawing the entity.
            This impacts the sprites RSI direction. Null will retrieve the entity's actual rotation.
            </param>
            <param name="eyeRotation">The effective "eye" angle.
            This will cause the entity to be rotated, and may also affect the RSI directions.
            Draws the entity at some given angle.</param>
            <param name="overrideDirection">RSI direction override.</param>
            <param name="sprite">The entity's sprite component</param>
            <param name="xform">The entity's transform component.
            Only required if <see cref="!:overrideDirection"/> is null.</param>
            <param name="xformSystem">The transform system</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleWorld.DrawRect(Robust.Shared.Maths.Box2,Robust.Shared.Maths.Color,System.Boolean)">
            <summary>
            Draws an untextured colored rectangle to the world.The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.DrawingHandleBase.SetTransform(System.Numerics.Vector2@,Robust.Shared.Maths.Angle@,System.Numerics.Vector2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="rect">The four vertices of the quad in object space (or world if the transform is identity.).</param>
            <param name="color">Color of the rectangle.</param>
            <param name="filled">Is it filled with color, or just the border lines?</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleWorld.DrawRect(Robust.Shared.Maths.Box2Rotated@,Robust.Shared.Maths.Color,System.Boolean)">
            <summary>
            Draws an untextured colored rectangle to the world.The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.DrawingHandleBase.SetTransform(System.Numerics.Vector2@,Robust.Shared.Maths.Angle@,System.Numerics.Vector2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="rect">The four vertices of the quad in object space (or world if the transform is identity.).
            The rotation of the rectangle is applied before the transform matrix.</param>
            <param name="color">Color of the rectangle.</param>
            <param name="filled">Is it filled with color, or just the border lines?</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleWorld.DrawTextureRectRegion(Robust.Client.Graphics.Texture,Robust.Shared.Maths.Box2,System.Nullable{Robust.Shared.Maths.Color},System.Nullable{Robust.Shared.Maths.UIBox2})">
            <summary>
            Draws a sprite to the world. The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.DrawingHandleBase.SetTransform(System.Numerics.Vector2@,Robust.Shared.Maths.Angle@,System.Numerics.Vector2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="texture">Texture to draw.</param>
            <param name="quad">The four vertices of the quad in object space (or world if the transform is identity.).</param>
            <param name="modulate">A color to multiply the texture by when shading.</param>
            <param name="subRegion">The four corners of the texture sub region in px.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleWorld.DrawTextureRectRegion(Robust.Client.Graphics.Texture,Robust.Shared.Maths.Box2Rotated@,System.Nullable{Robust.Shared.Maths.Color},System.Nullable{Robust.Shared.Maths.UIBox2})">
            <summary>
            Draws a sprite to the world. The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.DrawingHandleBase.SetTransform(System.Numerics.Vector2@,Robust.Shared.Maths.Angle@,System.Numerics.Vector2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="texture">Texture to draw.</param>
            <param name="quad">The four vertices of the quad in object space (or world if the transform is identity.).
            The rotation of the rectangle is applied before the transform matrix.</param>
            <param name="modulate">A color to multiply the texture by when shading.</param>
            <param name="subRegion">The four corners of the texture sub region in px.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleWorld.DrawTexture(Robust.Client.Graphics.Texture,System.Numerics.Vector2,System.Nullable{Robust.Shared.Maths.Color})">
            <summary>
            Draws a full texture sprite to the world. The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.DrawingHandleBase.SetTransform(System.Numerics.Vector2@,Robust.Shared.Maths.Angle@,System.Numerics.Vector2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="texture">Texture to draw.</param>
            <param name="position">The coordinates of the quad in object space (or world if the transform is identity.).</param>
            <param name="modulate">A color to multiply the texture by when shading.</param>
            <remarks>
            The sprite will have it's local dimensions calculated so that it has <see cref="F:Robust.Client.Graphics.EyeManager.PixelsPerMeter"/> texels per meter in the world.
            </remarks>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleWorld.DrawTexture(Robust.Client.Graphics.Texture,System.Numerics.Vector2,Robust.Shared.Maths.Angle,System.Nullable{Robust.Shared.Maths.Color})">
            <summary>
            Draws a full texture sprite to the world. The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.DrawingHandleBase.SetTransform(System.Numerics.Vector2@,Robust.Shared.Maths.Angle@,System.Numerics.Vector2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="texture">Texture to draw.</param>
            <param name="position">The coordinates of the quad in object space (or world if the transform is identity.).</param>
            <param name="angle">The angle of the quad in object space.</param>
            <param name="modulate">A color to multiply the texture by when shading.</param>
            <remarks>
            The sprite will have it's local dimensions calculated so that it has <see cref="F:Robust.Client.Graphics.EyeManager.PixelsPerMeter"/> texels per meter in the world.
            </remarks>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleWorld.DrawTextureRect(Robust.Client.Graphics.Texture,Robust.Shared.Maths.Box2,System.Nullable{Robust.Shared.Maths.Color})">
            <summary>
            Draws a full texture sprite to the world. The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.DrawingHandleBase.SetTransform(System.Numerics.Vector2@,Robust.Shared.Maths.Angle@,System.Numerics.Vector2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="texture">Texture to draw.</param>
            <param name="quad">The four vertices of the quad in object space (or world if the transform is identity.).</param>
            <param name="modulate">A color to multiply the texture by when shading.</param>
        </member>
        <member name="M:Robust.Client.Graphics.DrawingHandleWorld.DrawTextureRect(Robust.Client.Graphics.Texture,Robust.Shared.Maths.Box2Rotated@,System.Nullable{Robust.Shared.Maths.Color})">
            <summary>
            Draws a full texture sprite to the world. The coordinate system is right handed.
            Make sure to set <see cref="M:Robust.Client.Graphics.DrawingHandleBase.SetTransform(System.Numerics.Vector2@,Robust.Shared.Maths.Angle@,System.Numerics.Vector2@)"/>
            to set the model matrix if needed.
            </summary>
            <param name="texture">Texture to draw.</param>
            <param name="quad">The four vertices of the quad in object space (or world if the transform is identity.).
            The rotation of the rectangle is applied before the transform matrix.</param>
            <param name="modulate">A color to multiply the texture by when shading.</param>
        </member>
        <member name="T:Robust.Client.Graphics.DrawPrimitiveTopology">
            <summary>
                Determines the type of primitives drawn and how they are laid out from vertices.
            </summary>
            <remarks>
                See <see href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#drawing-point-lists">Vulkan's documentation</see> for descriptions of all these modes.
            </remarks>
        </member>
        <member name="T:Robust.Client.Graphics.StyleBox">
            <summary>
                This is for drawing modestly fancy boxes using minimal code.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBox.MinimumSize">
            <summary>
            Minimum size, in virtual pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBox.ContentMarginLeftOverride">
            <summary>
            Left content margin, in virtual pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBox.ContentMarginTopOverride">
            <summary>
            Top content margin, in virtual pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBox.ContentMarginRightOverride">
            <summary>
            Right content margin, in virtual pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBox.ContentMarginBottomOverride">
            <summary>
            Bottom content margin, in virtual pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBox.PaddingLeft">
            <summary>
            Left padding, in virtual pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBox.PaddingBottom">
            <summary>
            Bottom padding, in virtual pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBox.PaddingRight">
            <summary>
            Right padding, in virtual pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBox.PaddingTop">
            <summary>
            Top padding, in virtual pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBox.Padding">
            <summary>
            Padding, in virtual pixels.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.StyleBox.Draw(Robust.Client.Graphics.DrawingHandleScreen,Robust.Shared.Maths.UIBox2,System.Single)">
            <summary>
                Draw this style box to the screen at the specified coordinates. This is using physical pixels, not virtual pixels.
            </summary>
            <param name="handle"></param>
            <param name="box"></param>
        </member>
        <member name="M:Robust.Client.Graphics.StyleBox.GetContentMargin(Robust.Client.Graphics.StyleBox.Margin)">
            <summary>
                Gets the offset from a margin of the box to where content should actually be drawn. This is in virtual pixels.
            </summary>
            <exception cref="T:System.ArgumentException">
                Thrown if <paramref name="margin"/> is a compound is not a single margin flag.
            </exception>
        </member>
        <member name="M:Robust.Client.Graphics.StyleBox.GetPadding(Robust.Client.Graphics.StyleBox.Margin)">
            <summary>
                Gets the padding. This is in virtual pixels.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.StyleBox.GetContentOffset(System.Numerics.Vector2,System.Single)">
            <summary>
                Returns the offsets of the content region of this box when drawn from the given position. Input and
                output positions are in real pixels, though virtual pixels can also be used if the ui scale is set to 1.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.StyleBox.GetContentBox(Robust.Shared.Maths.UIBox2,System.Single)">
            <summary>
                Gets the box considered the "contents" of this style box, when drawn at a specific size. Input and output
                boxes are in virtual pixels, though virtual pixels can also be used if the ui scale is set to 1.
            </summary>
            <exception cref="T:System.ArgumentException">
                <paramref name="baseBox"/> is too small and the resultant box would have negative dimensions.
            </exception>
        </member>
        <member name="M:Robust.Client.Graphics.StyleBox.GetEnvelopBox(System.Numerics.Vector2,System.Numerics.Vector2,System.Single)">
            <summary>
                Gets the draw box, positioned at <paramref name="position"/>,
                that envelops a box with the given dimensions perfectly given this box's content margins.
                Input and output values are in physical pixels,  though virtual pixels can also be used if the ui scale
                is set to 1.
            </summary>
            <remarks>
                It's basically a reverse <see cref="M:Robust.Client.Graphics.StyleBox.GetContentBox(Robust.Shared.Maths.UIBox2,System.Single)"/>.
            </remarks>
            <param name="position">The position at which the new box should be drawn.</param>
            <param name="dimensions">The dimensions of the content box inside this new box.</param>
            <param name="uiScale">Scales the content margin border size</param>
            <returns>
                A box that, when ran through <see cref="M:Robust.Client.Graphics.StyleBox.GetContentBox(Robust.Shared.Maths.UIBox2,System.Single)"/>,
                has a content box of size <paramref name="dimensions"/>
            </returns>
        </member>
        <member name="M:Robust.Client.Graphics.StyleBox.DoDraw(Robust.Client.Graphics.DrawingHandleScreen,Robust.Shared.Maths.UIBox2,System.Single)">
            <summary>
            Draw the style box in the given UI Box.
            </summary>
            <param name="handle"></param>
            <param name="box">The area to draw in, in physical pixels</param>
            <param name="uiScale">The UI scale to use.</param>
        </member>
        <member name="T:Robust.Client.Graphics.StyleBox.Margin">
            <summary>
                Describes margins of a style box.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StyleBox.Margin.Top">
            <summary>
                The top margin.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StyleBox.Margin.Bottom">
            <summary>
                The bottom margin.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StyleBox.Margin.Right">
            <summary>
                The right margin.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StyleBox.Margin.Left">
            <summary>
                The left margin.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StyleBox.Margin.All">
            <summary>
                All margins.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StyleBox.Margin.Vertical">
            <summary>
                The vertical margins.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StyleBox.Margin.Horizontal">
            <summary>
                The horizontal margins.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBoxFlat.BorderThickness">
            <summary>
            Thickness of the border, in virtual pixels.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.StyleBoxTexture">
            <summary>
                Style box based on a 9-patch texture. An image is
                divided into up to nine regions by splitting the
                image along each `PatchMargin.` The corner pieces
                will be drawn once, at their original size, while
                the `Mode` controls the (up to five) central pieces
                which can be either stretched or tiled to fill up
                the space the box is being drawn in.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.StyleBoxTexture.#ctor(Robust.Client.Graphics.StyleBoxTexture)">
            <summary>
                Clones a stylebox so it can be separately modified.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBoxTexture.ExpandMarginLeft">
            <summary>
            Left expansion size, in virtual pixels.
            </summary>
            <remarks>
            This expands the size of the area where the patches get drawn. This will cause the drawn texture to
            extend beyond the box passed to the <see cref="M:Robust.Client.Graphics.StyleBox.Draw(Robust.Client.Graphics.DrawingHandleScreen,Robust.Shared.Maths.UIBox2,System.Single)"/> function. This is not affected by
            <see cref="P:Robust.Client.Graphics.StyleBoxTexture.TextureScale"/>.
            </remarks>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBoxTexture.ExpandMarginTop">
            <summary>
            Top expansion size, in virtual pixels.
            </summary>
            <remarks>
            This expands the size of the area where the patches get drawn. This will cause the drawn texture to
            extend beyond the box passed to the <see cref="M:Robust.Client.Graphics.StyleBox.Draw(Robust.Client.Graphics.DrawingHandleScreen,Robust.Shared.Maths.UIBox2,System.Single)"/> function. This is not affected by
            <see cref="P:Robust.Client.Graphics.StyleBoxTexture.TextureScale"/>.
            </remarks>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBoxTexture.ExpandMarginBottom">
            <summary>
            Bottom expansion size, in virtual pixels.
            </summary>
            <remarks>
            This expands the size of the area where the patches get drawn. This will cause the drawn texture to
            extend beyond the box passed to the <see cref="M:Robust.Client.Graphics.StyleBox.Draw(Robust.Client.Graphics.DrawingHandleScreen,Robust.Shared.Maths.UIBox2,System.Single)"/> function. This is not affected by
            <see cref="P:Robust.Client.Graphics.StyleBoxTexture.TextureScale"/>.
            </remarks>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBoxTexture.ExpandMarginRight">
            <summary>
            Right expansion size, in virtual pixels.
            </summary>
            <remarks>
            This expands the size of the area where the patches get drawn. This will cause the drawn texture to
            extend beyond the box passed to the <see cref="M:Robust.Client.Graphics.StyleBox.Draw(Robust.Client.Graphics.DrawingHandleScreen,Robust.Shared.Maths.UIBox2,System.Single)"/> function. This is not affected by
            <see cref="P:Robust.Client.Graphics.StyleBoxTexture.TextureScale"/>.
            </remarks>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBoxTexture.PatchMarginLeft">
            <summary>
            Distance of the left patch margin from the image. In texture space.
            The size of this patch in virtual pixels can be obtained by scaling this with <see cref="P:Robust.Client.Graphics.StyleBoxTexture.TextureScale"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBoxTexture.PatchMarginRight">
            <summary>
            Distance of the right patch margin from the image. In texture space.
            The size of this patch in virtual pixels can be obtained by scaling this with <see cref="P:Robust.Client.Graphics.StyleBoxTexture.TextureScale"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBoxTexture.PatchMarginTop">
            <summary>
            Distance of the top patch margin from the image. In texture space.
            The size of this patch in virtual pixels can be obtained by scaling this with <see cref="P:Robust.Client.Graphics.StyleBoxTexture.TextureScale"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBoxTexture.PatchMarginBottom">
            <summary>
            Distance of the bottom patch margin from the image. In texture space.
            The size of this patch in virtual pixels can be obtained by scaling this with <see cref="P:Robust.Client.Graphics.StyleBoxTexture.TextureScale"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.StyleBoxTexture.TextureScale">
            <summary>
            Additional scaling to use when drawing the texture.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.StyleBoxTexture.StretchMode">
            <summary>
                Specifies how to stretch the sides and center of the style box.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Font">
            <summary>
                A generic font for rendering of text.
                Does not contain properties such as size. Those are specific to children such as <see cref="T:Robust.Client.Graphics.VectorFont" />
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Font.GetAscent(System.Single)">
            <summary>
                The maximum amount a glyph goes above the baseline, in pixels.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Font.GetHeight(System.Single)">
            <summary>
                The maximum glyph height of a line of text in pixels, not relative to the baseline.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Font.GetDescent(System.Single)">
            <summary>
                The maximum amount a glyph drops below the baseline, in pixels.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Font.GetLineHeight(System.Single)">
            <summary>
                The distance between the baselines of two consecutive lines, in pixels.
                Basically, if you encounter a new line, this is how much you need to move down the cursor.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Font.GetLineSeparation(System.Single)">
            <summary>
                The distance between the edges of two consecutive lines, in pixels.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Font.DrawChar(Robust.Client.Graphics.DrawingHandleScreen,System.Text.Rune,System.Numerics.Vector2,System.Single,Robust.Shared.Maths.Color,System.Boolean)">
            <summary>
                Draw a character at a certain baseline position on screen.
            </summary>
            <param name="handle">The drawing handle to draw to.</param>
            <param name="rune">The Unicode code point to draw.</param>
            <param name="baseline">The baseline from which to draw the character.</param>
            <param name="scale">DPI scale factor to render the font at.</param>
            <param name="color">The color of the character to draw.</param>
            <param name="fallback">If the character is not available, render "�" instead.</param>
            <returns>How much to advance the cursor to draw the next character.</returns>
        </member>
        <member name="M:Robust.Client.Graphics.Font.GetCharMetrics(System.Text.Rune,System.Single,System.Boolean)">
            <summary>
                Gets metrics describing the dimensions and positioning of a single glyph in the font.
            </summary>
            <param name="rune">The unicode codepoint to fetch the glyph metrics for.</param>
            <param name="scale">DPI scale factor to render the font at.</param>
            <param name="fallback">
                If the character is not available, return data for "�" instead.
                This can still fail if the font does not define � itself.
            </param>
            <returns>
                <c>null</c> if this font does not have a glyph for the specified character,
                otherwise the metrics you asked for.
            </returns>
            <seealso cref="M:Robust.Client.Graphics.Font.TryGetCharMetrics(System.Text.Rune,System.Single,Robust.Client.Graphics.CharMetrics@,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Graphics.Font.TryGetCharMetrics(System.Text.Rune,System.Single,Robust.Client.Graphics.CharMetrics@,System.Boolean)">
            <summary>
                Try-pattern version of <see cref="M:Robust.Client.Graphics.Font.GetCharMetrics(System.Text.Rune,System.Single,System.Boolean)"/>.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.VectorFont">
            <summary>
                Font type that renders vector fonts such as OTF and TTF fonts from a <see cref="T:Robust.Client.ResourceManagement.FontResource"/>
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClyde.DefaultWindowScale">
            <summary>
                The default scale ratio for window contents, given to us by the OS.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IClyde.RequestWindowAttention">
            <summary>
                This is the magic method to make the game window ping you in the task bar.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IClyde.CreateBlankTexture``1(Robust.Shared.Maths.Vector2i,System.String,System.Nullable{Robust.Shared.Graphics.TextureLoadParameters}@)">
            <summary>
                Creates a blank texture of the specified parameters.
                This texture can later be modified using <see cref="M:Robust.Client.Graphics.OwnedTexture.SetSubImage``1(Robust.Shared.Maths.Vector2i,SixLabors.ImageSharp.Image{``0},Robust.Shared.Maths.UIBox2i@)"/>
            </summary>
            <param name="size">The size of the new texture, in pixels.</param>
            <param name="name">A name for the texture that can show up in debugging tools like renderdoc.</param>
            <param name="loadParams">
                Load parameters for the texture describing stuff such as sample mode.
            </param>
            <typeparam name="T">
                The type of pixels to "store" in the texture.
                This is the same type you should pass to <see cref="M:Robust.Client.Graphics.OwnedTexture.SetSubImage``1(Robust.Shared.Maths.Vector2i,SixLabors.ImageSharp.Image{``0},Robust.Shared.Maths.UIBox2i@)"/>,
                and also determines how the texture is stored internally.
            </typeparam>
            <returns>
                An owned, mutable texture object.
            </returns>
        </member>
        <member name="M:Robust.Client.Graphics.IClyde.GetStandardCursor(Robust.Client.Graphics.StandardCursorShape)">
            <summary>
                Gets a cursor object representing standard cursors that match the OS styling.
            </summary>
            <remarks>
                Cursor objects returned from this method are cached and you cannot not dispose them.
            </remarks>
        </member>
        <member name="M:Robust.Client.Graphics.IClyde.CreateCursor(SixLabors.ImageSharp.Image{SixLabors.ImageSharp.PixelFormats.Rgba32},Robust.Shared.Maths.Vector2i)">
            <summary>
                Create a custom cursor object from an image.
            </summary>
            <param name="image"></param>
            <param name="hotSpot"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Client.Graphics.IClyde.SetCursor(Robust.Client.Graphics.ICursor)">
            <summary>
                Sets the active cursor for the primary window.
            </summary>
            <param name="cursor">The cursor to set to, or <see langword="null"/> to reset to the default cursor.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the cursor object passed has been disposed.</exception>
        </member>
        <member name="M:Robust.Client.Graphics.IClyde.Screenshot(Robust.Client.Graphics.ScreenshotType,Robust.Client.Graphics.CopyPixelsDelegate{SixLabors.ImageSharp.PixelFormats.Rgb24},System.Nullable{Robust.Shared.Maths.UIBox2i})">
            <summary>
                Make a screenshot of the game, next render frame.
            </summary>
            <param name="type">What kind of screenshot to take</param>
            <param name="callback">The callback to run when the screenshot has been made.</param>
            <param name="subRegion">
                The subregion of the framebuffer to copy.
                If null, the whole framebuffer is copied.
            </param>
            <seealso cref="M:Robust.Client.Graphics.IClyde.ScreenshotAsync(Robust.Client.Graphics.ScreenshotType,System.Nullable{Robust.Shared.Maths.UIBox2i})"/>
            <seealso cref="M:Robust.Client.Graphics.IRenderTarget.CopyPixelsToMemory``1(Robust.Client.Graphics.CopyPixelsDelegate{``0},System.Nullable{Robust.Shared.Maths.UIBox2i})"/>
        </member>
        <member name="M:Robust.Client.Graphics.IClyde.ScreenshotAsync(Robust.Client.Graphics.ScreenshotType,System.Nullable{Robust.Shared.Maths.UIBox2i})">
            <summary>
                Async version of <see cref="M:Robust.Client.Graphics.IClyde.Screenshot(Robust.Client.Graphics.ScreenshotType,Robust.Client.Graphics.CopyPixelsDelegate{SixLabors.ImageSharp.PixelFormats.Rgb24},System.Nullable{Robust.Shared.Maths.UIBox2i})"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IClyde.TextInputSetRect(Robust.Shared.Maths.UIBox2i)">
            <summary>
            Set the active text input area in window pixel coordinates.
            </summary>
            <param name="rect">
            This information is used by the OS to position overlays like IMEs or emoji pickers etc.
            </param>
        </member>
        <member name="M:Robust.Client.Graphics.IClyde.TextInputStart">
            <summary>
            Indicate that the game should start accepting text input on the currently focused window.
            </summary>
            <remarks>
            On some platforms, this will cause an on-screen keyboard to appear.
            The game will also start accepting IME input if configured by the user.
            </remarks>
            <seealso cref="M:Robust.Client.Graphics.IClyde.TextInputStop"/>
        </member>
        <member name="M:Robust.Client.Graphics.IClyde.TextInputStop">
            <summary>
            Stop text input, opposite of <see cref="M:Robust.Client.Graphics.IClyde.TextInputStart"/>.
            </summary>
            <seealso cref="M:Robust.Client.Graphics.IClyde.TextInputStart"/>
        </member>
        <member name="T:Robust.Client.Graphics.IClydeDebugStats">
            <summary>
                Provides frame statistics about rendering.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeDebugStats.LastGLDrawCalls">
            <summary>
                The amount of draw calls sent to OpenGL last frame.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeDebugStats.LastClydeDrawCalls">
            <summary>
                The amount of Clyde draw calls done last frame.
            </summary>
            <remarks>
                This is stuff like <see cref="M:Robust.Client.Graphics.DrawingHandleScreen.DrawTexture(Robust.Client.Graphics.Texture,System.Numerics.Vector2,System.Nullable{Robust.Shared.Maths.Color})"/>.
            </remarks>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeDebugStats.LastBatches">
            <summary>
                The amount of batches made.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeDebugStats.TotalLights">
            <summary>
                The amount of lights that were rendered last frame.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeDebugStats.ShadowLights">
            <summary>
                Number of shadow-casting lights that were rendered last frame.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeDebugStats.Occluders">
            <summary>
                Number of occluders that were rendered last frame.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeDebugStats.Entities">
            <summary>
                Number of entities that were rendered last frame.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IClydeInternal.InstanceShader(Robust.Client.ResourceManagement.ShaderSourceResource,System.Nullable{System.Boolean},System.Nullable{Robust.Client.Graphics.ShaderBlendMode})">
            <summary>
                Creates a new instance of a shader.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeInternal.MouseScreenPosition">
            <summary>
                This is purely a hook for <see cref="T:Robust.Client.Input.IInputManager"/>, use that instead.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IClydeInternal.GetX11WindowId">
            <returns>Null if not running on X11.</returns>
        </member>
        <member name="T:Robust.Client.Graphics.IClydeMonitor">
            <summary>
                Represents a connected monitor on the user's system.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeMonitor.Id">
            <summary>
                This ID is not consistent between startups of the game.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.IClydeViewport">
            <summary>
                A viewport is an API for rendering a section of the game map centered around an eye,
                complete with lighting, FOV and grid rendering.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeViewport.RenderTarget">
            <summary>
                The render target that is rendered to when rendering this viewport.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeViewport.ClearColor">
            <summary>
            Color to clear the render target to before rendering. If null, no clearing will happen.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeViewport.RenderScale">
            <summary>
                This is, effectively, a multiplier to the eye's zoom.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeViewport.AutomaticRender">
            <summary>
                If true, <see cref="M:Robust.Client.Graphics.IClydeViewport.Render"/> will be automatically called at the start of the frame.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IClydeViewport.Render">
            <summary>
                Render the state of the world in this viewport, updating the texture inside the render target.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IClydeViewport.LocalToWorld(System.Numerics.Vector2)">
            <summary>
                Converts a point in the viewport's screen to world coordinates.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IClydeViewport.GetWorldToLocalMatrix">
            <summary>
                Matrix equivalent of <see cref="M:Robust.Client.Graphics.IClydeViewport.LocalToWorld(System.Numerics.Vector2)"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IClydeViewport.WorldToLocal(System.Numerics.Vector2)">
            <summary>
                Converts a point in world-space to the viewport's screen coordinates.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.IClydeViewport.RenderScreenOverlaysBelow(Robust.Client.Graphics.DrawingHandleScreen,Robust.Client.UserInterface.CustomControls.IViewportControl,Robust.Shared.Maths.UIBox2i@)">
            <summary>
                Draw below screen-space overlays for this viewport in UI space.
            </summary>
            <param name="handle">The drawing handle to draw with.</param>
            <param name="control">The control rendering.</param>
            <param name="viewportBounds">
                Absolute screen-space bounds to draw the control at.
                Not relative to the current transform of <see cref="!:handle"/>.
            </param>
        </member>
        <member name="M:Robust.Client.Graphics.IClydeViewport.RenderScreenOverlaysAbove(Robust.Client.Graphics.DrawingHandleScreen,Robust.Client.UserInterface.CustomControls.IViewportControl,Robust.Shared.Maths.UIBox2i@)">
            <summary>
                Draw above screen-space overlays for this viewport in UI space.
            </summary>
            <param name="handle">The drawing handle to draw with.</param>
            <param name="control">The control rendering.</param>
            <param name="viewportBounds">
                Absolute screen-space bounds to draw the control at.
                Not relative to the current transform of <see cref="!:handle"/>.
            </param>
        </member>
        <member name="T:Robust.Client.Graphics.IClydeWindow">
            <summary>
                Represents a single operating system window.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IClydeWindow.DisposeOnClose">
            <summary>
                If set to true, the user closing the window will also <see cref="M:System.IDisposable.Dispose"/> it.
            </summary>
        </member>
        <member name="E:Robust.Client.Graphics.IClydeWindow.RequestClosed">
            <summary>
                Fired when the user tries to close the window. Note that if <see cref="P:Robust.Client.Graphics.IClydeWindow.DisposeOnClose"/> is not true,
                this is merely a request and the user pressing the close button does nothing.
            </summary>
        </member>
        <member name="E:Robust.Client.Graphics.IClydeWindow.Destroyed">
            <summary>
            Raised when the window has been definitively closed.
            This means the window must not be used anymore (it is disposed).
            </summary>
        </member>
        <member name="E:Robust.Client.Graphics.IClydeWindow.Resized">
            <summary>
            Raised when the window has been resized.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.ICursor">
             <summary>
                 Represents a handle to a cursor object.
             </summary>
             <remarks>
                 If disposed while the active cursor, the active cursor will be reset to the default arrow.
            
                 Note that you cannot dispose standard cursors gotten from <see cref="M:Robust.Client.Graphics.IClyde.GetStandardCursor(Robust.Client.Graphics.StandardCursorShape)"/>.
             </remarks>
             <seealso cref="M:Robust.Client.Graphics.IClyde.CreateCursor(SixLabors.ImageSharp.Image{SixLabors.ImageSharp.PixelFormats.Rgba32},Robust.Shared.Maths.Vector2i)"/>
             <seealso cref="M:Robust.Client.Graphics.IClyde.GetStandardCursor(Robust.Client.Graphics.StandardCursorShape)"/>
             <seealso cref="M:Robust.Client.Graphics.IClyde.SetCursor(Robust.Client.Graphics.ICursor)"/>
        </member>
        <member name="T:Robust.Client.Graphics.CharMetrics">
            <summary>
                Metrics for a single glyph in a font.
                Refer to https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.html for more information.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.CharMetrics.BearingX">
            <summary>
                The horizontal distance between the origin and the left of the drawn glyph.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.CharMetrics.BearingY">
            <summary>
                The vertical distance between the origin and the top of the drawn glyph.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.CharMetrics.Advance">
            <summary>
                How much to advance the origin after drawing the glyph.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.CharMetrics.Width">
            <summary>
                The width of the drawn glyph.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.CharMetrics.Height">
            <summary>
                The height of the drawn glyph.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.IRenderHandle">
            <remarks>
                Unstable API. Likely to break hard during renderer rewrite if you rely on it.
            </remarks>
        </member>
        <member name="M:Robust.Client.Graphics.IRenderHandle.DrawEntity(Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2,System.Numerics.Vector2,System.Nullable{Robust.Shared.Maths.Angle},Robust.Shared.Maths.Angle,System.Nullable{Robust.Shared.Maths.Direction},Robust.Client.GameObjects.SpriteComponent,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.SharedTransformSystem)">
            <summary>
            Draws an entity.
            </summary>
            <param name="entity">The entity to draw</param>
            <param name="position">The local pixel position where the entity should be drawn.</param>
            <param name="scale">Scales the drawn entity</param>
            <param name="worldRot">The world rotation to use when drawing the entity.
            This impacts the sprites RSI direction. Null will retrieve the entity's actual rotation.
            </param>
            <param name="eyeRotation">The effective "eye" angle.
            This will cause the entity to be rotated, and may also affect the RSI directions.
            Draws the entity at some given angle.</param>
            <param name="overrideDirection">RSI direction override.</param>
            <param name="sprite">The entity's sprite component</param>
            <param name="xform">The entity's transform component.
            Only required if <see cref="!:overrideDirection"/> is null.</param>
            <param name="xformSystem">The transform system</param>
        </member>
        <member name="T:Robust.Client.Graphics.IRenderTarget">
            <summary>
                Represents something that can be rendered to.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IRenderTarget.Size">
            <summary>
                The size of the render target, in physical pixels.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.IRenderTexture">
            <summary>
                A render target that renders into a texture that can be re-used later.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IRenderTexture.Texture">
            <summary>
                A texture that contains the contents of the render target.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.ILightManager.Enabled">
            <summary>
            Enables/disables the entire light manager.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.ILightManager.DrawShadows">
            <summary>
            Enables/disables shadows, but lights are still functional.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.ILightManager.DrawHardFov">
            <summary>
            Enables/disables hard FOV.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.ILightManager.DrawLighting">
            <summary>
            Enables/disables everything to do with the lighting buffer, without interfering with hard FOV.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.ILightManager.LockConsoleAccess">
            <summary>
            This is useful to prevent players messing with lighting setup when they shouldn't.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.IGridOverlay">
            <summary>
            Marks this overlay as implementing per-grid rendering.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.IGridOverlay.RequiresFlush">
            <summary>
            Should we flush the render or can we keep going.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Overlay">
            <summary>
                An overlay is used for fullscreen drawing in the game. This can range from drawing parallax to a full screen shader.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.Overlay.Space">
            <summary>
                Determines when this overlay is drawn in the rendering queue.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.Overlay.RequestScreenTexture">
            <summary>
                If set to true, <see cref="F:Robust.Client.Graphics.Overlay.ScreenTexture"/> will be set to the current frame (at the moment before the overlay is rendered). This can be costly to performance, but
                some shaders will require it as a passed in uniform to operate.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Robust.Client.Graphics.Overlay.ScreenTexture" -->
        <member name="P:Robust.Client.Graphics.Overlay.ZIndex">
            <summary>
               Overlays on the same OverlaySpace will be drawn from lowest ZIndex to highest ZIndex. As an example, ZIndex -1 will be drawn before ZIndex 2.
               This value is 0 by default. Overlays with same ZIndex will be drawn in an random order.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.Overlay.OverwriteTargetFrameBuffer">
            <summary>
                If this is true, the target framebuffer will be wiped before applying this overlay to it.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Overlay.Draw(Robust.Client.Graphics.OverlayDrawArgs@)">
            <summary>
            Draws this overlay to the current space.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Overlay.BeforeDraw(Robust.Client.Graphics.OverlayDrawArgs@)">
            <summary>
            This function gets called prior to the overlay being drawn. If this function returns false, the overlay will
            not get drawn to this view-port. Useful for avoiding unnecessary screen-texture fetching or frame buffer
            clearing.
            </summary>
            <remarks>
            If you do not use <see cref="P:Robust.Client.Graphics.Overlay.RequestScreenTexture"/> or <see cref="P:Robust.Client.Graphics.Overlay.OverwriteTargetFrameBuffer"/>, you don't
            need to use this and can just perform these checks inside of <see cref="M:Robust.Client.Graphics.Overlay.Draw(Robust.Client.Graphics.OverlayDrawArgs@)"/> instead.
            </remarks>
        </member>
        <member name="T:Robust.Client.Graphics.OverlayDrawArgs">
            <summary>
                Parameters passed to <see cref="M:Robust.Client.Graphics.Overlay.Draw(Robust.Client.Graphics.OverlayDrawArgs@)"/>.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OverlayDrawArgs.Space">
            <summary>
                The overlay space that currently is being rendered for.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OverlayDrawArgs.ViewportControl">
            <summary>
                The viewport control that is rendering this viewport.
                Not always available.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OverlayDrawArgs.Viewport">
            <summary>
                The viewport that is rendering this viewport.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OverlayDrawArgs.DrawingHandle">
            <summary>
                The drawing handle that you can draw with.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OverlayDrawArgs.ViewportBounds">
            <summary>
                The screen-space coordinates available to render within.
                Relevant for screen-space overlay rendering.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OverlayDrawArgs.MapId">
            <summary>
            <see cref="F:Robust.Client.Graphics.OverlayDrawArgs.MapId"/> of the viewport's eye.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OverlayDrawArgs.WorldAABB">
            <summary>
                AABB enclosing the area visible in the viewport.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OverlayDrawArgs.WorldBounds">
            <summary>
                <see cref="T:Robust.Shared.Maths.Box2Rotated"/> of the area visible in the viewport.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.OwnedTexture">
            <summary>
                Represents a mutable texture that can be modified and deleted.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.OwnedTexture.SetSubImage``1(Robust.Shared.Maths.Vector2i,SixLabors.ImageSharp.Image{``0},Robust.Shared.Maths.UIBox2i@)">
            <summary>
                Modifies a sub area of the texture with new data.
            </summary>
            <param name="topLeft">The top left corner of the area to modify.</param>
            <param name="sourceImage">The image from which to copy pixel data.</param>
            <param name="sourceRegion">The rectangle inside <paramref name="sourceImage"/> from which to copy.</param>
            <typeparam name="T">
            The type of pixels being used.
            This must match the type used when creating the texture.
            </typeparam>
        </member>
        <member name="M:Robust.Client.Graphics.OwnedTexture.SetSubImage``1(Robust.Shared.Maths.Vector2i,SixLabors.ImageSharp.Image{``0})">
            <summary>
                Modifies a sub area of the texture with new data.
            </summary>
            <param name="topLeft">The top left corner of the area to modify.</param>
            <param name="sourceImage">The image to paste onto the texture.</param>
            <typeparam name="T">
            The type of pixels being used.
            This must match the type used when creating the texture.
            </typeparam>
        </member>
        <member name="T:Robust.Client.Graphics.RenderTargetColorFormat">
            <summary>
                Formats for the color component of a render target.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.RenderTargetColorFormat.Rgba8">
            <summary>
                8 bits per channel linear RGBA.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.RenderTargetColorFormat.Rgba8Srgb">
            <summary>
                8 bits per channel sRGB with linear alpha channel.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.RenderTargetColorFormat.Rgba16F">
            <summary>
                16 bits per channel floating point linear RGBA.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.RSI">
            <summary>
                Type to handle Robust Station Image (RSI) files.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.RSI.Size">
            <summary>
                The size of this RSI, width x height.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.RSI.Path">
            <summary>
                The original path of this RSI.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.RSI.StateId">
            <summary>
                Represents an ID used to reference states in an RSI.
                Kept around as a simple wrapper around the state Name, to avoid breaking existing code.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.RSI.StateId.Invalid">
            <summary>
                Effectively the "null" of <c>StateId</c>, because you can't have a null for structs.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.RSI.State">
            <summary>
                Represents a single icon state inside an RSI.
            </summary>
            <remarks>
                While the RSI spec allows different animation timing for directions in the same frame,
                RSIs are folded into a single set of animation timings when loaded.
                This is to simplify animation playback code in-engine.
            </remarks>
        </member>
        <member name="P:Robust.Client.Graphics.RSI.State.Size">
            <summary>
                The size of each individual frame in this state.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.RSI.State.RSI">
            <summary>
                The source RSI of this state.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.RSI.State.StateId">
            <summary>
                The identifier for this state inside an RSI.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.RSI.State.RsiDirections">
            <summary>
                How many directions this state has.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.RSI.State.Frame0">
            <summary>
                The first frame of the "south" direction.
            </summary>
            <remarks>
                Always available and better than nothing for previews etc.
            </remarks>
        </member>
        <member name="P:Robust.Client.Graphics.RSI.State.AnimationLength">
            <summary>
                The total play length of this state's animation, in seconds.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.RSI.State.DelayCount">
            <summary>
                The amount of frames in the animation of this state.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.RSI.State.IsAnimated">
            <summary>
                If true, this state has an animation to play.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.RSI.State.GetDelay(System.Int32)">
            <summary>
                Gets the delay between the specified frame and the next frame.
            </summary>
            <param name="frame">The index of the frame.</param>
            <returns>The delay, in seconds.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
                Thrown if the frame index does not exist.
            </exception>
        </member>
        <member name="T:Robust.Client.Graphics.ScreenshotType">
            <summary>
                Types of screenshots to take, at various stages of the render pipeline.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.ScreenshotType.Final">
            <summary>
                Final framebuffer that will be presented to the window.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.ShaderInstance">
             <summary>
                 A shader instance is a wrapper around a shader that can be used for rendering.
                 It can contain extra, mutable parameters depending on the shader backing it.
             </summary>
             <remarks>
                 Shader instances are often shared to reduce bloat.
                 As such, they can be made "immutable" to avoid accidentally modifying
                 the shader instance used by every entity on the station.
            
                 A shader can be made immutable with <see cref="M:Robust.Client.Graphics.ShaderInstance.MakeImmutable" />. This is irreversible.
                 After doing this, operations such as <see cref="M:Robust.Client.Graphics.ShaderInstance.SetParameter(System.String,System.Single)"/> will throw a <see cref="T:System.InvalidOperationException"/>.
            
                 You can "duplicate" a shader instance to make a separate,
                 once again mutable, copy with <see cref="M:Robust.Client.Graphics.ShaderInstance.Duplicate"/>.
             </remarks>
        </member>
        <member name="P:Robust.Client.Graphics.ShaderInstance.Mutable">
            <summary>
                Whether this shader is mutable. An immutable shader can no longer be edited and is ideal for sharing.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.ShaderInstance.MakeImmutable">
            <summary>
                Make this shader permanently immutable.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.ShaderInstance.Duplicate">
            <summary>
                Make an identical copy of this shader, that is treated separately for the parameters assigned to it.
                The copy is also mutable, even if the source is not so.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.StencilParameters.InternalCopy(Robust.Client.Graphics.StencilParameters@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Graphics.StencilParameters.Copy(Robust.Client.Graphics.StencilParameters@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Graphics.StencilParameters.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Graphics.StencilParameters.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Graphics.ShaderPrototype.Instance">
            <summary>
                Retrieves a ready-to-use instance of this shader.
            </summary>
            <remarks>
                This instance is shared. As such, it is immutable.
                Use <see cref="M:Robust.Client.Graphics.ShaderPrototype.InstanceUnique"/> to get a mutable and unique shader instance.
            </remarks>
        </member>
        <member name="T:Robust.Client.Graphics.StandardCursorShape">
            <summary>
                OS-standard cursor shapes.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StandardCursorShape.Arrow">
            <summary>
            The standard arrow shape. Used in almost all situations.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StandardCursorShape.IBeam">
            <summary>
            The I-Beam shape. Used when mousing over a place where text can be entered.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StandardCursorShape.Crosshair">
            <summary>
            The crosshair shape. Used when dragging and dropping.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StandardCursorShape.Hand">
            <summary>
            The hand shape. Used when mousing over something that can be dragged around.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StandardCursorShape.HResize">
            <summary>
            The horizontal resize shape. Used when mousing over something that can be horizontally resized.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StandardCursorShape.VResize">
            <summary>
            The vertical resize shape. Used when mousing over something that can be vertically resized.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.StandardCursorShape.CountCursors">
            <summary>
            Not a real value
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.Texture">
            <summary>
                Contains a texture used for drawing things.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.Texture.Width">
            <summary>
                The width of the texture, in pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.Texture.Height">
            <summary>
                The height of the texture, in pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.Graphics.Texture.Size">
            <summary>
                The size of the texture, in pixels.
            </summary>
        </member>
        <member name="M:Robust.Client.Graphics.Texture.LoadFromImage``1(SixLabors.ImageSharp.Image{``0},System.String,System.Nullable{Robust.Shared.Graphics.TextureLoadParameters})">
            <summary>
                Loads a new texture an existing image.
            </summary>
            <param name="image">The image to load.</param>
            <param name="name">The "name" of this texture. This can be referred to later to aid debugging.</param>
            <param name="loadParameters">
                Parameters that influence the loading of textures.
                Defaults to <see cref="!:Robust.Client.Graphics.TextureLoadParameters.Default"/> if <c>null</c>.
            </param>
            <typeparam name="T">The type of pixels of the image. At the moment, images must be <see cref="T:SixLabors.ImageSharp.PixelFormats.Rgba32"/>.</typeparam>
        </member>
        <member name="M:Robust.Client.Graphics.Texture.LoadFromPNGStream(System.IO.Stream,System.String,System.Nullable{Robust.Shared.Graphics.TextureLoadParameters})">
            <summary>
                Loads an image from a stream containing PNG data.
            </summary>
            <param name="stream">The stream to load the image from.</param>
            <param name="name">The "name" of this texture. This can be referred to later to aid debugging.</param>
            <param name="loadParameters">
                Parameters that influence the loading of textures.
                Defaults to <see cref="!:Robust.Client.Graphics.TextureLoadParameters.Default"/> if <c>null</c>.
            </param>
        </member>
        <member name="F:Robust.Client.Graphics.WindowCreateParameters.Owner">
            <summary>
            The window that will "own" this window.
            Owned windows always appear on top of their owners and have some other misc behavior depending on the OS.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.WindowCreateParameters.StartupLocation">
            <summary>
            Controls where a window is initially placed when created.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.WindowCreateParameters.Styles">
            <summary>
            Specifies window styling options for the created window.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.WindowStartupLocation">
            <summary>
            Controls where a window is initially placed when created.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.WindowStartupLocation.Manual">
            <summary>
            The window position is automatically picked by the windowing system.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.WindowStartupLocation.CenterOwner">
            <summary>
            The window is positioned at the center of the <see cref="F:Robust.Client.Graphics.WindowCreateParameters.Owner"/> window.
            </summary>
        </member>
        <member name="T:Robust.Client.Graphics.OSWindowStyles">
            <summary>
            Specifies window styling options for an OS window.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OSWindowStyles.None">
            <summary>
            No special styles set.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OSWindowStyles.NoTitleOptions">
            <summary>
            Hide title buttons such as close and minimize.
            </summary>
        </member>
        <member name="F:Robust.Client.Graphics.OSWindowStyles.NoTitleBar">
            <summary>
            Completely hide the title bar
            </summary>
        </member>
        <member name="T:Robust.Client.IBaseClient">
            <summary>
                Top level class that controls the game logic of the client.
            </summary>
        </member>
        <member name="P:Robust.Client.IBaseClient.DefaultPort">
            <summary>
                Default port that the client tries to connect to if no other port is specified.
            </summary>
        </member>
        <member name="P:Robust.Client.IBaseClient.RunLevel">
            <summary>
                Current RunLevel that the client is at.
            </summary>
        </member>
        <member name="P:Robust.Client.IBaseClient.GameInfo">
            <summary>
                Various bits of config info received when setting up a session.
            </summary>
        </member>
        <member name="P:Robust.Client.IBaseClient.PlayerNameOverride">
            <summary>
            A player name to use when connecting to the server instead of the one found in the configuration.
            </summary>
        </member>
        <member name="E:Robust.Client.IBaseClient.RunLevelChanged">
            <summary>
                Raised when the client RunLevel is changed.
            </summary>
        </member>
        <member name="E:Robust.Client.IBaseClient.PlayerJoinedServer">
            <summary>
                Raised when the player successfully joins the server.
            </summary>
        </member>
        <member name="E:Robust.Client.IBaseClient.PlayerJoinedGame">
            <summary>
                Raised when the player switches to the game.
            </summary>
        </member>
        <member name="E:Robust.Client.IBaseClient.PlayerLeaveServer">
            <summary>
                Raised right before the player leaves the server.
            </summary>
        </member>
        <member name="M:Robust.Client.IBaseClient.Initialize">
            <summary>
                Call this after BaseClient has been created. This sets up the object to its initial state. Only call this once.
            </summary>
        </member>
        <member name="M:Robust.Client.IBaseClient.ConnectToServer(System.String,System.UInt16)">
            <summary>
                Connects the Initialized BaseClient to a remote server.
            </summary>
        </member>
        <member name="M:Robust.Client.IBaseClient.DisconnectFromServer(System.String)">
            <summary>
                Disconnects the connected BaseClient from a remote server.
            </summary>
        </member>
        <member name="M:Robust.Client.IBaseClient.StartSinglePlayer">
            <summary>
                Starts the single player mode.
            </summary>
        </member>
        <member name="M:Robust.Client.IBaseClient.StopSinglePlayer">
            <summary>
                Stops the single player mode.
            </summary>
        </member>
        <member name="M:Robust.Client.IGameController.Redial(System.String,System.String)">
            <summary>
                Try to cause the launcher to either reconnect to the same server or connect to a new server.
                *The engine will shutdown on success.*
                Will throw an exception if contacting the launcher failed (success indicates it is now the launcher's responsibility).
                To redial the same server, retrieve the server's address from `LaunchState.Ss14Address`.
            </summary>
            <param name="address">The server address, such as "ss14://localhost:1212/".</param>
            <param name="text">Informational text on the cause of the reconnect. Empty or null gives a default reason.</param>
        </member>
        <member name="E:Robust.Client.IGameController.TickUpdateOverride">
            <summary>
                This event gets invoked prior to performing entity tick update logic. If this is null the game
                controller will simply call <see cref="M:Robust.Shared.GameObjects.IEntityManager.TickUpdate(System.Single,System.Boolean,Prometheus.Histogram)"/>.
                This exists to give content module more control over tick updating.
            </summary>
        </member>
        <member name="T:Robust.Client.Input.EngineContexts">
            <summary>
                Contains a helper function for setting up all default engine contexts.
            </summary>
        </member>
        <member name="M:Robust.Client.Input.EngineContexts.SetupContexts(Robust.Shared.Input.IInputContextContainer)">
            <summary>
                Adds the default set of engine contexts to a context container.
            </summary>
            <param name="contexts">Default contexts will be set up inside this container.</param>
        </member>
        <member name="M:Robust.Client.Input.InputEventArgs.Handle">
            <summary>
                Mark this event as handled.
            </summary>
        </member>
        <member name="T:Robust.Client.Input.ModifierInputEventArgs">
            <summary>
                Generic input event that has modifier keys like control.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.ModifierInputEventArgs.Alt">
            <summary>
                Whether the alt key (⌥ Option on MacOS) is held.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.ModifierInputEventArgs.Control">
            <summary>
                Whether the control key is held.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.ModifierInputEventArgs.Shift">
            <summary>
                Whether the shift key is held.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.ModifierInputEventArgs.System">
            <summary>
                Whether the system key (Windows key, ⌘ Command on MacOS) is held.
            </summary>
        </member>
        <member name="T:Robust.Client.Input.TextEnteredEventArgs">
            <summary>
            Information about text that has been typed by the user.
            </summary>
            <param name="Text">The typed text.</param>
        </member>
        <member name="M:Robust.Client.Input.TextEnteredEventArgs.#ctor(System.String)">
            <summary>
            Information about text that has been typed by the user.
            </summary>
            <param name="Text">The typed text.</param>
        </member>
        <member name="P:Robust.Client.Input.TextEnteredEventArgs.Text">
            <summary>The typed text.</summary>
        </member>
        <member name="T:Robust.Client.Input.TextEditingEventArgs">
            <summary>
            Information about an in-progress IME composition.
            </summary>
            <remarks>
            https://wiki.libsdl.org/Tutorials-TextInput
            </remarks>
            <param name="Text"></param>
            <param name="Start">The position in the composition at which the cursor should be placed. This is in runes, not chars.</param>
            <param name="Length">This is in runes, not chars.</param>
        </member>
        <member name="M:Robust.Client.Input.TextEditingEventArgs.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Information about an in-progress IME composition.
            </summary>
            <remarks>
            https://wiki.libsdl.org/Tutorials-TextInput
            </remarks>
            <param name="Text"></param>
            <param name="Start">The position in the composition at which the cursor should be placed. This is in runes, not chars.</param>
            <param name="Length">This is in runes, not chars.</param>
        </member>
        <member name="P:Robust.Client.Input.TextEditingEventArgs.Text">
            <summary></summary>
        </member>
        <member name="P:Robust.Client.Input.TextEditingEventArgs.Start">
            <summary>The position in the composition at which the cursor should be placed. This is in runes, not chars.</summary>
        </member>
        <member name="P:Robust.Client.Input.TextEditingEventArgs.Length">
            <summary>This is in runes, not chars.</summary>
        </member>
        <member name="M:Robust.Client.Input.TextEditingEventArgs.GetStartChars">
            <summary>
            Get <see cref="P:Robust.Client.Input.TextEditingEventArgs.Start"/> but in chars instead of runes.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.KeyEventArgs.Key">
            <summary>
                The key that got pressed or released.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.KeyEventArgs.IsRepeat">
            <summary>
                If true, this key is being held down and another key event is being fired by the OS.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.MouseEventArgs.Position">
            <summary>
                Position of the mouse relative to the screen.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.MouseButtonEventArgs.Button">
            <summary>
                The mouse button that has been pressed or released.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.MouseWheelEventArgs.Delta">
            <summary>
                The direction the mouse wheel was moved in.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.MouseMoveEventArgs.Relative">
            <summary>
                The new position relative to the previous position.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.MouseEnterLeaveEventArgs.Entered">
            <summary>
                True if the mouse ENTERED the window, false if it LEFT the window.
            </summary>
        </member>
        <member name="T:Robust.Client.Input.IInputManager">
            <summary>
                Manages key bindings, input commands and other misc. input systems.
            </summary>
        </member>
        <member name="M:Robust.Client.Input.IInputManager.ViewportKeyEvent(Robust.Client.UserInterface.Control,Robust.Shared.Input.BoundKeyEventArgs)">
            <summary>
                Relay a key event that hit a viewport further down the input stack.
            </summary>
            <remarks>
                This is ONLY intended to be used in key handler from viewport controls.
            </remarks>
            <param name="control">The viewport control that relayed the input.</param>
            <param name="eventArgs">The key event args triggering the input.</param>
        </member>
        <member name="P:Robust.Client.Input.IInputManager.MouseScreenPosition">
            <summary>
                The position and window of the mouse.
            </summary>
        </member>
        <member name="M:Robust.Client.Input.IInputManager.GetKeyBinding(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
                Gets a key binding according to the function it is bound to.
            </summary>
            <remarks>
                Which keybind is returned if there are multiple for a key function is unspecified.
            </remarks>
            <param name="function">The function the key binding is bound to.</param>
            <returns>The key binding.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
                Thrown if no there is no keybind for the specified function.
            </exception>
        </member>
        <member name="M:Robust.Client.Input.IInputManager.TryGetKeyBinding(Robust.Shared.Input.BoundKeyFunction,Robust.Client.Input.IKeyBinding@)">
            <remarks>
                Which keybind is returned if there are multiple for a key function is unspecified.
            </remarks>
        </member>
        <member name="M:Robust.Client.Input.IInputManager.GetInputCommand(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
                Returns the input command bound to a key function.
            </summary>
            <param name="function">The key function to find the bound input command for.</param>
            <returns>An input command, if any. Null if no command is set.</returns>
        </member>
        <member name="E:Robust.Client.Input.IInputManager.UIKeyBindStateChanged">
            <summary>
                UIKeyBindStateChanged is called when a keybind is found.
            </summary>
        </member>
        <member name="E:Robust.Client.Input.IInputManager.KeyBindStateChanged">
            <summary>
                If UIKeyBindStateChanged did not handle the BoundKeyEvent, KeyBindStateChanged is called.
            </summary>
        </member>
        <member name="M:Robust.Client.Input.IInputManager.GetKeyName(Robust.Client.Input.Keyboard.Key)">
            <summary>
                Gets the name of the key on the keyboard, based on the current input method and language.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Client.Input.IInputManager.GetKeyFunctionButtonString(Robust.Shared.Input.BoundKeyFunction)" -->
        <member name="P:Robust.Client.Input.IInputManager.AllBindings">
            <summary>
                Gets all the key bindings currently registered into the manager.
            </summary>
        </member>
        <member name="E:Robust.Client.Input.IInputManager.FirstChanceOnKeyEvent">
            <summary>
                An event that gets fired before everything else when a key event comes in.
                For key down events, the event can be handled to block it.
            </summary>
            <remarks>
                Do not use this for regular input handling.
                This is a low-level API intended solely for stuff like the key rebinding menu.
            </remarks>
        </member>
        <member name="M:Robust.Client.Input.IInputManager.GetKeyBindings(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
                Gets all the keybinds bound to a specific function.
            </summary>
        </member>
        <member name="M:Robust.Client.Input.IInputManager.ResetBindingsFor(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
                Resets the bindings for a specific BoundKeyFunction to the defaults from the resource files.
            </summary>
            <param name="function">The key function to reset the bindings for.</param>
        </member>
        <member name="M:Robust.Client.Input.IInputManager.ResetAllBindings">
            <summary>
                Resets ALL the keybinds to the defaults from the resource files.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Client.Input.IKeyBinding.GetKeyString" -->
        <member name="T:Robust.Client.Input.Mouse.Button">
            <summary>
                Represents one of three mouse buttons.
            </summary>
        </member>
        <member name="T:Robust.Client.Input.Keyboard.Key">
            <summary>
                Represents a key on the keyboard.
            </summary>
        </member>
        <member name="M:Robust.Client.Input.Keyboard.GetSpecialKeyName(Robust.Client.Input.Keyboard.Key,Robust.Shared.Localization.ILocalizationManager)">
            <summary>
                Gets a "nice" version of special unprintable keys such as <see cref="F:Robust.Client.Input.Keyboard.Key.Escape"/>.
            </summary>
            <returns><see langword="null"/> if there is no nice version of this special key.</returns>
        </member>
        <member name="P:Robust.Client.Input.InputManager.NetworkBindMap">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Input.InputManager.Contexts">
            <inheritdoc />
        </member>
        <member name="E:Robust.Client.Input.InputManager.UIKeyBindStateChanged">
            <inheritdoc />
        </member>
        <member name="E:Robust.Client.Input.InputManager.KeyBindStateChanged">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Input.InputManager.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Input.InputManager.KeyDown(Robust.Client.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Input.InputManager.KeyUp(Robust.Client.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Input.InputManager.LoadKeyFile(Robust.Shared.Utility.ResPath,System.Boolean,System.Boolean)">
            <summary>
            Loads a keybind file, configuring keybinds.
            </summary>
            <param name="file">File to load from the content package</param>
            <param name="defaultRegistration">Whether or not this is a "default" keybind set. If it is, then it won't override the current configuration, only the defaults.</param>
            <param name="userData">Whether or not to load from the user data directory instead of the content package.</param>
        </member>
        <member name="M:Robust.Client.Input.InputManager.RegisterBinding(Robust.Shared.Input.BoundKeyFunction,Robust.Client.Input.KeyBindingType,Robust.Client.Input.Keyboard.Key,System.Nullable{Robust.Client.Input.Keyboard.Key},System.Nullable{Robust.Client.Input.Keyboard.Key},System.Nullable{Robust.Client.Input.Keyboard.Key})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Input.InputManager.GetKeyBinding(Robust.Shared.Input.BoundKeyFunction)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Input.InputManager.TryGetKeyBinding(Robust.Shared.Input.BoundKeyFunction,Robust.Client.Input.IKeyBinding@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Input.InputManager.GetInputCommand(Robust.Shared.Input.BoundKeyFunction)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Input.InputManager.SetInputCommand(Robust.Shared.Input.BoundKeyFunction,Robust.Shared.Input.Binding.InputCmdHandler)">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Input.InputManager.KeyBinding.CanFocus">
            <summary>
                Whether the BoundKey can change the focused control.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.InputManager.KeyBinding.CanRepeat">
            <summary>
                Whether the BoundKey still triggers while held down.
            </summary>
        </member>
        <member name="P:Robust.Client.Input.InputManager.KeyBinding.AllowSubCombs">
            <summary>
                Whether the Bound Key Combination allows Sub Combinations of it to trigger.
            </summary>
        </member>
        <member name="F:Robust.Client.Input.KeyBindingType.Command">
            <summary>
            This keybind does not execute a real key function but instead causes a console command to be executed.
            </summary>
        </member>
        <member name="M:Robust.Client.Input.KeyBindingRegistration.InternalCopy(Robust.Client.Input.KeyBindingRegistration@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Input.KeyBindingRegistration.Copy(Robust.Client.Input.KeyBindingRegistration@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Input.KeyBindingRegistration.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Input.KeyBindingRegistration.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Client.Input.KeyEventType.Down">
            <summary>
                This key is pressed down.
            </summary>
        </member>
        <member name="F:Robust.Client.Input.KeyEventType.Repeat">
            <summary>
                This key was repeated by the operating system while already being pressed down.
            </summary>
        </member>
        <member name="F:Robust.Client.Input.KeyEventType.Up">
            <summary>
                This key has been released.
            </summary>
        </member>
        <member name="T:Robust.Client.Log.DebugConsoleLogHandler">
            <summary>
                Writes logs to the in-game debug console.
            </summary>
        </member>
        <member name="M:Robust.Client.Map.ClydeTileDefinitionManager.TileAtlasRegion(Robust.Shared.Map.Tile)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Map.ClydeTileDefinitionManager.TileAtlasRegion(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.Map.IClydeTileDefinitionManager">
            <summary>
                Stores a texture atlas of all the tile definitions for efficient rendering.
            </summary>
        </member>
        <member name="P:Robust.Client.Map.IClydeTileDefinitionManager.TileTextureAtlas">
            <summary>
                The texture atlas containing all the tiles.
            </summary>
        </member>
        <member name="M:Robust.Client.Map.IClydeTileDefinitionManager.TileAtlasRegion(Robust.Shared.Map.Tile)">
            <summary>
                Gets the region inside the texture atlas to use to draw a tile.
            </summary>
            <returns>If null, do not draw the tile at all.</returns>
        </member>
        <member name="M:Robust.Client.Map.IClydeTileDefinitionManager.TileAtlasRegion(System.Int32)">
            <summary>
                Gets the region inside the texture atlas to use to draw a tile type.
            </summary>
            <returns>If null, do not draw the tile at all.</returns>
        </member>
        <member name="T:Robust.Client.Map.TileEdgeOverlay">
            <summary>
            Draws border sprites for tiles that support them.
            </summary>
        </member>
        <member name="M:Robust.Client.Physics.PhysicsSystem.FinalStep(Robust.Shared.Physics.Dynamics.PhysicsMapComponent)">
            <summary>
            Flush all of our lerping data.
            </summary>
        </member>
        <member name="M:Robust.Client.Physics.PhysicsSystem.UpdateIsTouching(System.Collections.Generic.List{Robust.Shared.Physics.Dynamics.Contacts.Contact})">
            <summary>
            This is a stripped down version of <see cref="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.CollideContacts"/> that exists only to update
            <see cref="P:Robust.Shared.Physics.Dynamics.Contacts.Contact.IsTouching"/> for client-side prediction.
            </summary>
        </member>
        <member name="T:Robust.Client.Physics.UpdateIsPredictedEvent">
            <summary>
            Event raised to check whether physics prediction should be enabled.
            </summary>
        </member>
        <member name="F:Robust.Client.Physics.UpdateIsPredictedEvent.BlockPrediction">
            <summary>
            Can be used to block prediction of entities that would otherwise be predicted.
            E.g., if a player is being pulled by a non-predicted entity.
            </summary>
        </member>
        <member name="T:Robust.Client.Physics.PredictedPhysicsComponent">
            <summary>
                Simple component used to tag entities that have physics prediction enabled.
            </summary>
        </member>
        <member name="M:Robust.Client.Physics.PredictedPhysicsComponent.InternalCopy(Robust.Client.Physics.PredictedPhysicsComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Physics.PredictedPhysicsComponent.Copy(Robust.Client.Physics.PredictedPhysicsComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Physics.PredictedPhysicsComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Physics.PredictedPhysicsComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Physics.PredictedPhysicsComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Physics.PredictedPhysicsComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Client.Physics.PredictedPhysicsComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Robust.Client.Placement.IPlacementManager.Replacement">
            <summary>
            Do we replace any existing entities with matching keys.
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.IPlacementManager.Direction">
            <summary>
            The direction to spawn the entity in (presently exposed for EntitySpawnWindow UI)
            </summary>
        </member>
        <member name="E:Robust.Client.Placement.IPlacementManager.DirectionChanged">
            <summary>
            Gets called when Direction changed (presently for EntitySpawnWindow UI)
            </summary>
        </member>
        <member name="E:Robust.Client.Placement.IPlacementManager.PlacementChanged">
            <summary>
            Gets called when the PlacementManager changed its build/erase mode or when the hijacks changed
            </summary>
        </member>
        <member name="T:Robust.Client.Placement.Modes.AlignWallProper">
            <summary>
                Snaps in edge on one axis, center in the other.
            </summary>
        </member>
        <member name="F:Robust.Client.Placement.PlacementManager.PendingTileTimeout">
            <summary>
                How long before a pending tile change is dropped.
            </summary>
        </member>
        <member name="F:Robust.Client.Placement.PlacementManager._modeDictionary">
            <summary>
            Dictionary of all placement mode types
            </summary>
        </member>
        <member name="F:Robust.Client.Placement.PlacementManager._placenextframe">
            <summary>
            Tells this system to try to handle placement of an entity during the next frame
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.PlacementType">
            <summary>
            Allows various types of placement as singular, line, or grid placement where placement mode allows this type of placement
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.StartPoint">
            <summary>
            Holds the anchor that we can try to spawn in a line or a grid from
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.IsActive">
            <summary>
            Whether the placement manager is currently in a mode where it accepts actions
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.Eraser">
            <summary>
            Determines whether we are using the mode to delete an entity on click
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.EraserRect">
            <summary>
            Holds the selection rectangle for the eraser
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager._drawingShader">
            <summary>
            Drawing shader for drawing without being affected by lighting
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.CurrentPlacementOverlayEntity">
            <summary>
            The entity for placement overlay.
            Colour of this gets swapped around in PlacementMode.
            This entity needs to stay in nullspace.
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.CurrentTextures">
            <summary>
            A BAD way to explicitly control the icons used!!!
            Need to fix Content for this
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.CurrentMode">
            <summary>
            Which of the placement orientations we are trying to place with
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.CurrentPrototype">
            <summary>
            The prototype of the entity we are going to spawn on click
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.ColliderAABB">
            <summary>
            The box which certain placement modes collision checks will be done against
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementManager.Direction">
            <inheritdoc />
        </member>
        <member name="E:Robust.Client.Placement.PlacementManager.DirectionChanged">
            <inheritdoc />
        </member>
        <member name="E:Robust.Client.Placement.PlacementManager.PlacementChanged">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Placement.PlacementManager.FrameUpdate(Robust.Shared.Timing.FrameEventArgs)">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Placement.PlacementMode.CurrentTile">
            <summary>
            Holds the current tile we are hovering our mouse over
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementMode.MouseCoords">
            <summary>
            Local coordinates of our cursor on the map
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementMode.TexturesToDraw">
            <summary>
            Texture resources to draw to represent the entity we are trying to spawn
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementMode.ValidPlaceColor">
            <summary>
            Color set to the ghost entity when it has a valid spawn position
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementMode.InvalidPlaceColor">
            <summary>
            Color set to the ghost entity when it has an invalid spawn position
            </summary>
        </member>
        <member name="F:Robust.Client.Placement.PlacementMode.GridDistancing">
            <summary>
            Used for line and grid placement to determine how spaced apart the entities should be
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementMode.RangeRequired">
            <summary>
            Whether this mode requires us to verify the player is spawning within a certain range of themselves
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementMode.HasLineMode">
            <summary>
            Whether this mode can use the line placement mode
            </summary>
        </member>
        <member name="P:Robust.Client.Placement.PlacementMode.HasGridMode">
            <summary>
            Whether this mode can use the grid placement mode
            </summary>
        </member>
        <member name="M:Robust.Client.Placement.PlacementMode.AlignPlacementMode(Robust.Shared.Map.ScreenCoordinates)">
            <summary>
            Aligns the location of placement based on cursor location
            </summary>
            <param name="mouseScreen"></param>
            <returns>Returns whether the current position is a valid placement position</returns>
        </member>
        <member name="M:Robust.Client.Placement.PlacementMode.IsValidPosition(Robust.Shared.Map.EntityCoordinates)">
            <summary>
            Verifies the location of placement is a valid position to place at
            </summary>
            <param name="mouseScreen"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Client.Placement.PlacementMode.GetTileRef(Robust.Shared.Map.EntityCoordinates)">
            <summary>
                Returns the tile ref for a grid, or a map.
            </summary>
        </member>
        <member name="M:Robust.Client.Placement.PlacementMode.RangeCheck(Robust.Shared.Map.EntityCoordinates)">
            <summary>
            Checks if the player is spawning within a certain range of his character if range is required on this mode
            </summary>
            <returns></returns>
        </member>
        <member name="E:Robust.Client.Player.IPlayerManager.PlayerListUpdated">
            <summary>
            Invoked when the list of sessions/players gets updated.
            </summary>
        </member>
        <member name="E:Robust.Client.Player.IPlayerManager.LocalPlayerAttached">
            <summary>
            Invoked when <see cref="P:Robust.Shared.Player.ISharedPlayerManager.LocalSession"/> gets attached to a new entity, or when the local
            session gets updated. See also <see cref="T:Robust.Shared.Player.LocalPlayerAttachedEvent"/>
            </summary>
        </member>
        <member name="E:Robust.Client.Player.IPlayerManager.LocalPlayerDetached">
            <summary>
            Invoked when <see cref="P:Robust.Shared.Player.ISharedPlayerManager.LocalSession"/> gets detached from an entity, or when the local
            session gets updated. See also <see cref="T:Robust.Shared.Player.LocalPlayerDetachedEvent"/>
            </summary>
        </member>
        <member name="E:Robust.Client.Player.IPlayerManager.LocalSessionChanged">
            <summary>
            Invoked whenever <see cref="P:Robust.Shared.Player.ISharedPlayerManager.LocalSession"/> changes.
            </summary>
        </member>
        <member name="M:Robust.Client.Player.IPlayerManager.SetupSinglePlayer(System.String)">
            <summary>
            Sets up a single player game. This creates a dummy <see cref="P:Robust.Shared.Player.ISharedPlayerManager.LocalSession"/>  without an
            <see cref="T:Robust.Shared.Network.INetChannel"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.Player.IPlayerManager.SetupMultiplayer(Robust.Shared.Network.INetChannel)">
            <summary>
            Sets up the manager for a multiplayer game. This creates a <see cref="P:Robust.Shared.Player.ISharedPlayerManager.LocalSession"/>
            using the given <see cref="T:Robust.Shared.Network.INetChannel"/>.
            </summary>
        </member>
        <member name="T:Robust.Client.Player.LocalPlayer">
            <summary>
                Variables and functions that deal with the local client's session.
            </summary>
        </member>
        <member name="P:Robust.Client.Player.LocalPlayer.ControlledEntity">
            <summary>
                Game entity that the local player is controlling. If this is default, the player is not attached to any
                entity at all.
            </summary>
        </member>
        <member name="P:Robust.Client.Player.LocalPlayer.Name">
            <summary>
                OOC name of the local player.
            </summary>
        </member>
        <member name="F:Robust.Client.Player.LocalPlayer.Session">
            <summary>
                Session of the local client.
            </summary>
        </member>
        <member name="T:Robust.Client.Player.PlayerManager">
            <summary>
                Here's the player controller. This will handle attaching GUIs and input to controllable things.
                Why not just attach the inputs directly? It's messy! This makes the whole thing nicely encapsulated.
                This class also communicates with the server to let the server control what entity it is attached to.
            </summary>
        </member>
        <member name="F:Robust.Client.Player.PlayerManager._pendingStates">
            <summary>
            Received player states that had an unknown <see cref="T:Robust.Shared.GameObjects.NetEntity"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.Player.PlayerManager.NetworkedSessions">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Player.PlayerManager.MaxPlayers">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Player.PlayerManager.Initialize(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Player.PlayerManager.Shutdown">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.Player.PlayerManager.HandlePlayerList(Robust.Shared.Network.Messages.MsgPlayerList)">
            <summary>
                Handles the incoming PlayerList message from the server.
            </summary>
        </member>
        <member name="M:Robust.Client.Player.PlayerManager.UpdatePlayerList(System.Collections.Generic.IEnumerable{Robust.Shared.GameStates.SessionState},System.Boolean)">
            <summary>
                Compares the server player list to the client one, and updates if needed.
            </summary>
        </member>
        <member name="T:Robust.Client.Profiling.ProfViewManager">
            <summary>
            Manager for managing recording and snapshots of profiles, consuming shared <see cref="T:Robust.Shared.Profiling.ProfManager"/>
            </summary>
        </member>
        <member name="T:Robust.Client.Reflection.ClientReflectionManager">
            <summary>
                Implementation of <see cref="T:Robust.Shared.Reflection.ReflectionManager"/>
                that defines <c>Robust.Client.</c> and <c>Robust.Shared.</c>
                as valid prefixes for <see cref="M:Robust.Shared.Reflection.ReflectionManager.GetType(System.String)"/>
            </summary>
        </member>
        <member name="T:Robust.Client.Replays.Loading.IReplayFileReader">
            <summary>
            Simple interface that the replay system loads files from.
            </summary>
        </member>
        <member name="M:Robust.Client.Replays.Loading.IReplayFileReader.Exists(Robust.Shared.Utility.ResPath)">
            <summary>
            Check whether a file exists in the replay data.
            </summary>
            <param name="path">The path to check. Doesn't need to be rooted.</param>
            <returns>True if the file exists.</returns>
        </member>
        <member name="M:Robust.Client.Replays.Loading.IReplayFileReader.Open(Robust.Shared.Utility.ResPath)">
            <summary>
            Open a file in the replay data.
            </summary>
            <param name="path">The path to the file. Doesn't need to be rooted.</param>
            <returns>A stream containing the file contents.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the file does not exist.</exception>
        </member>
        <member name="P:Robust.Client.Replays.Loading.IReplayFileReader.AllFiles">
            <summary>
            Returns all files in the replay data.
            </summary>
            <remarks>
            File paths are rooted.
            </remarks>
        </member>
        <member name="T:Robust.Client.Replays.Loading.ReplayFileReaderResources">
            <summary>
            Replay file reader that loads files from the VFS (<see cref="T:Robust.Shared.ContentPack.IResourceManager"/>).
            </summary>
        </member>
        <member name="M:Robust.Client.Replays.Loading.ReplayFileReaderResources.#ctor(Robust.Shared.ContentPack.IResourceManager,Robust.Shared.Utility.ResPath)">
            <param name="resourceManager">The resource manager.</param>
            <param name="prefix">The directory in the VFS that contains the replay files. Must be rooted.</param>
        </member>
        <member name="T:Robust.Client.Replays.Loading.ReplayFileReaderZip">
            <summary>
            Replay file reader that loads files from a zip file.
            </summary>
            <remarks>
            The zip archive is disposed when this instance is disposed.
            </remarks>
        </member>
        <member name="M:Robust.Client.Replays.Loading.ReplayFileReaderZip.#ctor(System.IO.Compression.ZipArchive,Robust.Shared.Utility.ResPath)">
            <param name="archive">The archive to read files from.</param>
            <param name="prefix">The directory in the zip that contains the replay files. Must NOT be rooted.</param>
        </member>
        <member name="M:Robust.Client.Replays.Loading.IReplayLoadManager.LoadYamlMetadata(Robust.Client.Replays.Loading.IReplayFileReader)">
            <summary>
            Load metadata information from a replay's yaml file.
            </summary>
            <param name="fileReader">A reader containing the replay files. Disposed when loading is done.</param>
        </member>
        <member name="M:Robust.Client.Replays.Loading.IReplayLoadManager.LoadReplayAsync(Robust.Client.Replays.Loading.IReplayFileReader,Robust.Client.Replays.Loading.LoadReplayCallback)">
            <summary>
            Async task that loads up a replay for playback. Note that this will have some side effects, such as loading
            networked resources and prototypes. These resources are not tracked or automatically unloaded.
            </summary>
            <remarks>
            This task is intended to be used with a <see cref="T:Robust.Shared.CPUJob.JobQueues.Job`1"/> so that the loading can happen over several frame
            updates.
            </remarks>
            <param name="fileReader">A reader containing the replay files. Disposed when loading is done.</param>
            <param name="callback">A callback delegate that invoked to provide information about the current loading
            progress. This callback can be used to invoke <see cref="M:Robust.Shared.CPUJob.JobQueues.Job`1.SuspendIfOutOfTime"/>. </param>
        </member>
        <member name="M:Robust.Client.Replays.Loading.IReplayLoadManager.StartReplayAsync(Robust.Shared.Replays.ReplayData,Robust.Client.Replays.Loading.LoadReplayCallback)">
            <summary>
            Async task that loads the initial state of a replay, including spawning and initializing all entities. Note that
            this will have some side effects, such as loading networked resources and prototypes. These resources are not
            tracked or automatically unloaded.
            </summary>
            <remarks>
            This task is intended to be used with a <see cref="T:Robust.Shared.CPUJob.JobQueues.Job`1"/> so that the loading can happen over several frame
            updates, otherwise, you could simply start a replay via <see cref="M:Robust.Client.Replays.Playback.IReplayPlaybackManager.StartReplay(Robust.Shared.Replays.ReplayData)"/>..
            </remarks>
            <param name="callback">A callback delegate that invoked to provide information about the current loading
            progress. This callback can be used to invoke <see cref="M:Robust.Shared.CPUJob.JobQueues.Job`1.SuspendIfOutOfTime"/>. </param>
        </member>
        <member name="M:Robust.Client.Replays.Loading.IReplayLoadManager.LoadAndStartReplayAsync(Robust.Client.Replays.Loading.IReplayFileReader,Robust.Client.Replays.Loading.LoadReplayCallback)">
            <summary>
            Convenience function that combines <see cref="M:Robust.Client.Replays.Loading.IReplayLoadManager.LoadReplayAsync(Robust.Client.Replays.Loading.IReplayFileReader,Robust.Client.Replays.Loading.LoadReplayCallback)"/> and <see cref="M:Robust.Client.Replays.Loading.IReplayLoadManager.StartReplayAsync(Robust.Shared.Replays.ReplayData,Robust.Client.Replays.Loading.LoadReplayCallback)"/>.
            </summary>
            <remarks>
            This task is intended to be used with a <see cref="T:Robust.Shared.CPUJob.JobQueues.Job`1"/> so that the loading can happen over several frame
            updates.
            </remarks>
            <param name="fileReader">A reader containing the replay files. Disposed when loading is done.</param>
            <param name="callback">A callback delegate that invoked to provide information about the current loading
            progress. This callback can be used to invoke <see cref="M:Robust.Shared.CPUJob.JobQueues.Job`1.SuspendIfOutOfTime"/>. </param>
        </member>
        <member name="M:Robust.Client.Replays.Loading.IReplayLoadManager.LoadAndStartReplay(Robust.Client.Replays.Loading.IReplayFileReader)">
            <summary>
            This is a variant of <see cref="M:Robust.Client.Replays.Loading.IReplayLoadManager.LoadAndStartReplayAsync(Robust.Client.Replays.Loading.IReplayFileReader,Robust.Client.Replays.Loading.LoadReplayCallback)"/> that will first invoke <see cref="E:Robust.Client.Replays.Loading.IReplayLoadManager.LoadOverride"/>
            before defaulting to simply simply running <see cref="M:Robust.Client.Replays.Loading.IReplayLoadManager.LoadAndStartReplayAsync(Robust.Client.Replays.Loading.IReplayFileReader,Robust.Client.Replays.Loading.LoadReplayCallback)"/> synchronously.
            </summary>
        </member>
        <member name="E:Robust.Client.Replays.Loading.IReplayLoadManager.LoadOverride">
            <summary>
            Event that can be used to override the default replay loading behaviour.
            </summary>
            <remarks>
            E.g., this could be used to make the <see cref="T:Robust.Client.Replays.Commands.ReplayLoadCommand"/> switch to some loading screen with an async
            load job, rather than just hanging the client.
            </remarks>
        </member>
        <member name="T:Robust.Client.Replays.Loading.LoadingState">
            <summary>
            Enum used to indicate loading progress.
            </summary>
        </member>
        <member name="T:Robust.Client.Replays.Loading.LoadReplayJob">
            <summary>
            Simple job for loading some replay file. Note that tick updates need to be blocked
            (<see cref="E:Robust.Client.IGameController.TickUpdateOverride"/>) in order to avoid unexpected errors.
            </summary>
        </member>
        <member name="F:Robust.Client.Replays.Loading.ReplayLoadManager._implicitData">
            <summary>
                Cached implicit entity states.
            </summary>
        </member>
        <member name="M:Robust.Client.Replays.Playback.IReplayPlaybackManager.StartReplay(Robust.Shared.Replays.ReplayData)">
            <summary>
            Starts playing a replay.
            </summary>
            <param name="replay"></param>
        </member>
        <member name="M:Robust.Client.Replays.Playback.IReplayPlaybackManager.StopReplay">
            <summary>
            Stops replaying a playback, unloads resources, and flushes all entities.
            </summary>
        </member>
        <member name="P:Robust.Client.Replays.Playback.IReplayPlaybackManager.Replay">
            <summary>
            The replay that us currently being played back.
            </summary>
        </member>
        <member name="P:Robust.Client.Replays.Playback.IReplayPlaybackManager.Playing">
            <summary>
            True if the replay is actively replaying ticks. False if the replay is currently paused.
            </summary>
        </member>
        <member name="P:Robust.Client.Replays.Playback.IReplayPlaybackManager.ScrubbingTarget">
            <summary>
            This integer can be used by UI controls to scrub to some specific replay index.
            </summary>
            <remarks>
            This just automatically calls <see cref="M:Robust.Client.Replays.Playback.IReplayPlaybackManager.SetIndex(System.Int32,System.Boolean)"/> every tick, as opposed to having the UI control call
            that method directly every frame update.
            </remarks>
        </member>
        <member name="M:Robust.Client.Replays.Playback.IReplayPlaybackManager.SetIndex(System.Int32,System.Boolean)">
            <summary>
            Set the current replay index (i.e., jump to a specific point in time). The zeroth index corresponds to the first
            tick of the replay.
            </summary>
        </member>
        <member name="M:Robust.Client.Replays.Playback.IReplayPlaybackManager.GetIndex(System.TimeSpan)">
            <summary>
            Gets the index corresponding to some time. <see cref="F:System.TimeSpan.Zero"/> corresponds to the beginning
            of the replay.
            </summary>
        </member>
        <member name="M:Robust.Client.Replays.Playback.IReplayPlaybackManager.SetTime(System.TimeSpan)">
            <summary>
            Sets the current replay time to some specified value. <see cref="F:System.TimeSpan.Zero"/> corresponds to the beginning
            of the replay.
            </summary>
        </member>
        <member name="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.ReplayPlaybackStarted">
            <summary>
            Invoked after replay playback has started and the first game state has been applied. Provides the replay
            metadata and the messages that were received just before the replay recording was started.
            </summary>
        </member>
        <member name="P:Robust.Client.Replays.Playback.IReplayPlaybackManager.AutoPauseCountdown">
            <summary>
            If not null, this will cause the playback to auto-pause after some number of ticks. E.g., if you want to advance
            the replay by 5 ticks and then pause, set this to 5 and set <see cref="P:Robust.Client.Replays.Playback.IReplayPlaybackManager.Playing"/> to true.
            </summary>
        </member>
        <member name="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.ReplayPlaybackStopped">
            <summary>
            Invoked after replay playback has stopped and the replay has been unloaded.
            </summary>
        </member>
        <member name="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.ReplayCheckpointReset">
            <summary>
            Invoked when the replay rewinds or jumps forward to some checkpoint state.
            </summary>
        </member>
        <member name="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.HandleReplayMessage">
            <summary>
            This gets invoked in order to allow content to handle a replay message. If the return value is false and the
            message is a <see cref="T:Robust.Shared.GameObjects.EntityEventArgs"/>, then it will simply be raised as if it had been received over the
            network.
            </summary>
        </member>
        <member name="T:Robust.Client.Replays.Playback.IReplayPlaybackManager.HandleReplayMessageDelegate">
            <param name="message">The message that is to be handled</param>
            <param name="skipEffects">Whether transient/visual effects should be skipped. This option is true when skipping
            through large portions of the replay, in order to avoid spamming audio and other such effects while still
            applying important or game-state modifying messages.</param>
        </member>
        <member name="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.BeforeSetTick">
            <summary>
            This action is invoked just before jumping forward or backward in time. See also <see cref="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.AfterSetTick"/>.
            </summary>
            <remarks>
            This can be used by content to do things like fetching information about the current viewport / observer
            position, so that the position can be updated after the jump, which might potentially cause the old position to
            be invalid (e.g., map or grid might get deleted).
            </remarks>
        </member>
        <member name="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.AfterSetTick">
            <summary>
            This action is invoked after jumping forward or backward in time. See also <see cref="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.BeforeSetTick"/>.
            </summary>
        </member>
        <member name="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.ReplayPaused">
            <summary>
            Invoked when the replay is paused.
            </summary>
        </member>
        <member name="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.ReplayUnpaused">
            <summary>
            Invoked when the replay is unpaused.
            </summary>
        </member>
        <member name="E:Robust.Client.Replays.Playback.IReplayPlaybackManager.BeforeApplyState">
            <summary>
            Invoked just before a replay applies a game state.
            </summary>
        </member>
        <member name="P:Robust.Client.Replays.Playback.IReplayPlaybackManager.Recorder">
            <summary>
            If currently replaying a client-side recording, this is the user that recorded the replay.
            Useful for setting default observer spawn positions.
            </summary>
        </member>
        <member name="M:Robust.Client.Replays.Playback.IReplayPlaybackManager.TryGetRecorderEntity(System.Nullable{Robust.Shared.GameObjects.EntityUid}@)">
            <summary>
            Fetches the entity that the <see cref="P:Robust.Client.Replays.Playback.IReplayPlaybackManager.Recorder"/> is currently attached to.
            </summary>
        </member>
        <member name="M:Robust.Client.Replays.Playback.ReplayPlaybackManager.ResetToNearestCheckpoint(System.Int32,System.Boolean,Robust.Shared.Replays.CheckpointState)">
            <summary>
            This function resets the game state to some checkpoint state. This is effectively what enables rewinding time.
            </summary>
            <param name="index">The target tick/index. The actual checkpoint will have an index less than or equal to this.</param>
            <param name="flushEntities">Whether to delete all entities</param>
        </member>
        <member name="T:Robust.Client.Replays.UI.ReplayControlWidget">
            <summary>
            This is a simple replay demonstration widget that has basic controls for manipulating a replay.
            </summary>
        </member>
        <member name="F:Robust.Client.Replays.UI.ReplayControlWidget.SmallJump">
            <summary>
            Number of ticks to jump by when using the forward/backward buttons.
            </summary>
        </member>
        <member name="F:Robust.Client.Replays.UI.ReplayControlWidget.BigJump">
            <summary>
            Number of ticks to jump by when using the fast forward/backward buttons.
            </summary>
        </member>
        <member name="T:Robust.Client.ResourceManagement.BaseResource">
            <summary>
                Base resource for the cache.
            </summary>
        </member>
        <member name="P:Robust.Client.ResourceManagement.BaseResource.Fallback">
            <summary>
                Fallback resource path if this one does not exist.
            </summary>
        </member>
        <member name="M:Robust.Client.ResourceManagement.BaseResource.Dispose">
            <summary>
                Disposes this resource.
            </summary>
        </member>
        <member name="M:Robust.Client.ResourceManagement.BaseResource.Load(Robust.Shared.IoC.IDependencyCollection,Robust.Shared.Utility.ResPath)">
            <summary>
                Deserializes the resource from the VFS.
            </summary>
        </member>
        <member name="T:Robust.Client.ResourceManagement.IResourceCache">
            <summary>
            Handles caching of <see cref="T:Robust.Client.ResourceManagement.BaseResource"/>
            </summary>
        </member>
        <member name="T:Robust.Client.ResourceManagement.IResourceCacheInternal">
            <inheritdoc />
        </member>
        <member name="T:Robust.Client.ResourceManagement.ResourceCache">
            <summary>
            Handles caching of <see cref="T:Robust.Client.ResourceManagement.BaseResource"/>
            </summary>
        </member>
        <member name="T:Robust.Client.ResourceManagement.RSIResource">
            <summary>
                Handles the loading code for RSI files.
                See <see cref="P:Robust.Client.ResourceManagement.RSIResource.RSI"/> for the RSI API itself.
            </summary>
        </member>
        <member name="F:Robust.Client.ResourceManagement.RSIResource.MINIMUM_RSI_VERSION">
            <summary>
                The minimum version of RSI we can load.
            </summary>
        </member>
        <member name="F:Robust.Client.ResourceManagement.RSIResource.MAXIMUM_RSI_VERSION">
            <summary>
                The maximum version of RSI we can load.
            </summary>
        </member>
        <member name="M:Robust.Client.ResourceManagement.RSIResource.FoldDelays(System.Single[][])">
            <summary>
                Folds a per-directional sets of animation delays
                into an equivalent set of animation delays and indices that works for every direction.
            </summary>
        </member>
        <member name="T:Robust.Client.ResourceManagement.ShaderSourceResource">
            <summary>
                Loads the **source code** of a shader.
            </summary>
        </member>
        <member name="M:Robust.Client.Serialization.IClientRobustSerializer.SetStringSerializerPackage(System.Byte[],System.Byte[])">
            <summary>
                Sets the string mappings used by <see cref="T:Robust.Shared.Serialization.IRobustMappedStringSerializer"/>. Only supported in single
                player games.
            </summary>
        </member>
        <member name="M:Robust.Client.State.State.StartupInternal(Robust.Client.UserInterface.IUserInterfaceManager)">
            <summary>
                Game switching to this state
            </summary>
        </member>
        <member name="M:Robust.Client.State.State.ShutdownInternal(Robust.Client.UserInterface.IUserInterfaceManager)">
            <summary>
                Game switching away from this state
            </summary>
        </member>
        <member name="P:Robust.Client.Timing.ClientGameTiming.LastRealTick">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Timing.ClientGameTiming.LastProcessedTick">
            <inheritdoc />
        </member>
        <member name="P:Robust.Client.Timing.IClientGameTiming.LastProcessedTick">
            <summary>
            This is functionally the clients "current-tick" before prediction, and represents the target value for <see
            cref="P:Robust.Client.Timing.IClientGameTiming.LastRealTick"/>. This value should increment by at least one every tick. It may increase by more than
            that if we apply several server states within a single tick.
            </summary>
        </member>
        <member name="P:Robust.Client.Timing.IClientGameTiming.LastRealTick">
            <summary>
            The last real non-extrapolated server state that was applied. Without networking issues, this tick should
            always correspond to <see cref="P:Robust.Client.Timing.IClientGameTiming.LastRealTick"/>, however if there is a missing states or the buffer has run
            out, this value may be smaller..
            </summary>
        </member>
        <member name="M:Robust.Client.Upload.NetworkResourceManager.ClearResources">
            <summary>
                Clears all the networked resources. If used while connected to a server, this will probably cause issues.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.AttachedPropertyChangedCallback">
            <param name="owner">Control on which the property was changed.</param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:Robust.Client.UserInterface.AttachedProperty">
            <summary>
                An attached property is a property that can be assigned to any control,
                without having to modify the base <see cref="T:Robust.Client.UserInterface.Control" /> class to add it.
                This is useful for storing data for specific controls like <see cref="T:Robust.Client.UserInterface.Controls.LayoutContainer" />
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.AttachedProperty.Name">
            <summary>
                The name of the property.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.AttachedProperty.OwningType">
            <summary>
                The type that defines the attached property.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.AttachedProperty.PropertyType">
            <summary>
                The type of the value stored in the property.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.AttachedProperty.DefaultValue">
            <summary>
                The default value of the property.
                This is returned if no value is set and <see cref="M:Robust.Client.UserInterface.Control.GetValue(Robust.Client.UserInterface.AttachedProperty)"/> is called.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.AttachedProperty.Validate">
            <summary>
                An optional validation function.
                If the value to <see cref="M:Robust.Client.UserInterface.Control.SetValue(Robust.Client.UserInterface.AttachedProperty,System.Object)"/> fails this check, an exception will be thrown.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.AttachedProperty.Changed">
            <summary>
                A callback to run whenever this property changes on a control.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.AttachedProperty.Create(System.String,System.Type,System.Type,System.Object,System.Func{System.Object,System.Boolean},Robust.Client.UserInterface.AttachedPropertyChangedCallback)">
            <remarks>
                Parameters correspond to properties on this class.
            </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.AttachedPropertyChangedEventArgs">
            <summary>
                Event args for when an attached property on a control changes.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.BoundUserInterfaceExt.CreateWindow``1(Robust.Shared.GameObjects.BoundUserInterface)">
            <summary>
            Helper method to create a window and also handle closing the BUI when it's closed.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.BoundUserInterfaceExt.CreateDisposableControl``1(Robust.Shared.GameObjects.BoundUserInterface)">
            <summary>
            Creates a control for this BUI that will be disposed when it is disposed.
            </summary>
            <param name="bui"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Robust.Client.UserInterface.Control">
            <summary>
                A node in the GUI system.
                See https://docs.spacestation14.io/en/engine/user-interface for some basic concepts.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.PlayAnimation(Robust.Client.Animations.Animation,System.String)">
            <summary>
                Start playing an animation.
            </summary>
            <param name="animation">The animation to play.</param>
            <param name="key">
                The key for this animation play. This key can be used to stop playback short later.
            </param>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Name">
            <summary>
                The name of this control.
                Names must be unique between the siblings of the control.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.AlwaysRender">
            <summary>
                If true, this control will always be rendered, even if other UI rendering is disabled.
            </summary>
            <remarks>
                Useful for e.g. primary viewports.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Parent">
            <summary>
                Our parent inside the control tree.
            </summary>
            <remarks>
                This cannot be changed directly. Use <see cref="M:Robust.Client.UserInterface.Control.AddChild(Robust.Client.UserInterface.Control)" /> and such on the parent to change it.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.UserInterfaceManager">
            <summary>
                The UserInterfaceManager we belong to, for convenience.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Children">
            <summary>
                Gets an ordered enumerable over all the children of this control.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.VisibleInTree">
            <summary>
                Gets whether this control is at all visible.
                This means the control is part of the tree of the root control, and all of its parents are visible.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.Visible"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Visible">
            <summary>
                Whether or not this control and its children are visible.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.VisibleInTree"/>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.VisibilityChanged(System.Boolean)">
            <summary>
            Called when this control's visibility in the control tree changed.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.ReservesSpace">
            <summary>
                Whether or not this control and its children require
                space to be reserved, even when not visible.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.ReservesSpace"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.IsInsideTree">
            <summary>
                Whether or not this control is an (possibly indirect) child of
                <see cref="P:Robust.Client.UserInterface.IUserInterfaceManager.RootControl"/>
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.ExitedTree">
            <summary>
                Called when the control is removed from the root control tree.
            </summary>
            <seealso cref="M:Robust.Client.UserInterface.Control.EnteredTree"/>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.EnteredTree">
            <summary>
                Called when the control enters the root control tree.
            </summary>
            <seealso cref="M:Robust.Client.UserInterface.Control.ExitedTree"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.ToolTip">
            <summary>
            Simple text tooltip that is shown when the mouse is hovered over this control for a bit.
            See <see cref="P:Robust.Client.UserInterface.Control.TooltipSupplier"/> or <see cref="E:Robust.Client.UserInterface.Control.OnShowTooltip"/> for a more customizable alternative.
            No effect when TooltipSupplier is specified.
            </summary>
            <remarks>
            If empty or null, no tooltip is shown in the first place (but OnShowTooltip and OnHideTooltip
            events are still fired).
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.TooltipDelay">
            <summary>
            Overrides the global tooltip delay, showing the tooltip for this
            control within the specified number of seconds.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.TrackingTooltip">
            <summary>
            Should the tooltip track the mouse cursor.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.TooltipSupplier">
             <summary>
             When a tooltip should be shown for this control, this will be invoked to
             produce a control which will serve as the tooltip (doing nothing if null is returned).
             This is the generally recommended way to implement custom tooltips for controls, as it takes
             care of the various edge cases for showing / hiding the tooltip.
             For an even more customizable approach, <see cref="E:Robust.Client.UserInterface.Control.OnShowTooltip"/>
            
             The returned control will be added to PopupRoot, and positioned
             within the user interface under the current mouse position to avoid going off the edge of the
             screen. When the tooltip should be hidden, the control will be hidden by removing it from the tree.
            
             It is expected that the returned control remains within PopupRoot. Other classes should
             not move it around in the tree or move it out of PopupRoot, but may access and modify
             the control and its children via <see cref="P:Robust.Client.UserInterface.Control.SuppliedTooltip"/>.
             </summary>
             <remarks>
             Returning a new instance of a tooltip control every time is usually fine. If for some
             reason constructing the tooltip control is expensive, it MAY be fine to cache + reuse a single instance but this
             approach has not yet been tested.
             </remarks>
        </member>
        <member name="E:Robust.Client.UserInterface.Control.OnShowTooltip">
             <summary>
             Invoked when the mouse is hovered over this control for a bit and a tooltip
             should be shown. Can be used as an alternative to ToolTip or TooltipSupplier to perform custom tooltip
             logic such as showing a more complex tooltip control.
            
             Any custom tooltip controls should typically be added
             as a child of UserInterfaceManager.PopupRoot
             Handlers can use <see cref="M:Robust.Client.UserInterface.Tooltips.PositionTooltip(Robust.Client.UserInterface.Control)"/> to assist with positioning
             custom tooltip controls.
             </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.SuppliedTooltip">
            <summary>
            If this control is currently showing a tooltip provided via TooltipSupplier,
            returns that tooltip. Do not move this control within the tree, it should remain in PopupRoot.
            Also, as it may be hidden (removed from tree) at any time, saving a reference to this is a Bad Idea.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.HideTooltip">
            <summary>
            Manually hide the tooltip currently being shown for this control, if there is one.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Control.OnHideTooltip">
            <summary>
            Invoked when this control is showing a tooltip which should now be hidden.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.MouseFilter">
            <summary>
                The mode that controls how mouse filtering works. See the enum for how it functions.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.CanKeyboardFocus">
            <summary>
                Whether this control can take keyboard focus.
                Keyboard focus is necessary for the control to receive keyboard events.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.KeyboardFocusOnClick"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.KeyboardFocusOnClick">
            <summary>
                Whether the control will automatically receive keyboard focus (if possible) when clicked on.
            </summary>
            <remarks>
                Obviously, <see cref="P:Robust.Client.UserInterface.Control.CanKeyboardFocus"/> must be set to true for this to work.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.RectClipContent">
            <summary>
                Whether to clip drawing of this control and its children to its rectangle.
            </summary>
            <remarks>
                By default, controls (and their children) can render outside their rectangle.
                If this is set, rendering is hard clipped to it.
            </remarks>
            <seealso cref="P:Robust.Client.UserInterface.Control.RectDrawClipMargin"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.RectDrawClipMargin">
            <summary>
                A margin around this control. If this control + this margin is outside its parent's <see cref="P:Robust.Client.UserInterface.Control.RectClipContent" />,
                it will not be drawn.
            </summary>
            <remarks>
                A control rectangle does not necessarily have to be listened to for drawing.
                So the problem is, how do we know where to stop trying to draw the control if it's clipped away?
            </remarks>
            <seealso cref="P:Robust.Client.UserInterface.Control.RectClipContent"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.ModulateSelfOverride">
            <summary>
                An override for the modulate self from the style sheet.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.ActualModulateSelf" />
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Modulate">
            <summary>
                Modulates the color of this control and all its children when drawing.
            </summary>
            <remarks>
                Modulation is multiplying or tinting the color basically.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.ActualModulateSelf">
             <summary>
                 The value used to modulate this control (and not its siblings) with on top of <see cref="P:Robust.Client.UserInterface.Control.Modulate"/>
                 when drawing.
             </summary>
             <remarks>
                 By default this value is pulled from CSS, or <see cref="P:Robust.Client.UserInterface.Control.ModulateSelfOverride"/> if available.
            
                 Modulation is multiplying or tinting the color basically.
             </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.#ctor">
            <summary>
                Default constructor.
                The name of the control is decided based on type.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.Draw(Robust.Client.Graphics.DrawingHandleScreen)">
            <summary>
                Called to render this control.
            </summary>
            <remarks>
                Drawing is done relative to the position of the control.
                It is also done in pixel space, so you should not directly use properties such as <see cref="P:Robust.Client.UserInterface.Control.Size"/>.
            </remarks>
            <param name="handle">A handle that can be used to draw.</param>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.ModalRemoved">
            <summary>
                Called when this modal control is closed.
                Only used for controls that are actually modals.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.Dispose">
            <summary>
                Dispose this control, its own scene control, and all its children.
                Basically the big delete button.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.DisposeAllChildren">
            <summary>
                Dispose all children, but leave this one intact.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.RemoveAllChildren">
            <summary>
                Remove all the children from this control.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.Orphan">
            <summary>
                Make this child an orphan. i.e. remove it from its parent if it has one.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.AddChild(Robust.Client.UserInterface.Control)">
            <summary>
                Make the provided control a parent of this control.
            </summary>
            <param name="child">The control to make a child of this control.</param>
            <exception cref="T:System.InvalidOperationException">
                Thrown if we already have a component with the same name,
                or the provided component is still parented to a different control.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="child" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.ChildAdded(Robust.Client.UserInterface.Control)">
            <summary>
                Called after a new child is added to this control.
            </summary>
            <param name="newChild">The new child.</param>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.Parented(Robust.Client.UserInterface.Control)">
            <summary>
                Called when this control gets made a child of a different control.
            </summary>
            <param name="newParent">The new parent component.</param>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.RemoveChild(Robust.Client.UserInterface.Control)">
            <summary>
                Removes the provided child from this control.
            </summary>
            <param name="child">The child to remove.</param>
            <exception cref="T:System.InvalidOperationException">
                Thrown if the provided child is not one of this control's children.
            </exception>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.ChildRemoved(Robust.Client.UserInterface.Control)">
            <summary>
                Called when a child is removed from this child.
            </summary>
            <param name="child">The former child.</param>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.Deparented">
            <summary>
                Called when this control is removed as child from the former parent.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.ChildMoved(Robust.Client.UserInterface.Control,System.Int32,System.Int32)">
            <summary>
                Called when the order index of a child changes.
            </summary>
            <param name="child">The child that was changed.</param>
            <param name="oldIndex">The previous index of the child.</param>
            <param name="newIndex">The new index of the child.</param>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.HasPoint(System.Numerics.Vector2)">
            <summary>
                Called to test whether this control has a certain point,
                for the purposes of finding controls under the cursor.
            </summary>
            <param name="point">The relative point, in virtual pixels.</param>
            <returns>True if this control does have the point and should be counted as a hit.</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.GetChild(System.Int32)">
            <summary>
                Gets the immediate child of this control with the specified index.
            </summary>
            <param name="index">The index of the child.</param>
            <returns>The child.</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.GetPositionInParent">
            <summary>
                Gets the "index" in the parent.
                This index is used for ordering of actions like input and drawing among siblings.
            </summary>
            <exception cref="T:System.InvalidOperationException">
                Thrown if this control has no parent.
            </exception>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.SetPositionInParent(System.Int32)">
            <summary>
                Sets the index of this control in the parent.
                This pretty much corresponds to layout and drawing order in relation to its siblings.
            </summary>
            <param name="position"></param>
            <exception cref="T:System.InvalidOperationException">This control has no parent.</exception>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.SetPositionFirst">
            <summary>
                Makes this the first control among its siblings,
                So that it's first in things such as drawing order.
            </summary>
            <exception cref="T:System.InvalidOperationException">This control has no parent.</exception>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.SetPositionLast">
            <summary>
                Makes this the last control among its siblings,
                So that it's last in things such as drawing order.
            </summary>
            <exception cref="T:System.InvalidOperationException">This control has no parent.</exception>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.KeyboardFocusEntered">
            <summary>
                Called when this control receives keyboard focus.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.KeyboardFocusExited">
            <summary>
                Called when this control loses keyboard focus (corresponds to UserInterfaceManager.KeyboardFocused).
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.ControlFocusExited">
             <summary>
                 Fired when a control loses control focus for any reason. See <see cref="P:Robust.Client.UserInterface.IUserInterfaceManager.ControlFocused"/>.
             </summary>
             <remarks>
                 Controls which have some sort of drag / drop behavior should usually implement this method (typically by cancelling the drag drop).
                 Otherwise, if a user clicks down LMB over one control to initiate a drag, then clicks RMB down
                 over a different control while still holding down LMB, the control being dragged will now lose focus
                 and will no longer receive the keyup for the LMB, thus won't cancel the drag.
                 This should also be considered for controls which have any special KeyBindUp behavior - consider
                 what would happen if the control lost focus and never received the KeyBindUp.
            
                 There is no corresponding ControlFocusEntered - if a control wants to handle that situation they should simply
                 handle KeyBindDown as that's the only way a control would gain focus.
             </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.HasKeyboardFocus">
            <summary>
                Check if this control currently has keyboard focus.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.GrabKeyboardFocus">
            <summary>
                Grab keyboard focus if this control doesn't already have it.
            </summary>
            <remarks>
                <see cref="P:Robust.Client.UserInterface.Control.CanKeyboardFocus"/> must be true for this to work.
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.ReleaseKeyboardFocus">
            <summary>
                Release keyboard focus from this control if it has it.
                If a different control has keyboard focus, nothing happens.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.Resized">
            <summary>
                Called when the size of the control changes.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.FrameUpdate(Robust.Shared.Timing.FrameEventArgs)">
            <summary>
                This is called before every render frame.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Control.MouseFilterMode">
            <summary>
                Mode that will be tested when testing controls to invoke mouse button events on.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.MouseFilterMode.Pass">
            <summary>
                The control will be able to receive mouse buttons events.
                Furthermore, if a control with this mode does get clicked,
                the event automatically gets marked as handled after every other candidate has been tried,
                so that the rest of the game does not receive it.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.MouseFilterMode.Stop">
            <summary>
                The control will be able to receive mouse button events like <see cref="F:Robust.Client.UserInterface.Control.MouseFilterMode.Pass" />,
                but the event will be stopped and handled even if the relevant events do not handle it.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.MouseFilterMode.Ignore">
            <summary>
                The control will not be considered at all, and will not have any effects.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Control.CursorShape">
            <summary>
                Default common cursor shapes available in the UI.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.CursorShape.Custom">
            <summary>
                Special cursor shape indicating that <see cref="P:Robust.Client.UserInterface.Control.CustomCursorShape"/> is set and being used.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.DefaultCursorShape">
            <summary>
                The shape the cursor will get when being over this control.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.CustomCursorShape">
            <summary>
                Custom cursor shape to use.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Control.OnMouseEntered">
            <summary>
                Invoked when the mouse enters the area of this control / when it hovers over the control.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Control.OnMouseExited">
            <summary>
                Invoked when the mouse exits the area of this control / when it stops hovering over the control.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.DesiredSize">
            <summary>
            The desired minimum size this control needs for layout to avoid cutting off content or such.
            </summary>
            <remarks>
            This is calculated by calling <see cref="M:Robust.Client.UserInterface.Control.Measure(System.Numerics.Vector2)"/>.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Margin">
            <summary>
            Controls the amount of empty space in virtual pixels around the control.
            </summary>
            <remarks>Values can be provided as "All" or "Horizontal, Vertical" or "Left, Top, Right, Bottom"</remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.UIScaleChanged">
            <summary>
                Called when the <see cref="P:Robust.Client.UserInterface.Control.UIScale"/> for this control changes.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.UIScale">
            <summary>
                The amount of "real" pixels a virtual pixel takes up.
                The higher the number, the bigger the interface.
                I.e. UIScale units are real pixels (rp) / virtual pixels (vp),
                real pixels varies depending on interface, virtual pixels doesn't.
                And vp * UIScale = rp, and rp / UIScale = vp
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Size">
            <summary>
                The size of this control, in virtual pixels.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.PixelSize"/>
            <seealso cref="P:Robust.Client.UserInterface.Control.Width"/>
            <seealso cref="P:Robust.Client.UserInterface.Control.Height"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.PixelSize">
            <summary>
                The size of this control, in physical pixels.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.SizeBox">
            <summary>
                A <see cref="T:Robust.Shared.Maths.UIBox2"/> with the top left at 0,0 and the size equal to <see cref="P:Robust.Client.UserInterface.Control.Size"/>.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.PixelSizeBox"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.PixelSizeBox">
            <summary>
                A <see cref="T:Robust.Shared.Maths.UIBox2i"/> with the top left at 0,0 and the size equal to <see cref="P:Robust.Client.UserInterface.Control.PixelSize"/>.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.SizeBox"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Width">
            <summary>
                The width of the control, in virtual pixels.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.PixelWidth"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Height">
            <summary>
                The height of the control, in virtual pixels.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.PixelHeight"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.PixelWidth">
            <summary>
                The width of the control, in physical pixels.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.Width"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.PixelHeight">
            <summary>
                The height of the control, in physical pixels.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.Height"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Position">
            <summary>
                The position of the top left corner of the control, in virtual pixels.
                This is relative to the position of the parent.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.PixelPosition"/>
            <seealso cref="P:Robust.Client.UserInterface.Control.GlobalPosition"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.PixelPosition">
            <summary>
                The position of the top left corner of the control, in physical pixels.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.Position"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.GlobalPosition">
            <summary>
                The position of the top left corner of the control, in virtual pixels.
                This is not relative to the parent.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.GlobalPosition"/>
            <seealso cref="P:Robust.Client.UserInterface.Control.Position"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.GlobalPixelPosition">
            <summary>
                The position of the top left corner of the control, in physical pixels.
                This is not relative to the parent.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.GlobalPosition"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Rect">
            <summary>
                Represents the "rectangle" of the control relative to the parent, in virtual pixels.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.PixelRect"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.PixelRect">
            <summary>
                Represents the "rectangle" of the control relative to the parent, in physical pixels.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.Rect"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.HorizontalAlignment">
            <summary>
            Horizontal alignment mode.
            This determines how the control should be laid out horizontally
            if it gets more available space than its <see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.VerticalAlignment">
            <summary>
            Vertical alignment mode.
            This determines how the control should be laid out vertically
            if it gets more available space than its <see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.HorizontalExpand">
            <summary>
            Whether to horizontally expand and push other controls in layout controls that support this.
            This does nothing unless the parent is a control like <see cref="T:Robust.Client.UserInterface.Controls.BoxContainer"/> which supports this behavior.
            </summary>
            <remarks>
            If I was redesigning the UI system from scratch today, this would be an attached property instead.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.VerticalExpand">
            <summary>
            Whether to vertically expand and push other controls in layout controls that support this.
            This does nothing unless the parent is a control like <see cref="T:Robust.Client.UserInterface.Controls.BoxContainer"/> which supports this behavior.
            </summary>
            <remarks>
            If I was redesigning the UI system from scratch today, this would be an attached property instead.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.SizeFlagsStretchRatio">
            <summary>
                Stretch ratio used to give shared of the available space in case multiple siblings are set to expand
                in a container
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
                Thrown if the value is less than or equal to 0.
            </exception>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.MinSize">
            <summary>
            A settable minimum size for this control.
            This is factored into <see cref="M:Robust.Client.UserInterface.Control.MeasureCore(System.Numerics.Vector2)"/> so that this control itself always has at least this size.
            </summary>
            <remarks>
            <para>
            This is not to be confused with <see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/>,
            which contains the actual calculated minimum size from the layout system.
            This property is just an input parameter.
            </para>
            <para>
            If <see cref="P:Robust.Client.UserInterface.Control.MaxSize"/>, <see cref="P:Robust.Client.UserInterface.Control.MinSize"/> and/or <see cref="P:Robust.Client.UserInterface.Control.SetSize"/> are in conflict,
            <see cref="P:Robust.Client.UserInterface.Control.MinSize"/> is the most important, then <see cref="P:Robust.Client.UserInterface.Control.MaxSize"/>, then <see cref="P:Robust.Client.UserInterface.Control.SetSize"/>.
            </para>
            </remarks>
            <seealso cref="P:Robust.Client.UserInterface.Control.MinWidth"/>
            <seealso cref="P:Robust.Client.UserInterface.Control.MinHeight"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.SetSize">
            <summary>
            A settable exact size for this control.
            This is factored into <see cref="M:Robust.Client.UserInterface.Control.MeasureCore(System.Numerics.Vector2)"/> so that this control itself always has exactly this size.
            </summary>
            <remarks>
            <para>
            This is not to be confused with <see cref="P:Robust.Client.UserInterface.Control.Size"/>,
            which contains the actual calculated size from the layout system.
            This property is just an input parameter.
            </para>
            <para>
            If <see cref="P:Robust.Client.UserInterface.Control.MaxSize"/>, <see cref="P:Robust.Client.UserInterface.Control.MinSize"/> and/or <see cref="P:Robust.Client.UserInterface.Control.SetSize"/> are in conflict,
            <see cref="P:Robust.Client.UserInterface.Control.MinSize"/> is the most important, then <see cref="P:Robust.Client.UserInterface.Control.MaxSize"/>, then <see cref="P:Robust.Client.UserInterface.Control.SetSize"/>.
            </para>
            </remarks>
            <seealso cref="P:Robust.Client.UserInterface.Control.SetWidth"/>
            <seealso cref="P:Robust.Client.UserInterface.Control.SetHeight"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.MaxSize">
            <summary>
            A settable maximum size for this control.
            This is factored into <see cref="M:Robust.Client.UserInterface.Control.MeasureCore(System.Numerics.Vector2)"/> so that this control itself always has at most this size.
            </summary>
            <remarks>
            If <see cref="P:Robust.Client.UserInterface.Control.MaxSize"/>, <see cref="P:Robust.Client.UserInterface.Control.MinSize"/> and/or <see cref="P:Robust.Client.UserInterface.Control.SetSize"/> are in conflict,
            <see cref="P:Robust.Client.UserInterface.Control.MinSize"/> is the most important, then <see cref="P:Robust.Client.UserInterface.Control.MaxSize"/>, then <see cref="P:Robust.Client.UserInterface.Control.SetSize"/>.
            </remarks>
            <seealso cref="P:Robust.Client.UserInterface.Control.MaxWidth"/>
            <seealso cref="P:Robust.Client.UserInterface.Control.MaxHeight"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.MinWidth">
            <summary>
            Width component of <see cref="P:Robust.Client.UserInterface.Control.MinSize"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.MinHeight">
            <summary>
            Height component of <see cref="P:Robust.Client.UserInterface.Control.MinSize"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.SetWidth">
            <summary>
            Width component of <see cref="P:Robust.Client.UserInterface.Control.SetSize"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.SetHeight">
            <summary>
            Height component of <see cref="P:Robust.Client.UserInterface.Control.SetSize"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.MaxWidth">
            <summary>
            Width component of <see cref="P:Robust.Client.UserInterface.Control.MaxSize"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.MaxHeight">
            <summary>
            Height component of <see cref="P:Robust.Client.UserInterface.Control.MaxSize"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.GetLocalPosition(Robust.Shared.Map.ScreenCoordinates)">
            <summary>
            Gets the screen coordinates position relative to the control.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.InvalidateMeasure">
            <summary>
            Notify the layout system that this control's <see cref="M:Robust.Client.UserInterface.Control.Measure(System.Numerics.Vector2)"/> result may have changed
            and must be recalculated.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.InvalidateArrange">
            <summary>
            Notify the layout system that this control's <see cref="M:Robust.Client.UserInterface.Control.Arrange(Robust.Shared.Maths.UIBox2)"/> result may have changed
            and must be recalculated.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.Measure(System.Numerics.Vector2)">
            <summary>
            Measure the desired size of this control, if given a specific available space.
            The result of this measure is stored in <see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/>.
            </summary>
            <remarks>
            Available size is given to this method so that controls can handle special cases such as text layout,
            where word wrapping can cause the vertical size to change based on available horizontal size.
            </remarks>
            <param name="availableSize">The space available to this control, that it should measure for.</param>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.MeasureCore(System.Numerics.Vector2)">
            <summary>
            Core logic implementation of <see cref="M:Robust.Client.UserInterface.Control.Measure(System.Numerics.Vector2)"/>,
            implementing stuff such as margins and <see cref="P:Robust.Client.UserInterface.Control.MinSize"/>.
            In almost all cases, you want to override <see cref="M:Robust.Client.UserInterface.Control.MeasureOverride(System.Numerics.Vector2)"/> instead, which is called by this.
            </summary>
            <returns>The actual measured desired size of the control.</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.MeasureOverride(System.Numerics.Vector2)">
            <summary>
            Calculates the actual desired size for the contents of this control, based on available size.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.ArrangePixel(Robust.Shared.Maths.UIBox2i)">
            <summary>
            Lay out this control in the given space of its parent, by pixel coordinates.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.Arrange(Robust.Shared.Maths.UIBox2)">
            <summary>
            Lay out this control in the given space of its parent.
            This sets <see cref="P:Robust.Client.UserInterface.Control.Position"/> and <see cref="P:Robust.Client.UserInterface.Control.Size"/> and also arranges any child controls.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.ArrangeCore(Robust.Shared.Maths.UIBox2)">
            <summary>
            Core logic implementation of <see cref="M:Robust.Client.UserInterface.Control.Arrange(Robust.Shared.Maths.UIBox2)"/>,
            implementing stuff such as margins and <see cref="P:Robust.Client.UserInterface.Control.MinSize"/>.
            In almost all cases, you want to override <see cref="M:Robust.Client.UserInterface.Control.ArrangeOverride(System.Numerics.Vector2)"/> instead, which is called by this.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.ArrangeOverride(System.Numerics.Vector2)">
            <summary>
            Lay out this control and its children for the specified final size.
            </summary>
            <param name="finalSize">
            The final size for this control,
            after calculation of things like margins and alignment.
            </param>
            <returns>The actual space used by this control.</returns>
        </member>
        <member name="T:Robust.Client.UserInterface.Control.HAlignment">
            <summary>
            Specifies horizontal alignment modes.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.HorizontalAlignment"/>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.HAlignment.Stretch">
            <summary>
            The control should take up all available horizontal space.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.HAlignment.Left">
            <summary>
            The control should take up minimal (<see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/>) space and align to the left of its given space.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.HAlignment.Center">
            <summary>
            The control should take up minimal (<see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/>) space and align in the center of its given space.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.HAlignment.Right">
            <summary>
            The control should take up minimal (<see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/>) space and align to the right of its given space.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Control.VAlignment">
            <summary>
            Specifies vertical alignment modes.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.VerticalAlignment"/>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.VAlignment.Stretch">
            <summary>
            The control should take up all available vertical space.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.VAlignment.Top">
            <summary>
            The control should take up minimal (<see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/>) space and align to the top of its given space.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.VAlignment.Center">
            <summary>
            The control should take up minimal (<see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/>) space and align in the center of its given space.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Control.VAlignment.Bottom">
            <summary>
            The control should take up minimal (<see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/>) space and align to the bottom of its given space.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.GetValue(Robust.Client.UserInterface.AttachedProperty)">
            <summary>
            Gets the value of an attached property on this control.
            </summary>
            <param name="property">The attached property to get the value of.</param>
            <returns>
            The property's value for this object,
            or the property's default value if it has not been set on this control yet.
            </returns>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.GetValue``1(Robust.Client.UserInterface.AttachedProperty)">
            <summary>
            Gets the value of an attached property on this control.
            </summary>
            <param name="property">The attached property to get the value of.</param>
            <typeparam name="T">The type to cast the property value to, for convenience.</typeparam>
            <returns>
            The property's value for this object,
            or the property's default value if it has not been set on this control yet.
            </returns>
            <exception cref="T:System.InvalidCastException">
            Thrown if the property value is not of type <typeparamref name="T"/>
            </exception>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.SetValue(Robust.Client.UserInterface.AttachedProperty,System.Object)">
            <summary>
            Sets the value of an attached property on this control.
            </summary>
            <remarks>
            If possible, it is recommended to use <see cref="M:Robust.Client.UserInterface.Control.SetValue``1(Robust.Client.UserInterface.AttachedProperty{``0},``0)"/> instead.
            </remarks>
            <param name="property">The attached property to set.</param>
            <param name="value">The new value.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the property type is a non-nullable value type, but <paramref name="value"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if the type of <paramref name="value"/> is not assignable to the property's type.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if the property has a validation function, and the validation function failed.
            </exception>
        </member>
        <member name="M:Robust.Client.UserInterface.Control.SetValue``1(Robust.Client.UserInterface.AttachedProperty,``0)">
            <summary>
            Sets the value of an attached property on this control.
            </summary>
            <param name="property">The attached property to set.</param>
            <param name="value">The new value.</param>
            <typeparam name="T">
            The type of the value being assigned.
            </typeparam>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the type of <paramref name="value"/> is not assignable to the property's type.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if the property has a validation function, and the validation function failed.
            </exception>
        </member>
        <member name="P:Robust.Client.UserInterface.Control.Stylesheet">
            <summary>
                Overrides the style sheet used for this control and its descendants.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.IUserInterfaceManager.Stylesheet"/>
        </member>
        <member name="P:Robust.Client.UserInterface.GUIMouseHoverEventArgs.SourceControl">
            <summary>
                The control this event originated from.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.GUIBoundKeyEventArgs.RelativePosition">
            <summary>
                Position of the mouse, relative to the current control.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.GUIKeyEventArgs.SourceControl">
            <summary>
                The control spawning this event.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.GUITextEnteredEventArgs">
            <summary>
            Information about text typed on a keyboard-focused UI control.
            </summary>
            <param name="SourceControl">The control spawning this event.</param>
            <param name="TextEnteredEvent">Event data for the typed text.</param>
        </member>
        <member name="M:Robust.Client.UserInterface.GUITextEnteredEventArgs.#ctor(Robust.Client.UserInterface.Control,Robust.Client.Input.TextEnteredEventArgs)">
            <summary>
            Information about text typed on a keyboard-focused UI control.
            </summary>
            <param name="SourceControl">The control spawning this event.</param>
            <param name="TextEnteredEvent">Event data for the typed text.</param>
        </member>
        <member name="P:Robust.Client.UserInterface.GUITextEnteredEventArgs.SourceControl">
            <summary>The control spawning this event.</summary>
        </member>
        <member name="P:Robust.Client.UserInterface.GUITextEnteredEventArgs.TextEnteredEvent">
            <summary>Event data for the typed text.</summary>
        </member>
        <member name="P:Robust.Client.UserInterface.GUITextEnteredEventArgs.Text">
            <summary>
            The text typed by the user.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.GUIMouseEventArgs.SourceControl">
            <summary>
                The control spawning this event.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.GUIMouseEventArgs.GlobalPosition">
            <summary>
                Position of the mouse, relative to the screen.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.GUIMouseEventArgs.RelativePosition">
            <summary>
                Position of the mouse, relative to the current control.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.GUIMouseMoveEventArgs.Relative">
            <summary>
                The new position relative to the previous position.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controllers.IOnStateChanged`1">
            <summary>
                Interface implemented by <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/>s
                Implements both <see cref="T:Robust.Client.UserInterface.Controllers.IOnStateEntered`1"/> and <see cref="T:Robust.Client.UserInterface.Controllers.IOnStateExited`1"/>
            </summary>
            <typeparam name="T">The state type</typeparam>
        </member>
        <member name="T:Robust.Client.UserInterface.Controllers.IOnStateEntered`1">
            <summary>
                Interface implemented by <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/>s
            </summary>
            <typeparam name="T">The state type</typeparam>
        </member>
        <member name="M:Robust.Client.UserInterface.Controllers.IOnStateEntered`1.OnStateEntered(`0)">
            <summary>
                Called by <see cref="M:Robust.Client.UserInterface.UserInterfaceManager.OnStateChanged(Robust.Client.State.StateChangedEventArgs)"/>
                on <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/>s that implement this method when a state
                of the specified type is entered
            </summary>
            <param name="state">The state that was entered</param>
        </member>
        <member name="T:Robust.Client.UserInterface.Controllers.IOnStateExited`1">
            <summary>
                Interface implemented by <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/>s
            </summary>
            <typeparam name="T">The state type</typeparam>
        </member>
        <member name="M:Robust.Client.UserInterface.Controllers.IOnStateExited`1.OnStateExited(`0)">
            <summary>
                Called by <see cref="M:Robust.Client.UserInterface.UserInterfaceManager.OnStateChanged(Robust.Client.State.StateChangedEventArgs)"/>
                on <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/>s that implement this method when a state
                of the specified type is exited
            </summary>
            <param name="state">The state that was exited</param>
        </member>
        <member name="T:Robust.Client.UserInterface.Controllers.IOnSystemChanged`1">
            <summary>
                Interface implemented by <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/>s
                Implements both <see cref="T:Robust.Client.UserInterface.Controllers.IOnSystemLoaded`1"/> and <see cref="T:Robust.Client.UserInterface.Controllers.IOnSystemUnloaded`1"/>
            </summary>
            <typeparam name="T">The entity system type</typeparam>
        </member>
        <member name="T:Robust.Client.UserInterface.Controllers.IOnSystemLoaded`1">
            <summary>
                Interface implemented by <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/>s
            </summary>
            <typeparam name="T">The entity system type</typeparam>
        </member>
        <member name="M:Robust.Client.UserInterface.Controllers.IOnSystemLoaded`1.OnSystemLoaded(`0)">
            <summary>
                Called by <see cref="M:Robust.Client.UserInterface.UserInterfaceManager.OnSystemLoaded(System.Object,Robust.Shared.GameObjects.SystemChangedArgs)"/>
                on <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/>s that implement this method when a system
                of the specified type is loaded
            </summary>
            <param name="system">The system that was loaded</param>
        </member>
        <member name="T:Robust.Client.UserInterface.Controllers.IOnSystemUnloaded`1">
            <summary>
                Interface implemented by <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/>s
            </summary>
            <typeparam name="T">The entity system type</typeparam>
        </member>
        <member name="M:Robust.Client.UserInterface.Controllers.IOnSystemUnloaded`1.OnSystemUnloaded(`0)">
            <summary>
                Called by <see cref="M:Robust.Client.UserInterface.UserInterfaceManager.OnSystemUnloaded(System.Object,Robust.Shared.GameObjects.SystemChangedArgs)"/>
                on <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/>s that implement this method when a system
                of the specified type is unloaded
            </summary>
            <param name="system">The system that was unloaded</param>
        </member>
        <member name="T:Robust.Client.UserInterface.Controllers.UIController">
            <summary>
                Each <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/> is instantiated as a singleton by <see cref="T:Robust.Client.UserInterface.UserInterfaceManager"/>
                <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/> can use <see cref="T:Robust.Shared.IoC.DependencyAttribute"/> for regular IoC dependencies
                and <see cref="T:Robust.Client.UserInterface.UISystemDependencyAttribute"/> to depend on <see cref="T:Robust.Shared.GameObjects.EntitySystem"/>s, which will be automatically
                injected once they are created.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.IUserInterfaceManager.Stylesheet">
            <summary>
                Default style sheet that applies to all controls
                that do not have a more specific style sheet via <see cref="P:Robust.Client.UserInterface.Control.Stylesheet"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.IUserInterfaceManager.KeyboardFocused">
            <summary>
            A control can have "keyboard focus" separate from ControlFocused, obtained when calling
            Control.GrabKeyboardFocus. Corresponding events in Control are KeyboardFocusEntered/Exited
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.IUserInterfaceManager.ControlFocused">
            <summary>
            A control gets "ControlFocused" when a mouse button (or any KeyBinding which has CanFocus = true) is
            pressed down on the control. While it is focused, it will receive mouse hover events and the corresponding
            keyup event if it still has focus when that occurs (it will NOT receive the keyup if focus has
            been taken by another control). Focus is removed when a different control takes focus
            (such as by pressing a different mouse button down over a different control) or when the keyup event
            happens. When focus is lost on a control, it always fires Control.ControlFocusExited.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.IUserInterfaceManager.DefaultUIScale">
            <summary>
                Gets the default UIScale that we will use if <see cref="F:Robust.Shared.CVars.DisplayUIScale"/> gets set to 0.
                Based on the OS-assigned window scale factor.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.IUserInterfaceManager.RootControl">
            <summary>
                The root control for the main game window.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.IUserInterfaceManager.MousePositionScaled">
            <summary>
                Gets the mouse position in UI space, accounting for <see cref="!:UIScale"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManager.GrabKeyboardFocus(Robust.Client.UserInterface.Control)">
            <summary>
                Give a control keyboard focus, releasing focus on the currently focused control (if any).
            </summary>
            <param name="control">The control to give keyboard focus to.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <see cref="!:control"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if <see cref="!:control"/> has <see cref="P:Robust.Client.UserInterface.Control.CanKeyboardFocus"/> <c>false</c>.
            </exception>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManager.ReleaseKeyboardFocus">
            <summary>
                Release keyboard focus from the currently focused control, if any.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManager.ReleaseKeyboardFocus(Robust.Client.UserInterface.Control)">
            <summary>
                Conditionally release keyboard focus if <see cref="!:ifControl"/> has keyboard focus.
            </summary>
            <exception cref="T:System.ArgumentNullException">
                Thrown if <see cref="!:ifControl"/> is <c>null</c>.
            </exception>
            <seealso cref="M:Robust.Client.UserInterface.IUserInterfaceManager.ReleaseKeyboardFocus"/>
        </member>
        <member name="P:Robust.Client.UserInterface.IUserInterfaceManager.WorldCursor">
            <summary>
                Cursor automatically used when the mouse is not over any UI control.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManager.GetWindowRoot(Robust.Client.Graphics.IClydeWindow)">
            <summary>
            Get the UI root associated with a window.
            </summary>
            <returns>Null if the window has no UI root.</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManager.ClickSound">
            <summary>
            Plays the UI click sound if relevant
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManager.HoverSound">
            <summary>
            Plays the UI hover sound if relevant.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManager.SetHovered(Robust.Client.UserInterface.Control)">
            <summary>
            Sets <see cref="P:Robust.Client.UserInterface.IUserInterfaceManager.CurrentlyHovered"/> to the given control.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManager.UpdateHovered">
            <summary>
            Forces <see cref="P:Robust.Client.UserInterface.IUserInterfaceManager.CurrentlyHovered"/> to get updated. This is done automatically when the mouse is moved,
            but not necessarily a new or existing control is rearranged.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.UserInterfaceManager._uiControllers">
            <summary>
                All registered <see cref="T:Robust.Client.UserInterface.Controllers.UIController"/> instances indexed by type
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.UserInterfaceManager._dependencies">
            <summary>
                Dependency collection holding UI controllers and IoC services
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.UserInterfaceManager._onStateEnteredDelegates">
            <summary>
                Implementations of <see cref="T:Robust.Client.UserInterface.Controllers.IOnStateEntered`1"/> to invoke when a state is entered
                State Type -> (UIController, Caller)
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.UserInterfaceManager._onStateExitedDelegates">
            <summary>
                Implementations of <see cref="T:Robust.Client.UserInterface.Controllers.IOnStateExited`1"/> to invoke when a state is exited
                State Type -> (UIController, Caller)
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.UserInterfaceManager._onSystemLoadedDelegates">
            <summary>
                Implementations of <see cref="T:Robust.Client.UserInterface.Controllers.IOnSystemLoaded`1"/> to invoke when an entity system is loaded
                Entity System Type -> (UIController, Caller)
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.UserInterfaceManager._onSystemUnloadedDelegates">
            <summary>
                Implementations of <see cref="T:Robust.Client.UserInterface.Controllers.IOnSystemUnloaded`1"/> to invoke when an entity system is unloaded
                Entity System Type -> (UIController, Caller)
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.UserInterfaceManager._assignerRegistry">
            <summary>
                Field -> Controller -> Field assigner delegate
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.UserInterfaceManager.ControlUpdateLimit">
            <summary>
            Upper limit on the number of times that controls can be measured / arranged each tick before being deferred
            to the next frame update. This is just meant to prevent infinite loops from completely locking up the UI.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.UserInterfaceManager.OnUIKeyBindStateChanged(Robust.Shared.Input.BoundKeyEventArgs)">
            <summary>
                Converts
            </summary>
            <param name="args">Event data values for a bound key state change.</param>
        </member>
        <member name="M:Robust.Client.UserInterface.UserInterfaceManager.GrabKeyboardFocus(Robust.Client.UserInterface.Control)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Client.UserInterface.UserInterfaceManager.QueueMeasureUpdate(Robust.Client.UserInterface.Control)">
            <summary>
            Queues a control so that it gets remeasured in the next frame update. Does not queue an arrange update.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.UserInterfaceManager.QueueArrangeUpdate(Robust.Client.UserInterface.Control)">
            <summary>
            Queues a control so that it gets rearranged in the next frame update. Does not queue a measure update.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.AnimatedTextureRect">
            <summary>
                A more complex control wrapping <see cref="T:Robust.Client.UserInterface.Controls.TextureRect"/> that can do RSI directions and animations.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.AnimatedTextureRect.DisplayRect">
            <summary>
                Internal TextureRect used to do actual drawing of the texture.
                You can use this property to change shaders or styling or such.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.BaseButton">
            <summary>
                Base class for a generic UI button.
            </summary>
            <seealso cref="T:Robust.Client.UserInterface.Controls.Button"/>
            <seealso cref="T:Robust.Client.UserInterface.Controls.TextureButton"/>
            <seealso cref="T:Robust.Client.UserInterface.Controls.CheckBox"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BaseButton.Group">
            <summary>
                Specifies the group this button belongs to.
            </summary>
            <remarks>
                Of multiple buttons in the same group, only one can be pressed (radio buttons).
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BaseButton.Mode">
            <summary>
                Controls mode of operation in relation to press/release events.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BaseButton.Disabled">
            <summary>
                Whether the button is disabled.
                If a button is disabled, it appears greyed out and cannot be interacted with.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BaseButton.Pressed">
            <summary>
                Whether the button is currently toggled down. Only applies when <see cref="P:Robust.Client.UserInterface.Controls.BaseButton.ToggleMode"/> is true.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.BaseButton.SetClickPressed(System.Boolean)">
            <summary>
            Sets the button's press state and also handles click sounds.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BaseButton.EnableAllKeybinds">
            <summary>
                Whether key functions other than <see cref="F:Robust.Shared.Input.EngineKeyFunctions.UIClick"/> trigger the button.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BaseButton.ToggleMode">
            <summary>
                If <c>true</c>, this button functions as a toggle, not as a regular push button.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BaseButton.IsHovered">
            <summary>
                If <c>true</c>, this button is currently being hovered over by the mouse.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BaseButton.DrawMode">
            <summary>
                Draw mode used for styling of buttons.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Controls.BaseButton.OnButtonDown">
            <summary>
                Fired when the button is pushed down by the mouse.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Controls.BaseButton.OnButtonUp">
            <summary>
                Fired when the button is released by the mouse.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Controls.BaseButton.OnPressed">
            <summary>
                Fired when the button is "pressed". When this happens depends on <see cref="P:Robust.Client.UserInterface.Controls.BaseButton.Mode"/>.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Controls.BaseButton.OnToggled">
            <summary>
                If <see cref="P:Robust.Client.UserInterface.Controls.BaseButton.ToggleMode"/> is set, fired when the button is toggled up or down.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BaseButton.ButtonEventArgs.Button">
            <summary>
                The button this event originated from.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.BaseButton.ButtonToggledEventArgs">
            <summary>
                Fired when a <see cref="T:Robust.Client.UserInterface.Controls.BaseButton"/> is toggled.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BaseButton.ButtonToggledEventArgs.Pressed">
            <summary>
                The new pressed state of the button.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.BaseButton.ActionMode">
            <summary>
                For use with <see cref="P:Robust.Client.UserInterface.Controls.BaseButton.Mode"/>.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.BaseButton.ActionMode.Press">
            <summary>
                <see cref="E:Robust.Client.UserInterface.Controls.BaseButton.OnPressed"/> fires when the mouse button causing them is pressed down.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.BaseButton.ActionMode.Release">
            <summary>
                <see cref="E:Robust.Client.UserInterface.Controls.BaseButton.OnPressed"/> fires when the mouse button causing them is released.
                This is the default and most intuitive method.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.ButtonGroup">
            <summary>
                Represents a group of buttons.
            </summary>
            <remarks>
                Of all buttons in a group, only one can be pressed down.
                Yes, it's for radio buttons.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.ButtonGroup.IsNoneSetAllowed">
            <summary>
            Whether it is legal for this button group to have no selected button.
            </summary>
            <remarks>
            If true, it's legal for no button in the group to be active.
            This is then the initial state of a new group of buttons (no button is automatically selected),
            and it becomes legal to manually clear the active button through code.
            The user cannot manually unselect the active button regardless, only by selecting a difference button.
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.ButtonGroup.#ctor(System.Boolean)">
            <summary>
            Create a new <see cref="T:Robust.Client.UserInterface.Controls.ButtonGroup"/>
            </summary>
            <param name="isNoneSetAllowed">The value of <see cref="P:Robust.Client.UserInterface.Controls.ButtonGroup.IsNoneSetAllowed"/> on the new button group.</param>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.BoxContainer">
            <summary>
                A container that lays out its children sequentially.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.BoxContainer.Align">
            <summary>
            Specifies the alignment of the controls <b>along the orientation axis.</b>
            </summary>
            <remarks>
            This is along the orientation axis, not cross to it.
            This means that if your orientation is vertical and you set this to center,
            your controls will be laid out in the vertical <i>center</i> of the box control instead of the top.
            </remarks>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.BoxContainer.AlignMode.Begin">
            <summary>
                Controls are laid out from the begin of the box container.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.BoxContainer.AlignMode.Center">
            <summary>
                Controls are laid out from the center of the box container.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.BoxContainer.AlignMode.End">
            <summary>
                Controls are laid out from the end of the box container.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.BoxContainer.LayoutOrientation">
            <summary>
            Orientation for a box container.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.BoxContainer.LayoutOrientation.Horizontal">
            <summary>
            Controls are laid out horizontally, left to right.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.BoxContainer.LayoutOrientation.Vertical">
            <summary>
            Controls are laid out vertically, top to bottom.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.Button">
            <summary>
                Most common button type that draws text in a fancy box.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.Button.TextAlign">
            <summary>
                How to align the text inside the button.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.Button.ClipText">
            <summary>
                If true, the button will allow shrinking and clip text
                to prevent the text from going outside the bounds of the button.
                If false, the minimum size will always fit the contained text.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.Button.Text">
            <summary>
                The text displayed by the button.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.CenterContainer">
            <summary>
                Container type that centers its children inside itself.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.CheckBox">
            <summary>
                A type of toggleable button that also has a checkbox.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.CheckBox.LeftAlign">
            <summary>
            Should the checkbox be to the left or the right of the label.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.CheckBox.TextAlign">
            <summary>
                How to align the text inside the button.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.CheckBox.ClipText">
            <summary>
                If true, the button will allow shrinking and clip text
                to prevent the text from going outside the bounds of the button.
                If false, the minimum size will always fit the contained text.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.CheckBox.Text">
            <summary>
                The text displayed by the button.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.CollapsibleHeading.Label">
            <summary>
            Exposes the label for this heading.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.ColorSelectorStyleBox">
            <summary>
            Style box for colouring sliders and 2-d colour selectors. E.g., this could be used to draw the typical HSV colour
            selection rainbow.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.ColorSelectorStyleBox.BaseColor">
            <summary>
            Base background colour.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.ColorSelectorStyleBox.XAxis">
            <summary>
            Colour to add to the background colour along the X-axis.
            I.e., from left to right the background colour will vary from (BaseColour) to (BaseColour + XAxis)
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.ColorSelectorStyleBox.YAxis">
            <summary>
            Colour to add to the background colour along the y-axis.
            I.e., from left to right the background colour will vary from (BaseColour) to (BaseColour + XAxis)
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.ColorSelectorStyleBox.Hsv">
            <summary>
            If true, then <see cref="F:Robust.Client.UserInterface.Controls.ColorSelectorStyleBox.BaseColor"/>, <see cref="F:Robust.Client.UserInterface.Controls.ColorSelectorStyleBox.XAxis"/>, and <see cref="F:Robust.Client.UserInterface.Controls.ColorSelectorStyleBox.YAxis"/> will be interpreted as HSVa
            colours.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.ColorSelectorStyleBox.SetBaseColor(Robust.Shared.Maths.Color)">
            <summary>
            Helper method that sets the base color by taking in some color and removing the components that are controlled by the x and y axes.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.ColorSelectorStyleBox.SetBaseColor(Robust.Shared.Maths.Vector4)">
            <summary>
            Helper method that sets the base color by taking in some color and removing the components that are controlled by the x and y axes.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.Container">
            <summary>
                A container lays out its children by some implementation-dependent rules.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.FloatSpinBox">
            <summary>
             Number input LineEdit with increment buttons.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.FloatSpinBox.IsValid">
            <summary>
                Determines whether the SpinBox value gets changed by the input text.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.GridContainer">
            <summary>
                A container that lays out its children in a grid. Can define specific count of
                rows or specific count of columns (not both), and will grow to fill in additional rows/columns within
                that limit. Alternatively, can define a maximum width or height, and grid will
                lay out elements (aligned in a grid pattern, not floated) within the defined limit.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.GridContainer.LimitedDimension">
            <summary>
            Indicates whether row or column count has been specified, and thus
            how items will fill them out as they are added.
            This is set depending on whether you have specified Columns or Rows.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.GridContainer.UnlimitedDimension">
            <summary>
            Opposite dimension of LimitedDimension
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.GridContainer.LimitType">
            <summary>
            Indicates whether we are limiting based on an explicit number of rows or columns, or limiting
            based on a defined max width or height.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.GridContainer.ExpandBackwards">
            <summary>
            The "normal" direction of expansion when the defined row or column limit is met
            is right (for row-limited) and down (for column-limited),
            this inverts that so the container expands in the opposite direction as elements are added.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.GridContainer.Columns">
            <summary>
                The number of columns to organize the children into. Setting this puts this grid
                into LimitMode.LimitColumns and LimitType.Count - items will be added to fill up the entire row, up to the defined
                limit of columns, and then create a second row.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
                Thrown if the value assigned is less than or equal to 0.
            </exception>
            <returns>specified limit if LimitMode.LimitColums, otherwise the number
            of columns being used for the current amount of children.</returns>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.GridContainer.Rows">
            <summary>
                The number of rows to organize the children into. Setting this puts this grid
                into LimitMode.LimitRows and LimitType.Count - items will be added to fill up the entire column, up to the defined
                limit of rows, and then create a second column.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
                Thrown if the value assigned is less than or equal to 0.
            </exception>
            <returns>specified limit if LimitMode.LimitRows, otherwise the number
            of rows being used for the current number of children.</returns>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.GridContainer.MaxGridWidth">
             <summary>
                 The max width (in virtual pixels) the grid of elements can have. This dynamically determines
                 the number of columns based on the size of the elements. Setting this puts this grid
                 into LimitMode.LimitColumns and LimitType.Size. Items will be added to fill up the entire row, up to the defined
                 width, and then create a second row.
            
                 In the presence of unevenly-sized children,
                 rows will still have the same amount elements - the items are laid out in a grid pattern such
                 that they are all aligned, the height and width of each "cell" being determined by
                 the greatest min height and min width among the elements. In the presence of expanding elements,
                 their pre-expanded size will be used to determine the cell layout, then the elements expand within
                 the defined Control.Size
             </summary>
             <exception cref="T:System.ArgumentOutOfRangeException">
                 Thrown if the value assigned is less than or equal to 0.
             </exception>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.GridContainer.MaxGridHeight">
             <summary>
                 The max height (in virtual pixels) the grid  of elements can have. This dynamically determines
                 the number of rows based on the size of the elements. Setting this puts this grid
                 into LimitMode.LimitRows and LimitType.Size - items will be added to fill up the entire column, up to the defined
                 height, and then create a second column.
            
                 In the presence of unevenly-sized children,
                 columns will still have the same amount elements - the items are laid out in a grid pattern such
                 that they are all aligned, the height and width of each "cell" being determined by
                 the greatest min height and min width among the elements. In the presence of expanding elements,
                 their pre-expanded size will be used to determine the layout, then the elements expand within
                 the defined Control.Size
             </summary>
             <exception cref="T:System.ArgumentOutOfRangeException">
                 Thrown if the value assigned is less than or equal to 0.
             </exception>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.GridContainer.CalculateLimitedCount">
            <summary>
            If columns (or width) are being limited, calculates how many columns
            there should be.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.GridContainer.CellSize">
            <summary>
            Calculates the size of a "cell" in physical pixels, for use in LimitType.Size mode. This
            is based on the maximum minheight / minwidth of each element.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LimitType.Count">
            <summary>
            Defined number of rows or columns
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LimitType.Size">
            <summary>
            Defined max width or height, inside of which the number of rows or columns
            will be fit.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.HistoryLineEdit.InvokeOnHistorySelect">
            <summary>
                If true, this will cause <see cref="E:Robust.Client.UserInterface.Controls.LineEdit.OnTextChanged"/> to be invoked when the history
                selection changes.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.ItemList._totalContentHeight">
            The size of all the child widgets, in pixels
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.ItemList.ItemSeparation">
            <summary>
            Gets or sets the ItemSeparation of individual list items
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.ItemList.ItemListEventArgs.ItemList">
            <summary>
                The ItemList this event originated from.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.ItemList.ItemListSelectedEventArgs.ItemIndex">
            <summary>
                The index of the item that was selected.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.ItemList.ItemListDeselectedEventArgs.ItemIndex">
            <summary>
                The index of the item that was selected.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.ItemList.ItemListHoverEventArgs.ItemIndex">
            <summary>
                The index of the item that was selected.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.Label">
            <summary>
                A label is a GUI control that displays simple text.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.Label.Text">
            <summary>
                The text to display.
            </summary>
            <remarks>
            Replaces <see cref="P:Robust.Client.UserInterface.Controls.Label.TextMemory"/> when set.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thrown if <see cref="P:Robust.Client.UserInterface.Controls.Label.TextMemory"/> was set directly and there is no backing string instance to fetch.
            </exception>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.Label.TextMemory">
            <summary>
            The text to display, set as a read-only memory.
            </summary>
            <remarks>
            <para>
            Note that updating the backing memory while the control is using it can result in incorrect display due to caching of measure information and similar.
            If you modify the backing storage, re-assign the property to invalidate these.
            </para>
            <para>
            Sets <see cref="P:Robust.Client.UserInterface.Controls.Label.Text"/> to throw an exception if read, as there is no backing string to retrieve.
            </para>
            </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.LayeredTextureRect">
            <summary>
                Like a TextureRect... but layered
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.LayeredTextureRect.Textures">
            <summary>
                The textures to draw.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.LayeredTextureRect.TextureScale">
            <summary>
                Scales the texture displayed.
            </summary>
            <remarks>
                This does not apply to the following stretch modes: <see cref="!:StretchMode.Scale"/>.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.LayeredTextureRect.CanShrink">
            <summary>
                If true, this control can shrink below the size of <see cref="T:Robust.Client.Graphics.Texture"/>.
            </summary>
            <remarks>
                This does not set <see cref="P:Robust.Client.UserInterface.Control.RectClipContent"/>.
                Certain stretch modes may display outside the area of the control unless it is set.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.LayeredTextureRect.Stretch">
            <summary>
                Controls how the texture should be drawn if the control is larger than the size of the texture.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LayoutContainer.AnchorBegin">
            <summary>
                The value of an anchor that is exactly on the begin of the parent control.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LayoutContainer.AnchorEnd">
            <summary>
                The value of an anchor that is exactly on the end of the parent control.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.LayoutContainer.InheritChildMeasure">
            <summary>
            If true, measurements of this control will be at least the size of any contained controls.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Client.UserInterface.Controls.LayoutContainer.SetAnchorAndMarginPreset(Robust.Client.UserInterface.Control,Robust.Client.UserInterface.Controls.LayoutContainer.LayoutPreset,Robust.Client.UserInterface.Controls.LayoutContainer.LayoutPresetMode,System.Int32)" -->
        <member name="M:Robust.Client.UserInterface.Controls.LayoutContainer.SetAnchorPreset(Robust.Client.UserInterface.Control,Robust.Client.UserInterface.Controls.LayoutContainer.LayoutPreset,System.Boolean)">
            <summary>
                Changes all the anchors of a node at once to common presets.
                The result is that the anchors are laid out to be suitable for a preset.
            </summary>
            <param name="preset">
                The preset to apply to the anchors.
            </param>
            <param name="keepMargin">
                If this is true, the control margin values themselves will not be changed,
                and the control position and size will change according to the new anchor parameters.
                If false, the control margins will adjust so that the control position and size remains the same relative to its parent.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                Thrown if <paramref name="preset" /> isn't a valid preset value.
            </exception>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.LayoutContainer.SetMarginsPreset(Robust.Client.UserInterface.Control,Robust.Client.UserInterface.Controls.LayoutContainer.LayoutPreset,Robust.Client.UserInterface.Controls.LayoutContainer.LayoutPresetMode,System.Int32)">
             <summary>
                 Changes all the margins of a control at once to common presets.
                 The result is that the control is laid out as specified by the preset.
            
                 Note that the current size and minimum size of the control affects how
                 each of the margins will be set, so if your control needs to shrink beyond its
                 current size / min size, you should either not call this method or only call it when your
                 control has a size of (0, 0). Otherwise your control's size will never be able
                 to go below the size implied by the margins set in this method.
             </summary>
             <param name="preset"></param>
             <param name="resizeMode"></param>
             <param name="margin">Some extra margin to add depending on the preset chosen.</param>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.LayoutContainer.GrowDirection">
            <summary>
                Controls how the control should move when its wanted size (controlled by anchors/margins) is smaller
                than its minimum size.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LayoutContainer.GrowDirection.End">
            <summary>
                The control will expand to the bottom right to reach its minimum size.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LayoutContainer.GrowDirection.Begin">
            <summary>
                The control will expand to the top left to reach its minimum size.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LayoutContainer.GrowDirection.Both">
            <summary>
                The control will expand on all axes equally to reach its minimum size.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LayoutContainer.GrowDirection.Constrain">
            <summary>
                The control will not be allowed to grow on this axis.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.LayoutContainer.LayoutPresetMode">
            <seealso cref="!:Control.SetMarginsPreset" />
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LayoutContainer.LayoutPresetMode.MinSize">
            <summary>
                Reset control size to minimum size.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LayoutContainer.LayoutPresetMode.KeepWidth">
            <summary>
                Reset height to minimum but keep width the same.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LayoutContainer.LayoutPresetMode.KeepHeight">
            <summary>
                Reset width to minimum but keep height the same.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.LayoutContainer.LayoutPresetMode.KeepSize">
            <summary>
                Do not modify control size at all.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.LineEdit">
            <summary>
                Allows the user to input and modify a line of text.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.LineEdit.IsValid">
            <summary>
                Determines whether the LineEdit text gets changed by the input text.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.LineEdit.Text">
            <summary>
                The actual text currently stored in the LineEdit. Setting this does not invoke the text change event, use <see cref="M:Robust.Client.UserInterface.Controls.LineEdit.SetText(System.String,System.Boolean)"/> for that.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.LineEdit.SetText(System.String,System.Boolean)">
            <summary>
                Sets the current text, optionally invoking <see cref="E:Robust.Client.UserInterface.Controls.LineEdit.OnTextChanged"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.LineEdit.SelectedText">
            <summary>
                The text
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.LineEdit.InternalSetText(System.String)">
            <remarks>
            Does not fix cursor positions, those will have to be adjusted manually.
            </remarks>>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.LineEdit.GetOffsetAtIndex(System.Int32)">
            <summary>
            Get offset from the left of the control
            to the left edge of the text glyph at the specified index in the text.
            </summary>
            <remarks>
            The returned value can be outside the bounds of the control if the glyph is currently clipped off.
            </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.LineEdit.LineEditRenderBox">
            <summary>
                Use a separate control to do the rendering to make use of RectClipContent,
                so that we can clip characters in half.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.MenuBar">
            <summary>
                A good simple menu bar control, like the one at the top of your IDE!
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.MenuBar.MenuEntry">
            <summary>
                An entry in a menu of a menu bar.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.MenuBar.Menu">
            <summary>
                A menu in a menu bar, like file...
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.MenuBar.MenuButton">
            <summary>
                A basic button entry in a menu bar menu.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.MultiselectOptionButton`1">
            <summary>
            Option button which allows toggling multiple elements.
            </summary>
            <typeparam name="TKey">type to use as the unique key for each option. Functions similarly
            to dictionary key, so the type should make sure to respect dictionary key semantics.</typeparam>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.MultiselectOptionButton`1._selectedKeys">
            <summary>
            Tracks the order in which items were selected, latest going at the end.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.MultiselectOptionButton`1.SelectedKeys">
            <summary>
            Ids of all currently selected items, ordered by most recently selected = last
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.MultiselectOptionButton`1.SelectedLabels">
            <summary>
            Labels of all currently selected items, ordered by most recently selected = last
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.MultiselectOptionButton`1.SelectedMetadata">
            <summary>
            Metadata of all currently selected items, ordered by most recently selected = last
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.MultiselectOptionButton`1.ItemPressedEventArgs.Selected">
            <summary>
            True if item is being selected, false if being unselected
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.MultiselectOptionButton`1.ItemPressedEventArgs.Deselected">
            <summary>
            True if item is being deselected, false if being selected
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.MultiselectOptionButton`1.ItemPressedEventArgs.Key">
            <summary>
            The key of the item that has been selected or deselected.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.OptionButton.HideTriangle">
            <summary>
            If true, hides the triangle that normally appears to the right of the button label
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.OptionButton.OptionStyleClasses">
            <summary>
            StyleClasses to apply to the options that popup when clicking this button.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.OptionButton.Select(System.Int32)">
            <summary>
            Select by index rather than id. Throws exception if item with that index
            not in this control.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.OptionButton.TrySelect(System.Int32)">
            <summary>
            Select by index rather than id.
            </summary>
            <returns>false if item with that index not in this control</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.OptionButton.SelectId(System.Int32)">
            throws exception if item with this ID is not in this control
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.OptionButton.TrySelectId(System.Int32)">
            <returns>false if item with id not in this control</returns>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.OptionButton.ItemSelectedEventArgs.Id">
            <summary>
                The ID of the item that has been selected.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.OSWindow">
            <summary>
            Represents an operating system-based UI window.
            </summary>
            <seealso cref="T:Robust.Client.UserInterface.CustomControls.BaseWindow"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.OSWindow.ClydeWindow">
            <summary>
            The window instance backing this window instance.
            Not guaranteed to be available unless the window is currently open.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.OSWindow.Owner">
            <summary>
            The window that will "own" this window.
            Owned windows always appear on top of their owners and have some other misc behavior depending on the OS.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.OSWindow.IsOpen">
            <summary>
            Whether the window is currently open.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.OSWindow.Title">
            <summary>
            The title of the window.
            </summary>
            <remarks>
            Can be changed while the window is open.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.OSWindow.StartupLocation">
            <summary>
            The location to place the window at when it is opened.
            </summary>
            <remarks>
            Changing this while the window is open has no effect.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.OSWindow.SizeToContent">
            <summary>
            Controls whether to automatically size one or both axis of the window to fit the content.
            </summary>
            <remarks>
            Changing this while the window is open has no effect.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.OSWindow.WindowStyles">
            <summary>
            Specifies window styling options for the window.
            </summary>
            <remarks>
            Changing this while the window is open has no effect.
            </remarks>
        </member>
        <member name="E:Robust.Client.UserInterface.Controls.OSWindow.Closing">
            <summary>
            Raised when the window is being closed
            (via calling <see cref="M:Robust.Client.UserInterface.Controls.OSWindow.Close"/> or the user clicking the close button).
            Can be cancelled.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Controls.OSWindow.Closed">
            <summary>
            Raised when the window has been closed.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.OSWindow.Show">
            <summary>
            Show the window to the user.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.OSWindow.Close">
            <summary>
            Try to close the window.
            </summary>
            <remarks>
            This can be cancelled by anything handling <see cref="E:Robust.Client.UserInterface.Controls.OSWindow.Closing"/>.
            </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.OutputPanel">
            <summary>
                A control to handle output of message-by-message output panels, like the debug console and chat panel.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Controls.Popup.OnPopupOpen">
            <summary>
                Action that gets invoked just before the pop-up gets shown. This does not get invoked if the pop-up is
                moved / re-opened in another location.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Controls.Popup.OnPopupHide">
            <summary>
                Action that gets invoked just after a pop-up becomes invisible. This does not get invoked if the pop-up
                is moved / re-opened in another location.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.PopupContainer">
            <summary>
                Container that tries to put controls at their specified origin,
                moving them around if necessary to avoid them going outside of the bounds of the container.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.PopupContainer.PopupOriginProperty">
            <summary>
                The origin that the container tries to place the child at.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.PopupContainer.AltOriginProperty">
            <summary>
                Alternative position to right-align the popup if <see cref="F:Robust.Client.UserInterface.Controls.PopupContainer.PopupOriginProperty"/>
                would put it off-screen horizontally.
            </summary>
            <remarks>
                You know how right click menus with sub menus put the submenu on the left
                if it's too close to the right of the screen? Yeah that.
            </remarks>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.RadioOptions`1.GenerateItem">
            <summary>
            Called when creating a Button Control for each radio item.
            The default creates a regular Button.
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.Controls.RadioOptions`1.OnItemSelected">
             <summary>
             Called whenever you select a button.
            
             Note: You should add optionButtons.Select(args.Id); if you want to actually select the button.
             </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.RadioOptions`1.ButtonOnPressed(Robust.Client.UserInterface.Controls.BaseButton.ButtonEventArgs)">
            <summary>
            This is triggered when the button is pressed via the UI
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.RadioOptions`1.IsItemDisabled(System.Int32)">
            <summary>
            Always will return true if itemId is not found.
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.RadioOptionItemSelectedEventArgs`1.Id">
            <summary>
                The ID of the item that has been selected.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.ScrollContainer.FallbackDeltaScroll">
            <summary>
            If true then if we have a y-axis scroll it will convert it to an x-axis scroll.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.Slider.Disabled">
            <summary>
            Whether the slider can be adjusted.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.SpinBox">
            <summary>
                Number input LineEdit with increment buttons.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SpinBox.IsValid">
            <summary>
                Determines whether the SpinBox value gets changed by the input text.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.SpinBox.OverrideValue(System.Int32)">
            <summary>
            Overrides the value of the spinbox without calling the event.
            Still applies validity-checks
            </summary>
            <param name="value">the new value</param>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.SpinBox.InitDefaultButtons">
            <summary>
                Creates and sets buttons to - and +.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.SpinBox.AddRightButton(System.Int32,System.String)">
            <summary>
                Adds a button to the right of the SpinBox LineEdit.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.SpinBox.AddLeftButton(System.Int32,System.String)">
            <summary>
                Adds a button to the left of the SpinBox LineEdit.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.SpinBox.SetButtons(System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32})">
            <summary>
                Creates and sets buttons for each int in leftButtons and rightButtons.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SpinBox.LineEditDisabled">
            <summary>
            Changes the editability of the lineedit-field
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.SpinBox.SetButtonDisabled(System.Boolean)">
            <summary>
            Changes the editability of the buttons
            </summary>
            <param name="disabled"></param>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.SpinBox.ClearButtons">
            <summary>
                Removes all buttons inside the SpinBox.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SplitContainer.ResizeMode">
            <summary>
            Defines how user-initiated moving of the split should work. See documentation
            for each enum value to see how the different options work.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SplitContainer.SplitWidth">
            <summary>
            Width of the split in virtual pixels
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SplitContainer.MinDraggableWidth">
            <summary>
                This width determines the minimum size of the draggable area around the split. This has no effect if it
                is smaller than <see cref="P:Robust.Client.UserInterface.Controls.SplitContainer.SplitWidth"/>, which determines the visual padding/width.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SplitContainer.SplitEdgeSeparation">
            <summary>
            Virtual pixel offset from the edge beyond which the split cannot be moved.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SplitContainer.SplitCenter">
            <summary>
            Virtual pixel offset from the center of the split.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SplitContainer.SplitFraction">
            <summary>
            Virtual pixel fraction of the split.
            </summary>
            <value>Takes a float from 0 to 1.</value>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SplitContainer.First">
            <summary>
            The upper/left control in the split container.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SplitContainer.Second">
            <summary>
            The lower/right control in the split container.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SplitContainer.State">
            <summary>
            Whether the split position should be set manually or automatically.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SplitContainer.StretchDirection">
            <summary>
            Determines which side of the split expands when the parent is resized.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SplitContainer.Orientation">
            <summary>
            Whether the split is horizontal or vertical.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.SplitContainer.Flip">
            <summary>
            Swaps the position of the first and zeroeth children; for a 2-control viewport it effectively flips them.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.SplitContainer.ClampSplitCenter(System.Nullable{System.Numerics.Vector2},System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Ensures the split center is within all necessary limits
            </summary>
            <param name="firstMinSize">min size of the first child, will calculate if null</param>
            <param name="secondMinSize">min size of the second child, will calculate if null</param>
            <returns></returns>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.SplitContainer.SplitResizeMode">
            <summary>
            Defines how user-initiated moving of the split should work
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SplitContainer.SplitResizeMode.NotResizable">
            <summary>
            Don't allow user to move the split.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SplitContainer.SplitResizeMode.RespectChildrenMinSize">
             <summary>
             User can resize the split but can't shrink either child
             beyond its minimum size.
            
             This ensures that no child ends up with its content outside the
             edges of its container.
             </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.SplitContainer.SplitState">
            <summary>
            Defines how the split position should be determined
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SplitContainer.SplitState.Auto">
            <summary>
            Automatically adjust the split based on the width of the children
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SplitContainer.SplitState.Manual">
            <summary>
            Manually adjust the split by dragging it
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.SplitContainer.SplitStretchDirection">
            <summary>
            Specifies horizontal alignment modes.
            </summary>
            <seealso cref="P:Robust.Client.UserInterface.Control.HorizontalAlignment"/>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SplitContainer.SplitStretchDirection.BottomRight">
            <summary>
            The control should stretch the the control on the bottom or the right.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SplitContainer.SplitStretchDirection.TopLeft">
            <summary>
            The control should stretch the the control on the top or the left.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.SplitContainer.SplitDragControl">
            <summary>
            Simple control to intercept mous events and redirect them to the parent.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SpriteView.Stretch">
            <summary>
            This field configures automatic scaling of the sprite. This automatic scaling is done before
            applying the explicitly set scale <see cref="P:Robust.Client.UserInterface.Controls.SpriteView.Scale"/>.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SpriteView.StretchMode.None">
            <summary>
            Don't automatically scale the sprite. The sprite can still be scaled via <see cref="P:Robust.Client.UserInterface.Controls.SpriteView.Scale"/>
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SpriteView.StretchMode.Fit">
            <summary>
            Scales the sprite down so that it fits within the control. Does not scale the sprite up. Keeps the same
            aspect ratio. This automatic scaling is done before applying <see cref="P:Robust.Client.UserInterface.Controls.SpriteView.Scale"/>.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SpriteView.StretchMode.Fill">
            <summary>
            Scale the sprite up or down so that it fills the whole control. Keeps the same aspect ratio. This
            automatic scaling is done before applying <see cref="P:Robust.Client.UserInterface.Controls.SpriteView.Scale"/>.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SpriteView.OverrideDirection">
            <summary>
            Overrides the direction used to render the sprite.
            </summary>
            <remarks>
            If null, the world space orientation of the entity will be used. Otherwise the specified direction will be
            used.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SpriteView.WorldRotation">
            <summary>
            Used to override the entity's world rotation. Note that the desired size of the control will not
            automatically get updated as the entity's world rotation changes.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SpriteView.Scale">
            <summary>
            Scale to apply when rendering the sprite. This is separate from the sprite's scale.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.SpriteView._spriteSize">
            <summary>
            Cached desired size. Differs from <see cref="P:Robust.Client.UserInterface.Control.DesiredSize"/> as it it is not clamped by the
            minimum/maximum size options.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.SpriteView.SpriteOffset">
            <summary>
            Determines whether or not the sprite's offset be applied to the control.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.TextEdit">
            <summary>
            A multi-line text editing control.
            </summary>
            <remarks>
            <para>
            This control uses a <see cref="T:Robust.Shared.Utility.Rope"/> to performantly manipulate editable text.
            </para>
            <para>
            Text selection and cursor positions are tracked with two values: a "selection start" and a "cursor position".
            When you do not have a selection (i.e. just a lone cursor) these values are at the same position.
            If you have an active selection, the cursor position is the part of the selection you can move around
            (via mouse or shift+left/right), while the start is the part that stays in place always.
            </para>
            <para>
            Positions inside this control are all in chars.
            Cursor positions and such should never be inside a surrogate pair, however.
            </para>
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextEdit.CursorPosition">
            <summary>
            The current position of the cursor in the text rope.
            </summary>
            <remarks>
            See the class remarks for how text selection works in this control.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown if the given position would put the cursor inside a surrogate pair.
            </exception>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextEdit.SelectionStart">
            <summary>
            The start position of the selection in the text rope.
            </summary>
            <remarks>
            See the class remarks for how text selection works in this control.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown if the given position would put the cursor inside a surrogate pair.
            </exception>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextEdit.TextRope">
            <summary>
            The text rope that can be viewed and edited.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextEdit.Editable">
            <summary>
            True to allow editing by the user. False to make it read-only.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextEdit.SelectionLower">
            <summary>
            The lower (in string index terms) end of the active text selection.
            </summary>
            <remarks>
            Confusingly, because text is read top-to-bottom, "lower" is actually higher up on your monitor.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextEdit.SelectionUpper">
            <summary>
            The upper (in string index terms) end of the active text selection.
            </summary>
            <remarks>
            Confusingly, because text is read top-to-bottom, "upper" is actually lower down on your monitor.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextEdit.SelectionLength">
            <summary>
            The amount of chars selected by the active selection.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextEdit.Placeholder">
            <summary>
            A placeholder text to be displayed when no actual text is entered.
            </summary>
            <remarks>
            <para>
            This isn't editable by the user, but to make the internals simpler, it is still exposed as a rope.
            </para>
            <para>
            When set to null, the placeholder style pseudo-class will not be applied when the actual text content is empty.
            If set to an empty text rope this does happen, but obviously no text is displayed either way.
            </para>
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.TextEdit.CalcCursorMove(Robust.Client.UserInterface.Controls.TextEdit.MoveType,System.Boolean,System.Boolean@)">
            <summary>
            Calculate the position the cursor should move to with a certain move.
            </summary>
            <remarks>
            This method is not pure: while it does not modify the actual cursor position yet,
            only calculating the next position, it still calls <c>CacheHorizontalCursorPos</c> manually.
            </remarks>
            <param name="type">The type of move the cursor is doing.</param>
            <param name="select">Whether a selection is being expanded.</param>
            <param name="keepHorizontalCursorPos">
            Whether the cached horizontal cursor position must be kept instead of being invalidates.
            </param>
            <returns>The new position of the cursor in the text.</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.TextEdit.GetDisplayRope">
            <summary>
            Get the rope of text actually being displayed. This may be the placeholder.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.TextEdit.RenderBox">
            <summary>
            Sub-control responsible for doing the actual rendering work.
            </summary>
            <remarks>
            This is a sub-control to use <see cref="P:Robust.Client.UserInterface.Control.RectClipContent"/>.
            </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.TextEdit.LineBreakBias">
            <summary>
            Specifies which line the cursor is positioned at when on a word-wrapping break.
            </summary>
            <remarks>
            <para>
            When words get pushed to a new line due to word-wrapping, a line break is tracked.
            For various reasons, people want to be able to place their cursor on both the end of the "top" line,
            as well as the start of the "bottom" line. These are however the same position in the source text,
            going by raw string indices at least. To allow the code to differentiate between these two positions,
            this bias value is tracked in all cursor positions.
            </para>
            <para>
            This is only for word-wrapping line breaks however. For explicit line breaks created with a newline character,
            the cursor bias should always be "top" so that everything works correctly.
            </para>
            </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.TextEdit.CursorPos">
            <summary>
            Stores the necessary data for a position in the cursor of the text.
            </summary>
            <param name="Index">The index of the cursor in the text contents.</param>
            <param name="Bias">Which direction to bias the cursor to </param>
        </member>
        <member name="M:Robust.Client.UserInterface.Controls.TextEdit.CursorPos.#ctor(System.Int32,Robust.Client.UserInterface.Controls.TextEdit.LineBreakBias)">
            <summary>
            Stores the necessary data for a position in the cursor of the text.
            </summary>
            <param name="Index">The index of the cursor in the text contents.</param>
            <param name="Bias">Which direction to bias the cursor to </param>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextEdit.CursorPos.Index">
            <summary>The index of the cursor in the text contents.</summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextEdit.CursorPos.Bias">
            <summary>Which direction to bias the cursor to </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.TextEditShared">
            <summary>
            Shared logic between <see cref="T:Robust.Client.UserInterface.Controls.TextEdit"/> and <see cref="T:Robust.Client.UserInterface.Controls.LineEdit"/>
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.TextEditShared.CursorBlink">
            <summary>
            Helper type for the cursor blink animation.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.TextEditShared.CursorBlink.BlinkTime">
            <summary>
            The total length of the animation.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Controls.TextureRect">
            <summary>
                Simple control that draws a single texture using a variety of possible stretching modes.
            </summary>
            <seealso cref="T:Robust.Client.UserInterface.Controls.AnimatedTextureRect"/>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextureRect.Texture">
            <summary>
                The texture to draw.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextureRect.TextureScale">
            <summary>
                Scales the texture displayed.
            </summary>
            <remarks>
                This does not apply to the following stretch modes: <see cref="F:Robust.Client.UserInterface.Controls.TextureRect.StretchMode.Scale"/>.
                This additionally does not apply if a size target is set.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextureRect.CanShrink">
            <summary>
                If true, this control can shrink below the size of <see cref="P:Robust.Client.UserInterface.Controls.TextureRect.Texture"/>.
            </summary>
            <remarks>
                This does not set <see cref="P:Robust.Client.UserInterface.Control.RectClipContent"/>.
                Certain stretch modes may display outside the area of the control unless it is set.
            </remarks>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.TextureRect.Stretch">
            <summary>
                Controls how the texture should be drawn if the control is larger than the size of the texture.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.TextureRect.StretchMode.Scale">
            <summary>
                The texture is stretched to fit the entire area of the control.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.TextureRect.StretchMode.Tile">
            <summary>
                The texture is tiled to fit the entire area of the control, without stretching.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.TextureRect.StretchMode.Keep">
            <summary>
                The texture is drawn in its correct size, in the top left corner of the control.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.TextureRect.StretchMode.KeepCentered">
            <summary>
                The texture is drawn in its correct size, in the center of the control.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.TextureRect.StretchMode.KeepAspect">
            <summary>
                The texture is stretched to take as much space as possible,
                while maintaining the original aspect ratio.
                The texture is positioned from the top left corner of the control.
                The texture remains completely visible, potentially leaving some sections of the control blank.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.TextureRect.StretchMode.KeepAspectCentered">
            <summary>
                <see cref="F:Robust.Client.UserInterface.Controls.TextureRect.StretchMode.KeepAspect"/>, but the texture is centered instead.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.Controls.TextureRect.StretchMode.KeepAspectCovered">
            <summary>
                <see cref="F:Robust.Client.UserInterface.Controls.TextureRect.StretchMode.KeepAspectCentered"/>, but the texture covers the entire control,
                potentially cutting out part of the texture.
            </summary>
            <example>
                This effectively causes the entire control to be filled with the texture,
                while preserving aspect ratio.
            </example>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.WindowRoot.UIScaleUpdateNeeded">
            <summary>
            Set after the window is resized, to batch up UI scale updates on window resizes.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.Controls.WindowRoot.DisableAutoScaling">
            <summary>
            Disable automatic scaling of window <see cref="P:Robust.Client.UserInterface.Controls.WindowRoot.UIScale"/> based on resolution.
            </summary>
            <remarks>
            <para>
            Disabled by default for non-main windows as those most likely are smaller popup windows,
            that won't make sense with the default parameters.
            </para>
            </remarks>
            <seealso cref="F:Robust.Shared.CVars.ResAutoScaleEnabled"/>
        </member>
        <member name="T:Robust.Client.UserInterface.CustomControls.BaseWindow">
            <summary>
                Provides basic functionality for windows that can be opened, dragged around, etc...
            </summary>
        </member>
        <member name="E:Robust.Client.UserInterface.CustomControls.BaseWindow.OnClose">
            <summary>
                Invoked when the close button of this window is pressed.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.BaseWindow.OpenScreenAt(System.Numerics.Vector2,Robust.Client.Graphics.IClyde)">
            <summary>
            Opens a window and centers it relative to the screen position.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.BaseWindow.OpenCenteredAt(System.Numerics.Vector2)">
            <summary>
                Opens a window, attempting to place the center of the window at some relative point on the screen.
            </summary>
            <param name="relativePosition">Fractional screen position. So (0,0) is the upper left, and (1,1) is the
            lower right.</param>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.BaseWindow.RecenterWindow(System.Numerics.Vector2)">
            <summary>
                Repositions a window, attempting to place the center of the window at some relative point on the screen.
            </summary>
            <param name="relativePosition">Fractional screen position. So (0,0) is the upper left, and (1,1) is the
            lower right.</param>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.IDebugConsoleView.AddLine(Robust.Shared.Utility.FormattedMessage,Robust.Shared.Maths.Color)">
            <summary>
            Write a line with a specific color to the console window.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.CustomControls.DefaultWindow">
            <summary>
            Simple window implementation that can be resized and has a title bar.
            </summary>
            <remarks>
            Warning: ugly.
            </remarks>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.DefaultWindow.WindowEdgeSeparation">
            <summary>
                This ensures that windows are always visible on screen and don't become unreachable. This only applies
                if the window is allowed to be partially off-screen.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.DefaultWindow.WindowEdgeBump">
            <summary>
                If a window is completely off-screen, the window will be bumped away from the edge so that its not a
                tiny square hidden in a corner. Effectively a conditional increase to <see cref="F:Robust.Client.UserInterface.CustomControls.DefaultWindow.WindowEdgeSeparation"/>.
                Helpful when changing UI scale or changing the window size.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.DefaultWindow.AllowOffScreen">
            <summary>
                This option determines whether a window is allowed to be dragged off the edge of the screen (as long as
                part of it remains visible).
            </summary>
            <remarks>
                Note that you generally want to disable north, as that will mean the header might not be visible, which
                might render the window unmovable.
            </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.CustomControls.DropDownDebugConsole">
            <summary>
                The default debug console that drops down from the top of the screen.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.FrameGraph.TrackedFrames">
            <summary>
                How many frames we show at once.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.FrameGraph.FrameWidth">
            <summary>
                The width of a single frame on the bar chart, in pixels.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.FrameGraph.FrameHeight">
            <summary>
                The height of a single frame in pixels to the target <see cref="!:TargetFrameRate"/> FPS.
                If the frame takes say 1/30 seconds to complete (30 FPS) it would be twice this value.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.CustomControls.IViewportControl">
            <summary>
                Base interface for controls that display a viewport.
            </summary>
            <remarks>
                This has to be implemented for correct handling of input,
                you do not strictly need to implement this otherwise.
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.IViewportControl.ScreenToMap(System.Numerics.Vector2)">
            <summary>
                Converts a point on the screen to map coordinates.
            </summary>
            <param name="coords">
                The coordinates, in ABSOLUTE SCREEN PIXEL COORDINATES. NOT CONTROL-RELATIVE COORDINATES.
            </param>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.IViewportControl.PixelToMap(System.Numerics.Vector2)">
            <summary>
            Similar to <see cref="M:Robust.Client.UserInterface.CustomControls.IViewportControl.ScreenToMap(System.Numerics.Vector2)"/>, except it should compensate for the effects of shaders on viewports.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.IViewportControl.WorldToScreen(System.Numerics.Vector2)">
            <summary>
                Converts a point on the map to screen coordinates.
            </summary>
            <returns>
                The coordinates, in ABSOLUTE SCREEN PIXEL COORDINATES. NOT CONTROL-RELATIVE COORDINATES.
            </returns>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.IViewportControl.GetWorldToScreenMatrix">
            <summary>
                Returns a matrix that can be used to perform the <see cref="M:Robust.Client.UserInterface.CustomControls.IViewportControl.WorldToScreen(System.Numerics.Vector2)"/> transformations.
            </summary>
            <remarks>
                This is generally just be a combination of <see cref="M:Robust.Client.Graphics.IClydeViewport.GetWorldToLocalMatrix"/> and <see cref="M:Robust.Client.UserInterface.CustomControls.IViewportControl.GetLocalToScreenMatrix"/>
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.IViewportControl.GetLocalToScreenMatrix">
            <summary>
                Returns a matrix that can be used to transform from view-port local to screen coordinates.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.CustomControls.MainViewportContainer">
            <summary>
                A viewport container shows a viewport.
                This one is particularly gnarly because it has the code for the main viewport stuff.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.CustomControls.PixelToMapEvent">
            <summary>
            An event used to reverse distortion effects applied by shaders.
            Used to find the map position that visible pixels originate from so that severe distortion shaders do not make interaction nigh-impossible.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.PixelToMapEvent.#ctor(System.Numerics.Vector2,Robust.Client.UserInterface.CustomControls.IViewportControl,Robust.Client.Graphics.IClydeViewport)">
            <summary>
            An event used to reverse distortion effects applied by shaders.
            Used to find the map position that visible pixels originate from so that severe distortion shaders do not make interaction nigh-impossible.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.PixelToMapEvent.LocalPosition">
            <summary>
            The local position of the pixel within the <see cref="F:Robust.Client.UserInterface.CustomControls.PixelToMapEvent.Control"/> that we are trying to convert to a map position.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.PixelToMapEvent.VisiblePosition">
            <summary>
            The original (or WIP) location of the pixel within the <see cref="F:Robust.Client.UserInterface.CustomControls.PixelToMapEvent.Control"/> that we are trying to convert to a map position.
            Used as the output of the event.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.PixelToMapEvent.Control">
            <summary>
            The control the pixel we are considering is located within.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.PixelToMapEvent.Viewport">
            <summary>
            The viewport being displayed by the control we are considering.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.CustomControls.Tooltip.Tracking">
            <summary>
            Should we track the mouse cursor.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.CustomControls.ViewportContainer">
            <summary>
                A viewport container shows a viewport.
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.CustomControls.ViewportContainer.ViewportResolution">
            <summary>
                This controls the render target size, *as a fraction of the control size.*
                Combined with controlling the Eye, this allows downscaling the game.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.CustomControls.ViewportContainer.PixelToMap(System.Numerics.Vector2)">
            <inheritdoc/>
        </member>
        <member name="T:Robust.Client.UserInterface.DummyFileDialogManager">
            <summary>
                Treats ever file dialog operation as cancelled.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.IDebugMonitors">
            <summary>
            Manages the debug monitors overlay, AKA "F3 screen".
            </summary>
        </member>
        <member name="P:Robust.Client.UserInterface.IDebugMonitors.Visible">
            <summary>
            Whether debug monitors are currently visible.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.IDebugMonitors.ToggleMonitor(Robust.Client.UserInterface.DebugMonitor)">
            <summary>
            Toggle visibility of a specific debug monitor.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.IDebugMonitors.SetMonitor(Robust.Client.UserInterface.DebugMonitor,System.Boolean)">
            <summary>
            Set visibility of a specific debug monitor.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.DebugMonitor">
            <summary>
            Debug monitors available in the debug monitors overlay.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.IFileDialogManager">
            <summary>
                Manager for opening of file dialogs.
            </summary>
            <remarks>
                File dialogs are native to the OS being ran on.
                All operations are asynchronous to prevent locking up the main thread while the user makes his pick.
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.IFileDialogManager.OpenFile(Robust.Client.UserInterface.FileDialogFilters)">
            <summary>
                Open a file dialog used for opening a single file.
            </summary>
            <returns>
            The file stream for the file the user opened.
            <see langword="null" /> if the user cancelled the action.
            </returns>
        </member>
        <member name="M:Robust.Client.UserInterface.IFileDialogManager.SaveFile(Robust.Client.UserInterface.FileDialogFilters,System.Boolean)">
            <summary>
                Open a file dialog used for saving a single file.
            </summary>
            <returns>
            The file stream the user chose to save to, and whether the file already existed.
            Null if the user cancelled the action.
            </returns>
            <param name="truncate">Should we truncate an existing file to 0-size then write or append.</param>
        </member>
        <member name="T:Robust.Client.UserInterface.InterfaceTheme">
            <summary>
                Fallback theme system for GUI.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.IRawInputControl">
            <summary>
            Allows a control to listen for raw keyboard events. This allows bypassing the input binding system.
            </summary>
            <remarks>
            Raw key events are raised *after* keybindings and focusing has been calculated,
            but before key bind events are actually raised.
            This is necessary to allow UI system stuff to actually work correctly.
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.IRawInputControl.RawKeyEvent(Robust.Client.UserInterface.GuiRawKeyEvent@)">
            <param name="guiRawEvent"></param>
            <returns>If true: all further key bind events should be blocked.</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManagerInternal.HandleCanFocusDown(Robust.Shared.Map.ScreenCoordinates,System.Nullable{System.ValueTuple{Robust.Client.UserInterface.Control,Robust.Shared.Maths.Vector2i}}@)">
            <returns>True if a UI control was hit and the key event should not pass through past UI.</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManagerInternal.HideTooltipFor(Robust.Client.UserInterface.Control)">
            <summary>
            Hides the tooltip for the indicated control, if tooltip for that control is currently showing.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.IUserInterfaceManagerInternal.GetSuppliedTooltipFor(Robust.Client.UserInterface.Control)">
            <summary>
            If the control is currently showing a tooltip,
            gets the tooltip that was supplied via TooltipSupplier (null if tooltip
            was not supplied by tooltip supplier or tooltip is not showing for the control).
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.RichTextEntry">
            <summary>
                Used by <see cref="T:Robust.Client.UserInterface.Controls.OutputPanel"/> and <see cref="T:Robust.Client.UserInterface.Controls.RichTextLabel"/> to handle rich text layout.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.RichTextEntry.Height">
            <summary>
                The vertical size of this entry, in pixels.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.RichTextEntry.Width">
            <summary>
                The horizontal size of this entry, in pixels.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.RichTextEntry.LineBreaks">
            <summary>
                The combined text indices in the message's text tags to put line breaks.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.RichTextEntry.Update(Robust.Client.UserInterface.RichText.MarkupTagManager,Robust.Client.Graphics.Font,System.Single,System.Single,System.Single)">
            <summary>
                Recalculate line dimensions and where it has line breaks for word wrapping.
            </summary>
            <param name="defaultFont">The font being used for display.</param>
            <param name="maxSizeX">The maximum horizontal size of the container of this entry.</param>
            <param name="uiScale"></param>
            <param name="lineHeightScale"></param>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.BoldItalicTag.PushDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.BoldItalicTag.PopDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.BoldTag.PushDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.BoldTag.PopDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.BulletTag.TextBefore(Robust.Shared.Utility.MarkupNode)">
            <inheritdoc/>
        </member>
        <member name="T:Robust.Client.UserInterface.RichText.ColorTag">
            <summary>
            Colors the text inside its opening and closing nodes
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.ColorTag.PushDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.ColorTag.PopDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.CommandLinkTag.TryGetControl(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.Control@)">
            <inheritdoc/>
        </member>
        <member name="T:Robust.Client.UserInterface.RichText.FontTag">
            <summary>
            Applies the font provided as the tags parameter to the markup drawing context.
            Definitely not save for user supplied markup
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.FontTag.PushDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.FontTag.PopDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.FontTag.CreateFont(System.Collections.Generic.Stack{Robust.Client.Graphics.Font},Robust.Shared.Utility.MarkupNode,Robust.Client.ResourceManagement.IResourceCache,Robust.Shared.Prototypes.IPrototypeManager,System.String)">
            <summary>
            Creates the a vector font from the supplied font id.<br/>
            The size of the resulting font will be either the size supplied as a parameter to the tag, the previous font size or 12
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.HeadingTag.PushDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.HeadingTag.PopDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="P:Robust.Client.UserInterface.RichText.IMarkupTag.Name">
            <summary>
            The string used as the tags name when writing rich text
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.IMarkupTag.PushDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <summary>
            Called when an opening node for this tag is encountered.<br/>
            Used for pushing new values used for rendering text contained within this tag.<br/>
            Important: Push some kind of default value into the context or throw when missing a required parameter
            or attribute. The order in which state gets popped of the context breaks otherwise.
            </summary>
            <param name="node">The markup node containing the parameter and attributes</param>
            <param name="context">The context to push the state on</param>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.IMarkupTag.TextBefore(Robust.Shared.Utility.MarkupNode)">
            <summary>
            Called after <see cref="M:Robust.Client.UserInterface.RichText.IMarkupTag.PushDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)"/>.<br/>
            Supplies text to be rendered before this tags children.
            </summary>
            <param name="node">The markup node containing the parameter and attributes</param>
            <returns>The text that gets rendered</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.IMarkupTag.TextAfter(Robust.Shared.Utility.MarkupNode)">
            <summary>
            Called after <see cref="M:Robust.Client.UserInterface.RichText.IMarkupTag.TextBefore(Robust.Shared.Utility.MarkupNode)"/>, when encountering a closing node for this tag.<br/>
            Supplies text to be rendered after this controls children.
            </summary>
            <param name="node">The markup node containing the parameter and attributes</param>
            <returns>The text that gets rendered</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.IMarkupTag.PopDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <summary>
            Called after <see cref="M:Robust.Client.UserInterface.RichText.IMarkupTag.TextAfter(Robust.Shared.Utility.MarkupNode)"/>.<br/>
            Used for popping values that got added by this tag from the drawing context.
            </summary>
            <param name="node">The markup node containing the parameter and attributes</param>
            <param name="context">The context to pop the state from</param>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.IMarkupTag.TryGetControl(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.Control@)">
            <summary>
            Called inside the constructor of <see cref="T:Robust.Client.UserInterface.RichTextEntry"/> to
            supply a control that gets rendered inline before this tags children<br/>
            Text continues to the right of the control until the next line and then continues bellow it
            </summary>
            <param name="node">The markup node containing the parameter and attributes</param>
            <param name="control">A UI control for placing in line with this tags children</param>
            <returns>true if this tag supplies a control</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.ItalicTag.PushDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.RichText.ItalicTag.PopDrawContext(Robust.Shared.Utility.MarkupNode,Robust.Client.UserInterface.RichText.MarkupDrawingContext)">
            <inheritdoc/>
        </member>
        <member name="F:Robust.Client.UserInterface.RichText.MarkupTagManager._markupTagTypes">
            <summary>
            Tags defined in engine need to be instantiated here because of sandboxing
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.RichText.MarkupTagManager._engineTypes">
            <summary>
            A list of <see cref="T:Robust.Client.UserInterface.RichText.IMarkupTag"/> types that shouldn't be instantiated through reflection
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Stylesheet">
            <summary>
                As part of my evil plan to convince Monster to work on SS14, I'm porting web technologies to Robust.
                Here's CSS style sheets.
            </summary>
            <seealso cref="T:Robust.Client.UserInterface.StylesheetHelpers"/>
        </member>
        <member name="T:Robust.Client.UserInterface.StylesheetHelpers">
            <summary>
            Helper methods to make construction of style sheets easier.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.StylesheetHelpers.Element">
            <summary>
                Creates a blank mutable element selector.
            </summary>
            <seealso cref="T:Robust.Client.UserInterface.SelectorElement"/>
        </member>
        <member name="M:Robust.Client.UserInterface.StylesheetHelpers.Element``1">
            <summary>
                Creates a mutable element selector with <typeparamref name="T"/> as control type.
            </summary>
            <typeparam name="T">The type of control that the selector binds to.</typeparam>
            <seealso cref="T:Robust.Client.UserInterface.SelectorElement"/>
        </member>
        <member name="M:Robust.Client.UserInterface.StylesheetHelpers.Child">
            <summary>
                Creates a new blank mutable child selector.
            </summary>
            <seealso cref="T:Robust.Client.UserInterface.MutableSelectorChild"/>
        </member>
        <member name="T:Robust.Client.UserInterface.MutableSelector">
            <summary>
                Mutable selectors are convenience wrappers to make constructing style selectors cleaner.
            </summary>
            <remarks>
                Mutable selectors can store style properties that will get used when converted to a style rule.
                These can be added with <see cref="M:Robust.Client.UserInterface.MutableSelector.Prop(System.String,System.Object)"/>
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.MutableSelector.op_Implicit(Robust.Client.UserInterface.MutableSelector)~Robust.Client.UserInterface.StyleRule">
            <summary>
                Converts a mutable selector into a style rule, using the properties added via <see cref="M:Robust.Client.UserInterface.MutableSelector.Prop(System.String,System.Object)"/>.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.MutableSelectorElement">
            <summary>
                Mutable selector for <see cref="T:Robust.Client.UserInterface.SelectorElement"/>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:Robust.Client.UserInterface.MutableSelectorElement.Class(System.String[])">
            <summary>
                Adds a set of style classes to this selector.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.MutableSelectorElement.Class(System.String)">
            <summary>
                Adds a single style class to this selector.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.MutableSelectorElement.Pseudo(System.String[])">
            <summary>
                Adds a set of pseudo classes to this selector.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.MutableSelectorElement.Pseudo(System.String)">
            <summary>
                Adds a single pseudo class to this selector.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.MutableSelectorElement.Identifier(System.String)">
            <summary>
                Sets the style identifier on this selector.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.MutableSelectorChild">
             <summary>
            
             </summary>
             <inheritdoc/>
             <remarks>
                 Both <see cref="M:Robust.Client.UserInterface.MutableSelectorChild.Parent(Robust.Client.UserInterface.Selector)"/> and <see cref="M:Robust.Client.UserInterface.MutableSelectorChild.Child(Robust.Client.UserInterface.Selector)"/> must be set before converting this to a proper selector,
                 or else an <see cref="T:System.InvalidOperationException"/> will be thrown.
             </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.StyleRule">
            <summary>
                A single rule in a style sheet, containing a bunch of properties and a selector.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.StyleProperty">
            <summary>
                A single property in a rule, with a name and an object value.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.Tooltips">
            <summary>
            Utilities for working with tooltips.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.Tooltips.PositionTooltip(Robust.Client.UserInterface.Control)">
            <summary>
            Positions the provided control as a tooltip within the bounds of its parent UserInterfaceManager screen
            under the current mouse position. Sizing Based on its current combined minimum size.
            Defaults to the top left corner
            of the control being placed at the mouse position but
            adjusting to a different corner if the control would go beyond the edge of the bounds.
            </summary>
            <param name="tooltip">control to position (current size will be used to determine bounds)</param>
        </member>
        <member name="M:Robust.Client.UserInterface.Tooltips.PositionTooltip(System.Numerics.Vector2,System.Numerics.Vector2,Robust.Client.UserInterface.Control)">
            <summary>
            Positions the provided control as a tooltip within the provided screenBounds based on its current
            combined minimum size.
            Defaults to the top left corner
            of the control being placed at the indicated position but
            adjusting to a different corner if the control would go beyond the edge of the bounds.
            </summary>
            <param name="screenBounds">max x and y screen coordinates for the tooltip to occupy, tooltip
            will be shifted to avoid exceeding these bounds.</param>
            <param name="screenPosition">position to place the tooltip at, in screen coordinates</param>
            <param name="tooltip">control to position (current size will be used to determine bounds)</param>
        </member>
        <member name="T:Robust.Client.UserInterface.UISystemDependencyAttribute">
            <summary>
                Attribute applied to EntitySystem-typed fields inside UIControllers that should be
                injected when the system becomes available.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.IUriOpener">
            <summary>
                Helper for opening <see cref="T:System.Uri"/>s on the user's machine.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.IUriOpener.OpenUri(System.Uri)">
            <summary>
                Open a <see cref="T:System.Uri" /> in the user's web browser.
            </summary>
            <remarks>
                The URI must be an absolute <c>http://</c> or <c>https://</c> URI.
            </remarks>
            <param name="uri">The uri to open.</param>
            <exception cref="T:System.ArgumentException">
                Thrown if the URI is not absolute or for HTTP or HTTPS.
            </exception>
        </member>
        <member name="M:Robust.Client.UserInterface.IUriOpener.OpenUri(System.String)">
            <summary>
                Open a URI in the user's web browser.
            </summary>
            <remarks>
                The URI must be an absolute <c>http://</c> or <c>https://</c> URI.
            </remarks>
            <param name="uriString">The uri to open.</param>
            <exception cref="T:System.ArgumentException">
                Thrown if the URI is not absolute or for HTTP or HTTPS.
            </exception>
        </member>
        <member name="T:Robust.Client.UserInterface.WordWrap">
            <summary>
            Helper utility struct for word-wrapping calculations.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.NameScope">
            <summary>
            Implements a name scope.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.Proxy.IXamlHotReloadManager">
             <summary>
             This service locates the SS14 source tree and watches for changes to its xaml files.
             </summary>
             <remarks>
             It then reloads them instantly.
            
             It depends on <see cref="T:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager"/> and is stubbed on non-TOOLS builds.
             </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.IXamlHotReloadManager.Initialize">
            <summary>
            Initialize the hot reload manager.
            </summary>
            <remarks>
            You can't do anything with this once it's started, including turn it off.
            </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyHelper">
            <summary>
            Reexport the Populate method of <see cref="T:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager"/> and nothing else.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager">
             <summary>
             This service provides a proxy for Populate, which is the generated function that
             initializes the UI objects of a Xaml widget.
             </summary>
             <remarks>
             The proxy can always return false: in that case, a Xaml widget will self-populate
             as usual. This is the behavior on Release builds.
            
             However, it can also call into an externally-provided implementation of the Xaml
             widget.
            
             No source of externally-provided implementations actually exists, by default --
             you will need to call SetImplementation with a blob of xaml source code to provide
             one. <see cref="T:Robust.Client.UserInterface.XAML.Proxy.IXamlHotReloadManager" /> is an example of a service that calls into
             that functionality.
             </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager.Initialize">
            <summary>
            Initialize creates the <see cref="T:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager"/>.
            </summary>
            <remarks>
            If the <see cref="T:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager" /> is not a stub, then it will spy on the
            assembly list (from <see cref="T:Robust.Shared.Reflection.IReflectionManager" />)
            and find <see cref="T:Robust.Client.UserInterface.XAML.Proxy.XamlMetadataAttribute" /> entries on the loaded types.
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager.CanSetImplementation(System.String)">
             <summary>
             Return true if at least one <see cref="T:System.Type"/> in the current project expects its XAML
             to come from a file with the given name.
             </summary>
             <remarks>
             This method supports code that is trying to figure out what name the build process
             would have assigned to a resource file. A caller can try a few candidate names and use
             its "yes" to continue.
            
             This method is very fast, so it's OK to hammer it!
            
             Also, on a non-tools build, this always returns false.
             </remarks>
             <param name="fileName">the filename</param>
             <returns>true if expected</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager.SetImplementation(System.String,System.String)">
             <summary>
             Replace the implementation of <paramref name="fileName"/> with <paramref name="fileContent" />,
             compiling it if needed.
            
             All types based on <paramref name="fileName" /> will be recompiled.
             </summary>
             <remarks>
             This may fail and the caller won't be notified. (There will usually be logs.)
            
             On a non-tools build, this fails silently.
             </remarks>
             <param name="fileName">the name of the file</param>
             <param name="fileContent">the new content of the file</param>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager.Populate(System.Type,System.Object)">
            <summary>
            If we have a JIT version of the XAML code for <paramref name="t" />, then call
            the new implementation on <paramref name="o" />.
            </summary>
            <remarks>
            <paramref name="o" /> may be a subclass of <paramref name="t" />.
            </remarks>
            <param name="t">the static type of the object</param>
            <param name="o">the object</param>
            <returns>true if we called a hot reloaded implementation</returns>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.Proxy.XamlHotReloadManager">
            <summary>
            The real implementation of <see cref="T:Robust.Client.UserInterface.XAML.Proxy.IXamlHotReloadManager" />.
            </summary>
            <remarks>
            Its behavior is described there.
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlHotReloadManager.CreateWatcher(System.String)">
            <summary>
            Create a file system watcher that identifies XAML changes in a given
            location.
            </summary>
            <param name="location">the location (a real path on the OS file system)</param>
            <returns>the new watcher</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if <see cref="T:System.IO.FileSystemWatcher"/> violates its type-related postconditions</exception>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlHotReloadManager.InferCodeLocation">
            <summary>
            Using the content roots of the project, infer the location of its code.
            </summary>
            <remarks>
            This kind of introspection is almost universally a bad idea, but we don't
            feasibly have other options, so I've buried it in a private method.
            </remarks>
            <returns>the inferred code location or null</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlHotReloadManager.ResourceFileName(System.String,System.String,System.Predicate{System.String})">
            <summary>
            Infer the name of the resource file associated with the XAML item at the given path.
            </summary>
            <param name="codeLocation">the code location</param>
            <param name="realPath">the real path of the file</param>
            <param name="isDesired">a function returning true if something expects this file</param>
            <returns>the name of a desired resource that matches this file, or null</returns>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.Proxy.XamlHotReloadManagerStub">
            <summary>
            A stub implementation of <see cref="T:Robust.Client.UserInterface.XAML.Proxy.XamlHotReloadManager"/>. Its
            behavior is to do nothing.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlHotReloadManagerStub.Initialize">
            <summary>
            Do nothing.
            </summary>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage">
            <summary>
            This is a utility class that tracks the relationship between resource file names,
            Xamlx-compatible <see cref="T:System.Uri"/>s, <see cref="T:System.Type"/>s that are interested in a
            given file, and implementations of Populate.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage._fileUri">
            <summary>
            For each filename, we store its last known <see cref="T:System.Uri"/>.
            </summary>
            <remarks>
            When we compile the new implementation, we will use the same <see cref="T:System.Uri"/>.
            </remarks>
        </member>
        <member name="F:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage._fileContent">
            <summary>
            For each filename, we store its last known content.
            </summary>
            <remarks>
            This is known even for AOT-compiled code -- therefore, we can use this table
            to convert an AOT-compiled Control to a JIT-compiled one.
            </remarks>
        </member>
        <member name="F:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage._fileType">
            <summary>
            For each filename, we store the type interested in this file.
            </summary>
        </member>
        <member name="F:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage._populateImplementations">
            <summary>
            For each type, store the JIT-compiled implementation of Populate.
            </summary>
            <remarks>
            If no such implementation exists, then methods that would normally
            find and call a JIT'ed implementation will do nothing and return
            false instead. As an ultimate result, the AOT'ed implementation
            will be used.
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage.#ctor(Robust.Shared.Log.ISawmill,Robust.Client.UserInterface.XAML.Proxy.XamlJitDelegate)">
            <summary>
            Create the storage.
            </summary>
            <remarks>
            It would be weird to call this from any type outside of
            <see cref="N:Robust.Client.UserInterface.XAML.Proxy" />.
            </remarks>
            <param name="sawmill">the (shared) logger</param>
            <param name="jitDelegate">
                a delegate that calls the
                <see cref="T:Robust.Xaml.XamlJitCompiler"/>, possibly handling errors
            </param>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage.TypesWithXamlMetadata(System.Reflection.Assembly)">
             <summary>
             Inspect <paramref name="assembly" /> for types that declare a <see cref="T:Robust.Client.UserInterface.XAML.Proxy.XamlMetadataAttribute"/>.
             </summary>
             <remarks>
             We can only do hot reloading if we know this basic information.
            
             Note that even release-mode content artifacts contain this attribute.
             </remarks>
             <param name="assembly">the assembly</param>
             <returns>an IEnumerable of types with xaml metadata</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage.Add(System.Reflection.Assembly)">
            <summary>
            Add all Xaml-annotated types from <paramref name="assembly" /> to this storage.
            </summary>
            <remarks>
            We don't JIT these types, but we store enough info that we could JIT
            them if we wanted to.
            </remarks>
            <param name="assembly">an assembly</param>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage.ForceReloadAll">
            <summary>
            Quietly JIT every type with XAML metadata.
            </summary>
            <remarks>
            This should have no visible effect except that the <see cref="T:Robust.Client.UserInterface.XAML.Proxy.XamlJitDelegate"/>
            may dump some info messages into the terminal about cases where the
            hot reload failed.
            </remarks>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage.CanSetImplementation(System.String)">
            <summary>
            Return true if calling <see cref="M:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage.SetImplementation(System.String,System.String,System.Boolean)" /> on <paramref name="fileName" /> would not be a no-op.
            </summary>
            <remarks>
            That is: if some type cares about the contents of <paramref name="fileName" />.
            </remarks>
            <param name="fileName">the filename</param>
            <returns>true if not a no-op</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage.SetImplementation(System.String,System.String,System.Boolean)">
            <summary>
            Replace the implementation of <paramref name="fileName"/> by JIT-ing
            <paramref name="fileContent"/>.
            </summary>
            <remarks>
            If nothing cares about the implementation of <paramref name="fileName"/>, then this will do nothing.
            </remarks>
            <param name="fileName">the name of the file whose implementation should be replaced</param>
            <param name="fileContent">the new implementation</param>
            <param name="quiet">if true, then don't bother to log</param>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlImplementationStorage.Populate(System.Type,System.Object)">
             <summary>
             Call the JITed implementation of Populate on a XAML-associated object <paramref name="o"/>.
            
             If no JITed implementation exists, return false.
             </summary>
             <param name="t">the static type of <paramref name="o"/></param>
             <param name="o">an instance of <paramref name="t"/> (can be a subclass)</param>
             <returns>true if a JITed implementation existed</returns>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.Proxy.XamlJitDelegate">
             <summary>
             This callback has the approximate type of <see cref="M:Robust.Xaml.XamlJitCompiler.Compile(System.Type,System.Uri,System.String,System.String)"/>,
             but it has no error-signaling faculty.
             </summary>
             <remarks>
             Implementors of this delegate should inform the users of errors in their own way.
            
             Hot reloading failures should not directly take down the process, so implementors
             should not rethrow exceptions unless they have a strong reason to believe they
             will be caught.
             </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.Proxy.XamlMetadataAttribute">
             <summary>
             Metadata to support JIT compilation of XAML resources for a type.
             </summary>
             <remarks>
             We can feed XamlX data from this type, along with new content, to get new XAML
             resources.
            
             This type is inert and is generated for release artifacts too, not just debug
             artifacts. Released content should support hot reloading if loaded in a debug
             client, but this is untested.
             </remarks>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManager">
            <summary>
            The real implementation of <see cref="T:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManager.Initialize">
            <summary>
            Initialize this, subscribing to assembly changes.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManager.CanSetImplementation(System.String)">
            <summary>
            Return true if setting the implementation of <paramref name="fileName" />
            would not be a no-op.
            </summary>
            <param name="fileName">the file name</param>
            <returns>true or false</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManager.SetImplementation(System.String,System.String)">
            <summary>
            Replace the implementation of <paramref name="fileName" />, failing
            silently if the new content does not compile. (but still logging)
            </summary>
            <param name="fileName">the file name</param>
            <param name="fileContent">the new content</param>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManager.AddAssemblies">
            <summary>
            Add all the types from all known assemblies, then force-JIT everything
            again.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManager.Populate(System.Type,System.Object)">
            <summary>
            Populate <paramref name="o" /> using the JIT compiler, if possible.
            </summary>
            <param name="t">the static type of <paramref name="o" /></param>
            <param name="o">a <paramref name="t" /> instance or subclass</param>
            <returns>true if there was a JITed implementation</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManager.Compile(System.Type,System.Uri,System.String,System.String)">
            <summary>
            Calls <see cref="M:Robust.Xaml.XamlJitCompiler.Compile(System.Type,System.Uri,System.String,System.String)"/> using a stored
            <see cref="T:Robust.Xaml.XamlJitCompiler"/> instance.
            </summary>
            <param name="t">the <see cref="T:System.Type"/> that cares about this Xaml</param>
            <param name="uri">the <see cref="T:System.Uri" /> of this xaml (from the type's metadata)</param>
            <param name="fileName">the filename of this xaml (from the type's metadata)</param>
            <param name="content">the new content of the xaml file</param>
            <returns>the MethodInfo for the new JITed implementation</returns>
        </member>
        <member name="T:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManagerStub">
            <summary>
            The stub implementation of <see cref="T:Robust.Client.UserInterface.XAML.Proxy.IXamlProxyManager"/>.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManagerStub.Initialize">
            <summary>
            Do nothing.
            </summary>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManagerStub.CanSetImplementation(System.String)">
            <summary>
            Return false. Nothing is ever interested in a Xaml content update when
            hot reloading is off.
            </summary>
            <param name="fileName">the filename</param>
            <returns>false</returns>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManagerStub.SetImplementation(System.String,System.String)">
            <summary>
            Do nothing. A hot reload will always silently fail if hot reloading is off.
            </summary>
            <param name="fileName"></param>
            <param name="fileContent"></param>
        </member>
        <member name="M:Robust.Client.UserInterface.XAML.Proxy.XamlProxyManagerStub.Populate(System.Type,System.Object)">
            <summary>
            Return false.
            </summary>
            <remarks>
            There will never be a JIT-ed implementation of Populate if hot reloading is off.
            </remarks>
            <param name="t">the static type of <paramref name="o" /></param>
            <param name="o">an instance of <paramref name="t" /> or a subclass</param>
            <returns>false</returns>
        </member>
        <member name="M:Robust.Client.Utility.DirExt.RoundToCardinal(Robust.Shared.Graphics.RSI.RsiDirection)">
            <summary>
            'Rounds' a diagonal direction down to a cardinal direction
            </summary>
            <param name="dir">The direction to round</param>
            <returns><paramref name="dir"/> if it's a cardinal direction, otherwise either north or
            south.</returns>
        </member>
        <member name="M:Robust.Client.Utility.DiscordRichPresence.Truncate(System.String,System.Int32,System.String,System.Text.Encoding)">
            <summary>
            Truncate strings down to some minimum byte count. If the string gets truncated, it will have the postfix appended.
            </summary>
        </member>
        <member name="F:Robust.Client.Utility.DiscordRichPresence.NativeLogger._successfullyConnected">
            <summary>
            This library keeps trying to connect all the time and spams the client with error messages.
            To mitigate this annoyance, this variable keeps track of whether a connection was established
            (or whether it's the first time it's being attempted) so that we can print the error only when it's useful.
            </summary>
        </member>
        <member name="M:Robust.Client.Utility.ImageSharpExt.Blit``1(SixLabors.ImageSharp.Image{``0},Robust.Shared.Maths.UIBox2i,SixLabors.ImageSharp.Image{``0},Robust.Shared.Maths.Vector2i)">
            <summary>
                Blit an image into another, with the specified offset.
            </summary>
            <param name="source">The image to copy data from.</param>
            <param name="sourceRect">The sub section of <see cref="!:source"/> that will be copied.</param>
            <param name="destinationOffset">
                The offset into <see cref="!:destination"/> that data will be copied into.
            </param>
            <param name="destination">The image to copy to.</param>
            <typeparam name="T">The type of pixel stored in the images.</typeparam>
        </member>
        <member name="M:Robust.Client.Utility.ImageSharpExt.GetPixelSpan``1(SixLabors.ImageSharp.Image{``0})">
            <summary>
            Gets a <see cref="T:System.Span`1" /> to the backing data if the backing group consists of a single contiguous memory buffer.
            </summary>
            <returns>The <see cref="T:System.Span`1" /> referencing the memory area.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the image is not a single contiguous buffer.</exception>
        </member>
        <member name="T:Robust.Client.Utility.SpriteSpecifierExt">
            <summary>
                Helper methods for resolving <see cref="T:Robust.Shared.Utility.SpriteSpecifier"/>s.
            </summary>
        </member>
        <member name="T:Robust.Client.ViewVariables.Editors.VVPropEditorDummy">
            <summary>
                Just writes out the ToString of the object.
                The ultimate fallback.
            </summary>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManager.OpenVV(System.Object)">
            <summary>
                Open a VV window for a locally existing object.
            </summary>
            <param name="obj">The object to VV.</param>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManager.OpenVV(System.String)">
            <summary>
                Open a VV window for a locally existing object.
            </summary>
            <param name="path">The VV path to the object to VV.</param>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManager.OpenVV(Robust.Shared.ViewVariables.ViewVariablesObjectSelector)">
            <summary>
                Open a VV window for a remotely existing object.
            </summary>
            <param name="selector">The selector to reference the object remotely.</param>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManagerInternal.PropertyFor(System.Type)">
            <summary>
                Creates the ideal property editor for a specific property type.
            </summary>
            <param name="type">The type of the property to create an editor for.</param>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManagerInternal.RequestSession(Robust.Shared.ViewVariables.ViewVariablesObjectSelector)">
            <summary>
                Requests a session to an object on the server.
            </summary>
            <param name="selector">The selector so the server knows what object we want.</param>
            <returns>A session that can be used to request data and modify the remote object.</returns>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManagerInternal.RequestData(Robust.Client.ViewVariables.ViewVariablesRemoteSession,Robust.Shared.ViewVariables.ViewVariablesRequest)">
            <summary>
                Requests a data blob from the object referenced by a VV session.
            </summary>
            <param name="session">The session for the remote object.</param>
            <param name="meta">A request object the server uses to know what kind of data you want of the remote object.</param>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManagerInternal.RequestData``1(Robust.Client.ViewVariables.ViewVariablesRemoteSession,Robust.Shared.ViewVariables.ViewVariablesRequest)">
            <summary>
                Requests a data blob from the object referenced by a VV session.
            </summary>
            <typeparam name="T">The type of blob that is expected of the server to be sent back, to be automatically cast for convenience.</typeparam>
            <param name="session">The session for the remote object.</param>
            <param name="meta">A request object the server uses to know what kind of data you want of the remote object.</param>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManagerInternal.CloseSession(Robust.Client.ViewVariables.ViewVariablesRemoteSession)">
            <summary>
                Close a session to a remote object.
            </summary>
            <param name="session">The session to close.</param>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManagerInternal.TryGetSession(System.UInt32,Robust.Client.ViewVariables.ViewVariablesRemoteSession@)">
            <summary>
                Attempts to get a VV session given its Uid.
            </summary>
            <param name="sessionId"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManagerInternal.ModifyRemote(Robust.Client.ViewVariables.ViewVariablesRemoteSession,System.Object[],System.Object,System.Boolean)">
            <summary>
                Modify a remote object.
            </summary>
            <param name="session">The session pointing to the remote object.</param>
            <param name="propertyIndex">An array of objects that the server can parse to figure out what to assign.</param>
            <param name="value">The new value for the object.</param>
            <param name="reinterpretValue">Whether the <see cref="!:value"/> will be reinterpreted on the server. Also see: <seealso cref="P:Robust.Shared.Network.Messages.MsgViewVariablesModifyRemote.ReinterpretValue"/></param>
        </member>
        <member name="M:Robust.Client.ViewVariables.IClientViewVariablesManagerInternal.TraitIdsFor(System.Type)">
            <summary>
                Gets a collection of trait IDs that are agreed upon so <see cref="T:Robust.Client.ViewVariables.Instances.ViewVariablesInstanceObject"/> knows which traits to instantiate.
            </summary>
            <seealso cref="P:Robust.Shared.ViewVariables.ViewVariablesBlobMetadata.Traits" />
            <seealso cref="M:Robust.Shared.ViewVariables.ViewVariablesManager.TraitIdsFor(System.Type)"/>
        </member>
        <member name="M:Robust.Client.ViewVariables.Instances.ViewVariablesInstanceEntity.GetValidComponentsForAdding">
            <summary>
                Returns an enumeration of components that can *probably* be added to an entity.
            </summary>
        </member>
        <member name="M:Robust.Client.ViewVariables.Instances.ViewVariablesInstanceEntity.GetValidServerComponentsForAdding">
            <summary>
                Requests and returns an enumeration of server-side components that can *probably* be added to an entity.
            </summary>
        </member>
        <member name="T:Robust.Client.ViewVariables.ViewVariablesInstance">
            <summary>
                Controls the behavior of a VV window.
            </summary>
        </member>
        <member name="M:Robust.Client.ViewVariables.ViewVariablesInstance.Initialize(Robust.Client.UserInterface.CustomControls.DefaultWindow,System.Object)">
            <summary>
                Initializes this instance to work on a local object.
            </summary>
            <param name="window">The window to initialize by adding GUI components.</param>
            <param name="obj">The object that is being VV'd</param>
        </member>
        <member name="M:Robust.Client.ViewVariables.ViewVariablesInstance.Initialize(Robust.Client.UserInterface.CustomControls.DefaultWindow,Robust.Shared.ViewVariables.ViewVariablesBlobMetadata,Robust.Client.ViewVariables.ViewVariablesRemoteSession)">
            <summary>
                Initializes this instance to work on a remote object.
                This is called when the view variables manager has already made a session to the remote object.
            </summary>
            <param name="window">The window to initialize by adding GUI components.</param>
            <param name="blob">The data blob sent by the server for this remote object.</param>
            <param name="session">The session connecting to the remote object.</param>
        </member>
        <member name="M:Robust.Client.ViewVariables.ViewVariablesInstance.Close">
            <summary>
                Invoked to "clean up" the instance, such as closing remote sessions.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Robust.Client.ViewVariables.ViewVariablesRemoteSession" -->
        <member name="T:Robust.Client.ViewVariables.ViewVariablesTrait">
            <summary>
                Traits define what behavior an object can have that VV cares about.
                So like, is it enumerable, does it have VV accessible members. That kinda deal.
                These are the "modular" way of extending VV.
            </summary>
        </member>
        <member name="T:Robust.Client.ViewVariables.VVPropEditor">
            <summary>
                An editor for the value of a property.
            </summary>
        </member>
        <member name="E:Robust.Client.ViewVariables.VVPropEditor.OnValueChanged">
            <summary>
                Invoked when the value was changed.
            </summary>
        </member>
        <member name="T:Robust.Client.WebViewHook.WebViewManagerImplAttribute">
            <summary>
            Used so that the IWebViewManager can be loaded when loading Robust.Client.WebView.
            </summary>
        </member>
        <member name="M:SDL2.SDL.SDL_GetNumTouchDevices">
            \brief Get the number of registered touch devices.
        </member>
        <member name="M:SDL2.SDL.SDL_GetTouchDevice(System.Int32)">
            \brief Get the touch ID with the given index, or 0 if the index is invalid.
        </member>
        <member name="M:SDL2.SDL.SDL_GetNumTouchFingers(System.Int64)">
            \brief Get the number of active fingers for a given touch device.
        </member>
        <member name="M:SDL2.SDL.SDL_GetTouchFinger(System.Int64,System.Int32)">
            \brief Get the finger object of the given touch, with the given index.
            Returns pointer to SDL_Finger.
        </member>
    </members>
</doc>
