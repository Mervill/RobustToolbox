<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Robust.Server</name>
    </assembly>
    <members>
        <member name="M:Robust.Server.Audio.AudioSystem.PlayGlobal(System.String,Robust.Shared.Player.Filter,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Audio.AudioSystem.PlayEntity(System.String,Robust.Shared.Player.Filter,Robust.Shared.GameObjects.EntityUid,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Audio.AudioSystem.PlayPvs(System.String,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Audio.AudioSystem.PlayStatic(System.String,Robust.Shared.Player.Filter,Robust.Shared.Map.EntityCoordinates,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Audio.AudioSystem.PlayPvs(System.String,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Audio.AudioSystem.PlayPredicted(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Audio.AudioSystem.PlayPredicted(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Nullable{Robust.Shared.Audio.AudioParams})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Audio.AudioSystem.ReloadPresets">
            <summary>
            Reloads all <see cref="T:Robust.Shared.Audio.AudioPresetPrototype"/> entities.
            </summary>
        </member>
        <member name="T:Robust.Server.BaseServer">
            <summary>
            The master class that runs the rest of the engine.
            </summary>
        </member>
        <member name="P:Robust.Server.BaseServer.MaxPlayers">
            <inheritdoc />
        </member>
        <member name="P:Robust.Server.BaseServer.ServerName">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.BaseServer.Restart">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.BaseServer.Shutdown(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.BaseServer.Start(Robust.Server.ServerOptions,System.Func{Robust.Shared.Log.ILogHandler})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.BaseServer.MainLoop">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.BaseServer.LoadSettings">
            <summary>
                Loads the server settings from the ConfigurationManager.
            </summary>
        </member>
        <member name="T:Robust.Server.Configuration.IServerNetConfigurationManager">
            <summary>
            A networked configuration manager that controls the replication of
            console variables between client and server.
            </summary>
        </member>
        <member name="M:Robust.Server.Configuration.IServerNetConfigurationManager.SyncConnectingClient(Robust.Shared.Network.INetChannel)">
            <summary>
            Synchronize the CVars marked with <see cref="F:Robust.Shared.Configuration.CVar.REPLICATED"/> with the client.
            This needs to be called once during the client connection.
            </summary>
            <param name="client">Client's NetChannel to sync replicated CVars with.</param>
        </member>
        <member name="M:Robust.Server.Configuration.ServerNetConfigurationManager.GetClientCVar``1(Robust.Shared.Network.INetChannel,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Configuration.ServerNetConfigurationManager.SetCVar(System.String,System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Server.Console.Commands.TestbedCommand">
            <summary>
                Copies of Box2D's physics testbed for debugging.
            </summary>
        </member>
        <member name="T:Robust.Server.Console.IServerConsoleHost">
            <summary>
            The server console shell that executes commands.
            </summary>
        </member>
        <member name="M:Robust.Server.Console.IServerConsoleHost.Initialize">
            <summary>
            Initializes the ConsoleShell service.
            </summary>
        </member>
        <member name="T:Robust.Server.Console.ISystemConsoleManager">
            <summary>
                Wraps the system console.
            </summary>
        </member>
        <member name="M:Robust.Server.Console.ISystemConsoleManager.UpdateInput">
            <summary>
                process input/output of the console. This needs to be called often.
            </summary>
        </member>
        <member name="M:Robust.Server.Console.ISystemConsoleManager.Print(System.String)">
            <summary>
                Prints <paramref name="text" /> to the system console.
            </summary>
            <param name="text">Text to write to the system console.</param>
        </member>
        <member name="T:Robust.Server.Console.ServerConsoleHost">
            <inheritdoc cref="T:Robust.Server.Console.IServerConsoleHost" />
        </member>
        <member name="M:Robust.Server.Console.ServerConsoleHost.ExecuteCommand(Robust.Shared.Player.ICommonSession,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Console.ServerConsoleHost.RemoteExecuteCommand(Robust.Shared.Player.ICommonSession,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Console.ServerConsoleHost.WriteLine(Robust.Shared.Player.ICommonSession,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Console.ServerConsoleHost.WriteError(Robust.Shared.Player.ICommonSession,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Console.ServerConsoleHost.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Console.ServerConsoleHost.CalcCompletions(Robust.Shared.Console.IConsoleShell,System.String[],System.String)">
            <summary>
            Get completions. Non-null results imply that the command was handled. If it is empty, it implies that
            there are no completions for this command.
            </summary>
        </member>
        <member name="M:Robust.Server.Console.SystemConsoleManager.UpdateTitle">
            <summary>
                Updates the console window title with performance statistics.
            </summary>
        </member>
        <member name="T:Robust.Server.DataMetrics.IMetricsManager">
            <summary>
            Manages OpenTelemetry metrics exposure.
            </summary>
            <remarks>
            <para>
            If enabled via <see cref="F:Robust.Shared.CVars.MetricsEnabled"/>, metrics about the game server are exposed via a HTTP server
            in an OpenTelemetry-compatible format (Prometheus).
            </para>
            <para>
            Metrics can be added through the types in <c>System.Diagnostics.Metrics</c> or <c>Prometheus</c>.
            IoC contains an implementation of <see cref="T:System.Diagnostics.Metrics.IMeterFactory"/> that can be used to instantiate meters.
            </para>
            </remarks>
        </member>
        <member name="E:Robust.Server.DataMetrics.IMetricsManager.UpdateMetrics">
            <summary>
            An event that gets raised on the main thread when complex metrics should be updated.
            </summary>
            <remarks>
            This event is raised on the main thread before a Prometheus collection happens,
            and also with a fixed interval if <see cref="F:Robust.Shared.CVars.MetricsUpdateInterval"/> is set.
            You can use it to update complex metrics that can't "just" be stuffed into a counter.
            </remarks>
        </member>
        <member name="M:Robust.Server.GameObjects.PointLightComponent.InternalCopy(Robust.Server.GameObjects.PointLightComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.PointLightComponent.Copy(Robust.Server.GameObjects.PointLightComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.PointLightComponent.Copy(Robust.Shared.GameObjects.SharedPointLightComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.PointLightComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.PointLightComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.PointLightComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.PointLightComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Server.GameObjects.VisibilityComponent">
            <summary>
            Controls PVS visibility of entities. THIS COMPONENT CONTROLS WHETHER ENTITIES ARE NETWORKED TO PLAYERS
            AND SHOULD NOT BE USED AS THE SOLE WAY TO HIDE AN ENTITY FROM A PLAYER.
            </summary>
        </member>
        <member name="F:Robust.Server.GameObjects.VisibilityComponent.Layer">
            <summary>
                The visibility layer for the entity.
                Players whose visibility masks don't match this won't get state updates for it.
            </summary>
        </member>
        <member name="M:Robust.Server.GameObjects.VisibilityComponent.InternalCopy(Robust.Server.GameObjects.VisibilityComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.VisibilityComponent.Copy(Robust.Server.GameObjects.VisibilityComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.VisibilityComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.VisibilityComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.VisibilityComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.VisibilityComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.VisibilityComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Server.GameObjects.InputSystem">
            <summary>
                Server side processing of incoming user commands.
            </summary>
        </member>
        <member name="M:Robust.Server.GameObjects.InputSystem.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.GameObjects.InputSystem.Shutdown">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.GameObjects.MapLoaderSystem.TryLoad(Robust.Shared.Map.MapId,System.String,System.Collections.Generic.IReadOnlyList{Robust.Shared.GameObjects.EntityUid}@,Robust.Server.Maps.MapLoadOptions)">
            <summary>
            Tries to load the supplied path onto the supplied Mapid.
            Will return false if something went wrong and needs handling.
            </summary>
            <param name="mapId">The Mapid to load onto. Depending on the supplied options this map may or may not already exist.</param>
            <param name="path">The resource path to the required map.</param>
            <param name="rootUids">The root Uids of the map; not guaranteed to be grids!</param>
            <param name="options">The required options for loading.</param>
            <returns></returns>
        </member>
        <member name="T:Robust.Server.GameObjects.MapLoaderSystem.MapData">
            <summary>
                Does basic pre-deserialization checks on map file load.
                For example, let's not try to use maps with multiple grids as blueprints, shall we?
            </summary>
        </member>
        <member name="M:Robust.Server.GameObjects.PhysicsSystem.Update(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.GameObjects.ServerMetaDataSystem.OnComponentAdded(Robust.Shared.GameObjects.AddedComponentEventArgs)">
            <summary>
                If a session-specific component gets added, make sure the meta-data flag is set.
            </summary>
        </member>
        <member name="M:Robust.Server.GameObjects.ServerMetaDataSystem.OnComponentRemoved(Robust.Shared.GameObjects.RemovedComponentEventArgs)">
            <summary>
                If a session-specific component gets removed, this will update the meta-data flag.
            </summary>
        </member>
        <member name="M:Robust.Server.GameObjects.ServerMetaDataSystem.OnActorPlayerAttach(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.Player.PlayerAttachedEvent)">
            <summary>
                If a new player gets attached to an entity, this will ensure that the player receives session-restricted
                component states by dirtying any restricted components.
            </summary>
        </member>
        <member name="T:Robust.Server.GameObjects.ViewSubscriberSystem">
            <summary>
                Entity System that handles subscribing and unsubscribing to PVS views.
            </summary>
        </member>
        <member name="M:Robust.Server.GameObjects.ViewSubscriberSystem.AddViewSubscriber(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.ICommonSession)">
            <summary>
                Subscribes the session to get PVS updates from the point of view of the specified entity.
            </summary>
        </member>
        <member name="M:Robust.Server.GameObjects.ViewSubscriberSystem.RemoveViewSubscriber(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.ICommonSession)">
            <summary>
                Unsubscribes the session from getting PVS updates from the point of view of the specified entity.
            </summary>
        </member>
        <member name="T:Robust.Server.GameObjects.ViewSubscriberAddedEvent">
            <summary>
                Raised when a session subscribes to an entity's PVS view.
            </summary>
        </member>
        <member name="T:Robust.Server.GameObjects.ViewSubscriberRemovedEvent">
            <summary>
                Raised when a session is unsubscribed from an entity's PVS view.
                Not raised when sessions are unsubscribed due to the component being removed.
            </summary>
        </member>
        <member name="T:Robust.Server.GameObjects.IServerEntityManager">
            <summary>
            Server side version of the <see cref="T:Robust.Shared.GameObjects.IEntityManager"/>.
            </summary>
        </member>
        <member name="T:Robust.Server.GameObjects.MapSaveIdComponent">
            <summary>
                Metadata component used to keep consistent UIDs inside map files cross saving.
            </summary>
            <remarks>
                This component stores the previous map UID of entities from map load.
                This can then be used to re-serialize the entity with the same UID for the merge driver to recognize.
            </remarks>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveIdComponent.InternalCopy(Robust.Server.GameObjects.MapSaveIdComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveIdComponent.Copy(Robust.Server.GameObjects.MapSaveIdComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveIdComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveIdComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveIdComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveIdComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveIdComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Server.GameObjects.MapSaveTileMapComponent">
            <summary>
            Used by <see cref="T:Robust.Server.GameObjects.MapLoaderSystem"/> to track the original tile map from when a map was loaded.
            </summary>
            <remarks>
            <para>
            This component is used to reduce differences on map saving, by making it so that a tile map can be re-used between map saves even if internal engine IDs change.
            </para>
            <para>
            This component is created on every grid entity read during map load.
            This means loading a multi-grid map will create multiple of these components.
            When re-saving the map, the map loader will arbitrarily choose which available <see cref="T:Robust.Server.GameObjects.MapSaveTileMapComponent"/>
            to use.
            </para>
            </remarks>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveTileMapComponent.InternalCopy(Robust.Server.GameObjects.MapSaveTileMapComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveTileMapComponent.Copy(Robust.Server.GameObjects.MapSaveTileMapComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveTileMapComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveTileMapComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveTileMapComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveTileMapComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.GameObjects.MapSaveTileMapComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Server.GameObjects.ServerEntityManager">
            <summary>
            Manager for entities -- controls things like template loading and instantiation
            </summary>
        </member>
        <member name="M:Robust.Server.GameObjects.ServerEntityManager.RaiseSharedEvent``1(``0,System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.GameObjects.ServerEntityManager.RaiseSharedEvent``1(``0,Robust.Shared.Player.ICommonSession)">
            <inheritdoc />
        </member>
        <member name="E:Robust.Server.GameObjects.ServerEntityManager.ReceivedSystemMessage">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.GameObjects.ServerEntityManager.SetupNetworking">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.GameObjects.ServerEntityManager.TickUpdate(System.Single,System.Boolean,Prometheus.Histogram)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.GameObjects.ServerEntityManager.SendSystemNetworkMessage(Robust.Shared.GameObjects.EntityEventArgs,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.GameObjects.ServerEntityManager.SendSystemNetworkMessage(Robust.Shared.GameObjects.EntityEventArgs,Robust.Shared.Network.INetChannel)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Server.GameStates.IServerGameStateManager">
            <summary>
            Engine service that provides creating and dispatching of game states.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.IServerGameStateManager.Initialize">
            <summary>
            One time initialization of the service.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.IServerGameStateManager.SendGameStateUpdate">
            <summary>
            Create and dispatch game states to all connected sessions.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsChunk.Root">
            <summary>
            The root of this chunk. This should either be a map or a grid.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsChunk.Map">
            <summary>
            The map that this grid is on. Tis might be the same entity as <see cref="F:Robust.Server.GameStates.PvsChunk.Root"/>.
            </summary>
        </member>
        <member name="P:Robust.Server.GameStates.PvsChunk.Dirty">
            <summary>
            If true, then some entity was added or removed from this chunks and has to be reconstructed
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsChunk.Children">
            <summary>
            Set of entities that are directly parented to this grid.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsChunk.Contents">
            <summary>
            Sorted list of all entities on this chunk. The list is sorted based on their "proximity" to the root entity in
            the transform hierarchy. I.e., it will list all entities that are directly parented to the grid before listing
            any entities that are parented to those entities and so on.
            </summary>
            <remarks>
            This already includes <see cref="F:Robust.Server.GameStates.PvsChunk.Map"/>, <see cref="F:Robust.Server.GameStates.PvsChunk.Root"/>, and <see cref="F:Robust.Server.GameStates.PvsChunk.Children"/>
            </remarks>
        </member>
        <member name="F:Robust.Server.GameStates.PvsChunk.Location">
            <summary>
            The unique location identifier for this chunk.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsChunk.Centre">
            <summary>
            The location of the centre of this chunk, relative to the <see cref="F:Robust.Server.GameStates.PvsChunk.Root"/>
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsChunk.Position">
            <summary>
            The map position of the chunk's centre during the last PVS update.
            </summary>
        </member>
        <member name="P:Robust.Server.GameStates.PvsChunk.InvWorldMatrix">
            <summary>
            The <see cref="F:Robust.Server.GameStates.PvsChunk.Root"/>'s inverse world matrix.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Robust.Server.GameStates.PvsChunk.LodCounts" -->
        <member name="M:Robust.Server.GameStates.PvsChunk.PopulateContents(Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Populates the contents of this chunk. Returns false if some error occurs (e.g., contains deleted entities).
            </summary>
        </member>
        <member name="T:Robust.Server.GameStates.PvsSession">
            <summary>
            Class for storing session specific PVS data.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSession.#ctor(Robust.Shared.Player.ICommonSession,Robust.Shared.Utility.ResizableMemoryRegion{Robust.Server.GameStates.PvsData})">
            <summary>
            Class for storing session specific PVS data.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.PreviouslySent">
            <summary>
            All entities that this session saw during the last <see cref="F:Robust.Server.GameStates.PvsSystem.DirtyBufferSize"/> ticks.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.Overflow">
            <summary>
            <see cref="F:Robust.Server.GameStates.PvsSession.PreviouslySent"/> overflow in case a player's last ack is more than
            <see cref="F:Robust.Server.GameStates.PvsSystem.DirtyBufferSize"/> ticks behind the current tick.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.VisMask">
            <summary>
            The client's current visibility mask.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.ToSend">
            <summary>
            The list that is currently being prepared for sending.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.LastSent">
            <summary>
            The <see cref="F:Robust.Server.GameStates.PvsSession.ToSend"/> list from the previous tick. Also caches the current tick that the PVS leave message
            should belong to, in case the processing is ever run asynchronously with normal system/game ticking.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.Chunks">
            <summary>
            Visible chunks, sorted by proximity to the client's viewers.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.ChunkSet">
            <summary>
            Unsorted set of visible chunks. Used to construct the <see cref="F:Robust.Server.GameStates.PvsSession.Chunks"/> list.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.ChunkDistanceSq">
            <summary>
            Squared distance ta all of the visible chunks.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.Viewers">
            <summary>
            The client's current eyes/viewers.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.RequestedFull">
            <summary>
            If true, the client has explicitly requested a full state. Unlike the first state, we will send them all data,
            not just data that cannot be implicitly inferred from entity prototypes.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.States">
            <summary>
            List of entity states to send to the client.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.Budget">
            <summary>
            Information about the current number of entities that are being sent to the player this tick. Used to enforce
            pvs budgets.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.LastReceivedAck">
            <summary>
            The tick of the last acknowledged game state.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.FromTick">
            <summary>
            Start tick for the time window of data that has to be sent to this player.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.LeftView">
            <summary>
            List of entities that have left the player's view this tick.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.State">
            <summary>
            The game state for this tick,
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSession.StateStream">
            <summary>
            The serialized <see cref="F:Robust.Server.GameStates.PvsSession.State"/> object.
            </summary>
        </member>
        <member name="P:Robust.Server.GameStates.PvsSession.ForceSendReliably">
            <summary>
            Whether we should force reliable sending of the <see cref="T:Robust.Shared.Network.Messages.MsgState"/>.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSession.ClearState">
            <summary>
            Clears all stored game state data. This should only be used after the game state has been serialized.
            </summary>
        </member>
        <member name="T:Robust.Server.GameStates.PvsData">
            <summary>
            Class for storing session-specific information about when an entity was last sent to a player.
            </summary>
            <remarks>
            Size is padded to 16 bytes so
            </remarks>
        </member>
        <member name="F:Robust.Server.GameStates.PvsData.LastSeen">
            <summary>
            Tick at which this entity was last sent to a player.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsData.LastLeftView">
            <summary>
            Tick at which an entity last left a player's PVS view.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsData.EntityLastAcked">
            <summary>
            Stores the last tick at which a given entity was acked by a player. Used to avoid re-sending the whole entity
            state when an item re-enters PVS. This is only the same as the player's last acked tick if the entity was
            present in that state.
            </summary>
        </member>
        <member name="T:Robust.Server.GameStates.PvsMetadata">
            <summary>
            Specialized struct with the same size as <see cref="T:Robust.Server.GameStates.PvsData"/> that is used to store metadata in the pinned PVsData array
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsMetadata.NetEntity">
            <summary>
            Tick at which this entity was last sent to a player.
            </summary>
        </member>
        <member name="T:Robust.Server.GameStates.PvsBudget">
            <summary>
            Struct for storing information about the current number of entities that are being sent to the player this tick.
            Used to enforce pvs budgets.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsOverrideSystem.GetPvsInfo(Robust.Shared.Console.IConsoleShell,System.String,System.String[])">
            <summary>
            Debug command for displaying PVS override information.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsOverrideSystem.AddGlobalOverride(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Forces the entity, all of its parents, and all of its children to ignore normal PVS range limitations,
            causing them to always be sent to all clients.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsOverrideSystem.RemoveGlobalOverride(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Removes an entity from the global overrides.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsOverrideSystem.AddForceSend(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            This causes an entity and all of its parents to always be sent to all players.
            </summary>
            <remarks>
            This differs from <see cref="M:Robust.Server.GameStates.PvsOverrideSystem.AddGlobalOverride(Robust.Shared.GameObjects.EntityUid)"/> as it does not send children, and will ignore a players usual
            PVS budget. You generally shouldn't use this unless an entity absolutely always needs to be sent to all clients.
            </remarks>
        </member>
        <member name="M:Robust.Server.GameStates.PvsOverrideSystem.AddForceSend(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.ICommonSession)">
            <summary>
            This causes an entity and all of its parents to always be sent to a player..
            </summary>
            <remarks>
            This differs from <see cref="M:Robust.Server.GameStates.PvsOverrideSystem.AddSessionOverride(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.ICommonSession)"/> as it does not send children, and will ignore a players usual
            PVS budget. You generally shouldn't use this unless an entity absolutely always needs to be sent to a client.
            </remarks>
        </member>
        <member name="M:Robust.Server.GameStates.PvsOverrideSystem.RemoveForceSend(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.ICommonSession)">
            <summary>
            Removes an entity from a session's force send set.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsOverrideSystem.AddSessionOverride(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.ICommonSession)">
            <summary>
            Forces the entity, all of its parents, and all of its children to ignore normal PVS range limitations for a
            specific session.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsOverrideSystem.RemoveSessionOverride(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.ICommonSession)">
            <summary>
            Removes an entity from a session's overrides.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsOverrideSystem.AddSessionOverrides(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.Filter)">
            <summary>
            Forces the entity, all of its parents, and all of its children to ignore normal PVS range limitations,
            causing them to always be sent to all clients.
            </summary>
        </member>
        <member name="T:Robust.Server.GameStates.PvsSystem">
            <summary>
            Caching for dirty bodies
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.OnClientAck(Robust.Shared.Player.ICommonSession,Robust.Shared.Timing.GameTick)">
            <summary>
                Invoked when a client ack message is received. Queues up for processing in parallel prior to sending game
                state data.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ProcessQueuedAcks">
            <summary>
                Processes queued client acks in parallel
            </summary>
            <param name="histogram"></param>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ProcessQueuedAck(Robust.Server.GameStates.PvsSession)">
            <summary>
                Process a given client's queued ack.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.UpdateDirtyChunks(System.Int32)">
            <summary>
            Iterate over all visible chunks and, if necessary, re-construct their list of entities.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.UpdateChunkPosition(Robust.Server.GameStates.PvsChunk)">
            <summary>
            Update a chunk's world position. This is used to prioritize sending chunks that a closer to players.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.GetVisibleChunks">
            <summary>
            Update the list of all currently visible chunks.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.GetVisibleChunks(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.EyeComponent},System.Collections.Generic.HashSet{Robust.Server.GameStates.PvsChunk})">
            <summary>
            Get the chunks visible to a single entity and add them to a player's set of visible chunks.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.GetSessionViewers(Robust.Server.GameStates.PvsSession)">
            <summary>
            Get all viewers for a given session. This is required to get a list of visible chunks.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ProcessVisibleChunksSequential">
            <summary>
            Variant of <see cref="M:Robust.Server.GameStates.PvsSystem.ProcessVisibleChunks"/> that isn't multithreaded.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.AddEntityToChunk(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.PvsChunkLocation)">
            <summary>
            Add an entity to the set of entities that are directly attached to a chunk and mark the chunk as dirty.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.RemoveEntityFromChunk(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Remove an entity from a chunk and mark it as dirty.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.DirtyChunk(Robust.Shared.GameObjects.PvsChunkLocation)">
            <summary>
            Mark a chunk as dirty.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.DirtyAllChunks">
            <summary>
            Mark all chunks as dirty.
            </summary>
        </member>
        <member name="P:Robust.Server.GameStates.PvsSystem.ForceAckThreshold">
            <summary>
            See <see cref="F:Robust.Shared.CVars.NetForceAckThreshold"/>.
            </summary>
        </member>
        <member name="P:Robust.Server.GameStates.PvsSystem.CullingEnabled">
            <summary>
            Is view culling enabled, or will we send the whole map?
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._viewSize">
            <summary>
            Size of the side of the view bounds square. Related to <see cref="F:Robust.Shared.CVars.NetMaxUpdateRange"/>
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._priorityViewSize">
            <summary>
            Size of the side of the priority view bounds square. Related to <see cref="F:Robust.Shared.CVars.NetPvsPriorityRange"/>
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._toAck">
            <summary>
            Per-tick ack data to avoid re-allocating.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._deletedEntities">
            <summary>
            List of recently deleted entities.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._deletedTick">
            <summary>
            The tick at which each entity was deleted.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Robust.Server.GameStates.PvsSystem._sessions" -->
        <member name="M:Robust.Server.GameStates.PvsSystem.SendGameStates(Robust.Shared.Player.ICommonSession[])">
            <summary>
            Send this tick's game state data to players.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._incomingReturns">
            <summary>
            Recently returned indexes from deleted entities. These get moved to <see cref="F:Robust.Server.GameStates.PvsSystem._pendingReturns"/> before
            moving back into the free list.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._pendingReturns">
            <summary>
            Recently returned pointers from deleted entities. These will get returned to the free list
            after a minimum amount of time has passed, to ensure that processing late game-state ack messages doesn't
            write data to deleted entities.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._lastReturn">
            <summary>
            Tick at which the <see cref="F:Robust.Server.GameStates.PvsSystem._pendingReturns"/> were last processed.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._metadataMemory">
            <summary>
            Memory region to store <see cref="T:Robust.Server.GameStates.PvsMetadata"/> instances and the free list.
            </summary>
            <remarks>
            Unused elements form a linked list out of <see cref="T:Robust.Server.GameStates.PvsMetadataFreeLink"/> elements.
            </remarks>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._dataFreeListHead">
            <summary>
            The head of the PVS data free list. This is the first element that will be used if a new one is needed.
            </summary>
            <remarks>
            If the value is <see cref="F:Robust.Shared.GameObjects.PvsIndex.Invalid"/>,
            there are no more free elements and the next allocation must expand the memory.
            </remarks>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ExpandEntityCapacity">
            <summary>
            Expand the size of <see cref="F:Robust.Server.GameStates.PvsSystem._metadataMemory"/> (and all session data stores) one iteration.
            </summary>
            <remarks>
            This ensures that we have at least one free list slot.
            </remarks>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.InitializePvsArray">
            <summary>
            Initialize <see cref="F:Robust.Server.GameStates.PvsSystem._metadataMemory"/> and the free list.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.InitializeFreeList(System.Span{Robust.Server.GameStates.PvsMetadataFreeLink},System.Int32,Robust.Shared.GameObjects.PvsIndex@)">
            <summary>
            Initialize a section of the free list.
            </summary>
            <param name="memory">The section of the free list to initialize.</param>
            <param name="baseOffset">What offset in the total PVS data this section starts at.</param>
            <param name="head">The current head storage of the free list to update.</param>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ClearPvsData">
            <summary>
            Clear all PVS data. After this function is called,
            <see cref="M:Robust.Server.GameStates.PvsSystem.ResetDataMemory"/> must be called if the system isn't being shut down.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ResetDataMemory">
            <summary>
            Re-initialize the memory in <see cref="F:Robust.Server.GameStates.PvsSystem._metadataMemory"/> after it was fully cleared on reset.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ShrinkDataMemory">
            <summary>
            Shrink <see cref="F:Robust.Server.GameStates.PvsSystem._metadataMemory"/> (and all sessions) back down to initial entity size after clear.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ShufflePointers(System.Int32)">
            <summary>
            This method shuffles the entity free list. This is used to avoid accidental / unrealistic cache locality
            in benchmarks.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ClearPlayerPvsData(Robust.Server.GameStates.PvsSession)">
            <summary>
            Clear all of this sessions' PvsData for all entities. This effectively means that PVS will act as if the player
            had never been sent information about any entity. Used when returning the player's index offset to the pool.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ClearEntityPvsData(Robust.Shared.GameObjects.PvsIndex)">
            <summary>
            Clear all of this entity' PvsData entries. This effectively means that PVS will act as if no player
            had never been sent information about this entity. Used when returning the entity's index back to the free list.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.IndexToNetEntity(Robust.Shared.GameObjects.PvsIndex)">
            <summary>
            Get the NetEntity associated with a given <see cref="T:Robust.Shared.GameObjects.PvsIndex"/>.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.CreateSessionDataMemory">
            <summary>
            Create a new <see cref="T:Robust.Shared.Utility.ResizableMemoryRegion`1"/> suitable for assigning to a new <see cref="T:Robust.Server.GameStates.PvsSession"/>.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.AssignEntityPointer(Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Retrieve a free entity index and assign it to an entity.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.OnEntityDeleted(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.MetaDataComponent})">
            <summary>
            Return an entity's index in the data array back to the free list of available indices.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.AfterEntityFlush">
            <summary>
            Immediately return all data indexes back to the pool after flushing all entities.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ProcessDeletions">
            <summary>
            This update method periodically returns entity indices back to the pool, once we are sure no old
            game state acks will use indices to that entity.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._addEntities">
            <summary>
            if it's a new entity we need to GetEntityState from tick 0.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.GetEntityState(Robust.Shared.Player.ICommonSession,Robust.Shared.GameObjects.EntityUid,Robust.Shared.Timing.GameTick,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Generates a network entity state for the given entity.
            </summary>
            <param name="player">The player to generate this state for. This may be null if the state is for replay recordings.</param>
            <param name="entityUid">Uid of the entity to generate the state from.</param>
            <param name="fromTick">Only provide delta changes from this tick.</param>
            <param name="meta">The entity's metadata component</param>
            <returns>New entity State for the given entity.</returns>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.GetFullEntityState(Robust.Shared.Player.ICommonSession,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Variant of <see cref="M:Robust.Server.GameStates.PvsSystem.GetEntityState(Robust.Shared.Player.ICommonSession,Robust.Shared.GameObjects.EntityUid,Robust.Shared.Timing.GameTick,Robust.Shared.GameObjects.MetaDataComponent)"/> that includes all entity data, including data that can be inferred implicitly from the entity prototype.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.GetAllEntityStates(Robust.Server.GameStates.PvsSession)">
            <summary>
            Gets all entity states that have been modified after and including the provided tick.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.ProcessLeavePvs(Robust.Server.GameStates.PvsSession)">
            <summary>
            Figure out what entities are no longer visible to the client. These entities are sent reliably to the client
            in a separate net message. This has to be called after EntityData.LastSent is updated.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.AddForcedEntities(Robust.Server.GameStates.PvsSession)">
            <summary>
            Adds all entities that ignore normal pvs budgets.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.RecursivelyAddOverride(Robust.Server.GameStates.PvsSession,Robust.Shared.GameObjects.EntityUid,Robust.Shared.Timing.GameTick,System.Boolean)">
            <summary>
            Recursively add an entity and all of its parents to the to-send set. This optionally also adds all children.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.RecursivelyAddChildren(Robust.Server.GameStates.PvsSession,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Timing.GameTick)">
            <summary>
            Recursively add an entity and all of its children to the to-send set.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem.MaxVisPoolSize">
            <summary>
            Maximum number of pooled objects.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.SendStates">
            <summary>
            Compress and send game states to connected clients.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Server.GameStates.PvsSystem.SerializeStates" -->
        <member name="M:Robust.Server.GameStates.PvsSystem.SerializeState(System.Int32)">
            <summary>
            Get and serialize a <see cref="T:Robust.Shared.GameStates.GameState"/> for a single session (or the current replay).
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.SerializeSessionState(Robust.Server.GameStates.PvsSession)">
            <summary>
            Get and serialize a <see cref="T:Robust.Shared.GameStates.GameState"/> for a single session.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.PvsSystem._seenAllEnts">
            <summary>
            If PVS disabled then we'll track if we've dumped all entities on the player.
            This way any future ticks can be orders of magnitude faster as we only send what changes.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.AddPvsChunks(Robust.Server.GameStates.PvsSession)">
            <summary>
            Iterate over chunks that are visible to a player and add entities to the game-state.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.AddPvsChunk(Robust.Server.GameStates.PvsChunk,System.Single,Robust.Server.GameStates.PvsSession)">
            <summary>
            Add all entities on a given PVS chunk to a clients game-state.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.AddEntity(Robust.Server.GameStates.PvsSession,Robust.Server.GameStates.PvsChunk.ChunkEntity@,Robust.Server.GameStates.PvsMetadata@,Robust.Shared.Timing.GameTick)">
            <summary>
            Attempt to add an entity to the to-send lists, while respecting pvs budgets.
            </summary>
            <returns>Returns false if the entity would exceed the client's PVS budget.</returns>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.AddEntity(Robust.Server.GameStates.PvsSession,Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.Timing.GameTick)">
            <summary>
            Attempt to add an entity to the to-send lists, while respecting pvs budgets.
            </summary>
        </member>
        <member name="M:Robust.Server.GameStates.PvsSystem.IsEnteringPvsRange(Robust.Server.GameStates.PvsData@,Robust.Shared.Timing.GameTick,Robust.Server.GameStates.PvsBudget@)">
            <summary>
            This method figures out whether a given entity is currently entering a player's PVS range.
            This method will also check that the player's PVS entry budget is not being exceeded.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.ExpandPvsEvent.Entities">
            <summary>
            List of entities that will get added to this session's PVS set.
            </summary>
        </member>
        <member name="F:Robust.Server.GameStates.ExpandPvsEvent.RecursiveEntities">
            <summary>
            List of entities that will get added to this session's PVS set. Unlike <see cref="F:Robust.Server.GameStates.ExpandPvsEvent.Entities"/> this will also
            recursively add all children of the given entity.
            </summary>
        </member>
        <member name="T:Robust.Server.GameStates.ServerGameStateManager">
            <inheritdoc cref="T:Robust.Server.GameStates.IServerGameStateManager"/>
        </member>
        <member name="M:Robust.Server.GameStates.ServerGameStateManager.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.GameStates.ServerGameStateManager.SendGameStateUpdate">
            <inheritdoc />
        </member>
        <member name="T:Robust.Server.IBaseServer">
            <summary>
                Top level class that controls the game logic of the server.
            </summary>
        </member>
        <member name="P:Robust.Server.IBaseServer.MaxPlayers">
            <summary>
                The maximum number of players allowed in the server.
            </summary>
        </member>
        <member name="P:Robust.Server.IBaseServer.ServerName">
            <summary>
                The displayed name of our server.
            </summary>
        </member>
        <member name="M:Robust.Server.IBaseServer.Start(Robust.Server.ServerOptions,System.Func{Robust.Shared.Log.ILogHandler})">
            <summary>
                Sets up the server, loads the game, gets ready for client connections.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Server.IBaseServer.Restart">
            <summary>
                Hard restarts the server, shutting it down, kicking all players, and starting the server again.
            </summary>
        </member>
        <member name="M:Robust.Server.IBaseServer.Shutdown(System.String)">
            <summary>
                Shuts down the server, and ends the process.
            </summary>
            <param name="reason">Reason why the server was shut down.</param>
        </member>
        <member name="M:Robust.Server.IBaseServer.MainLoop">
            <summary>
                Enters the main loop of the server. This functions blocks until the server is shut down.
            </summary>
        </member>
        <member name="T:Robust.Server.Maps.LoadedMapComponent">
            <summary>
            Added to Maps that were loaded by MapLoaderSystem. If not present then this map was created externally.
            </summary>
        </member>
        <member name="M:Robust.Server.Maps.LoadedMapComponent.InternalCopy(Robust.Server.Maps.LoadedMapComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.Maps.LoadedMapComponent.Copy(Robust.Server.Maps.LoadedMapComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.Maps.LoadedMapComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.Maps.LoadedMapComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.Maps.LoadedMapComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.Maps.LoadedMapComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Server.Maps.LoadedMapComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Robust.Server.Maps.MapLoadOptions.StoreMapUids">
            <summary>
                If true, UID components will be created for loaded entities
                to maintain consistency upon subsequent savings.
            </summary>
        </member>
        <member name="P:Robust.Server.Maps.MapLoadOptions.Offset">
            <summary>
                Offset to apply to the loaded objects.
            </summary>
        </member>
        <member name="P:Robust.Server.Maps.MapLoadOptions.Rotation">
            <summary>
                Rotation to apply to the loaded objects as a collective, around 0, 0.
            </summary>
            <remarks>Setting this overrides </remarks>
        </member>
        <member name="P:Robust.Server.Maps.MapLoadOptions.LoadMap">
            <summary>
            If there is a map entity serialized should we also load it.
            </summary>
            <remarks>
            This should be set to false if you want to load a map file onto an existing map and do not wish to overwrite the existing entity.
            </remarks>
        </member>
        <member name="T:Robust.Server.Physics.GridFixtureSystem">
            <summary>
            Handles generating fixtures for MapGrids.
            </summary>
        </member>
        <member name="F:Robust.Server.Physics.GridFixtureSystem._subscribedSessions">
            <summary>
            Sessions to receive nodes for debug purposes.
            </summary>
        </member>
        <member name="F:Robust.Server.Physics.GridFixtureSystem._isSplitting">
            <summary>
            Recursion detection to avoid splitting while handling an existing split
            </summary>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.EnsureGrid(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Due to how MapLoader works need to ensure grid exists in dictionary before it's initialised.
            </summary>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.CheckSplits(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Check for any potential splits.
            </summary>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.CheckSplits(Robust.Shared.GameObjects.EntityUid,System.Collections.Generic.HashSet{Robust.Server.Physics.GridFixtureSystem.ChunkSplitNode})">
            <summary>
            Check for splits on the specified nodes.
            </summary>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.CreateNodes(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.Map.MapChunk)">
            <summary>
            Creates all of the splitting nodes within this chunk; also consider neighbor chunks.
            </summary>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.CheckSplit(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.MapChunk,System.Collections.Generic.List{Robust.Shared.Maths.Box2i})">
            <summary>
            Checks for grid split with 1 chunk updated.
            </summary>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.CheckSplit(Robust.Shared.GameObjects.EntityUid,System.Collections.Generic.Dictionary{Robust.Shared.Map.MapChunk,System.Collections.Generic.List{Robust.Shared.Maths.Box2i}},System.Collections.Generic.List{Robust.Shared.Map.MapChunk})">
            <summary>
            Checks for grid split with many chunks updated.
            </summary>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.RemoveSplitNode(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.MapChunk)">
            <summary>
            Removes this chunk from nodes and dirties its neighbours.
            </summary>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.GenerateSplitNode(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.MapChunk)">
            <summary>
            Re-adds this chunk to nodes and dirties its neighbours and itself.
            </summary>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.TryGetNode(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.MapChunk,Robust.Shared.Maths.Vector2i,Robust.Server.Physics.GridFixtureSystem.ChunkSplitNode@)">
            <summary>
            Tries to get the relevant split node from a neighbor chunk.
            </summary>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.Merge(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Vector2i,Robust.Shared.Maths.Angle,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Merges GridB into GridA.
            </summary>
            <param name="offset">Origin of GridB relative to GridA</param>
            <param name="rotation">Rotation to apply to GridB when being merged.
            Note that the rotation is applied before the offset so the offset itself will be rotated.</param>
        </member>
        <member name="M:Robust.Server.Physics.GridFixtureSystem.Merge(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Numerics.Matrix3x2,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Merges GridB into GridA.
            </summary>
            <param name="offset">Origin of GridB relative to GridA</param>
            <param name="matrix">Matrix to apply to gridB when being merged.
            Note that rotation is applied first and then offset so the offset itself will be rotated.</param>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.Initialize">
            <summary>
                Initializes this manager into a usable state.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.HandleNetMessage(Robust.Shared.Network.Messages.MsgPlacement)">
            <summary>
             Handles placement related client messages.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.SendPlacementBegin(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Places mob in entity placement mode with given settings.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.SendPlacementBeginTile(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Places mob in tile placement mode with given settings.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.SendPlacementCancel(Robust.Shared.GameObjects.EntityUid)">
            <summary>
             Cancels object placement mode for given mob.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.StartBuilding(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Gives Mob permission to place entity and places it in object placement mode.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.StartBuildingTile(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Gives Mob permission to place tile and places it in object placement mode.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.CancelBuilding(Robust.Shared.GameObjects.EntityUid)">
            <summary>
             Revokes open placement Permission and cancels object placement mode.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.AssignBuildPermission(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Gives a mob a permission to place a given Entity.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.AssignBuildPermissionTile(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Gives a mob a permission to place a given Tile.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.IPlacementManager.RevokeAllBuildPermissions(Robust.Shared.GameObjects.EntityUid)">
            <summary>
             Removes all building Permissions for given mob.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.PlacementManager.HandleNetMessage(Robust.Shared.Network.Messages.MsgPlacement)">
            <summary>
             Handles placement related client messages.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.PlacementManager.SendPlacementBegin(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Places mob in entity placement mode with given settings.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.PlacementManager.SendPlacementBeginTile(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Places mob in tile placement mode with given settings.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.PlacementManager.SendPlacementCancel(Robust.Shared.GameObjects.EntityUid)">
            <summary>
             Cancels object placement mode for given mob.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.PlacementManager.StartBuilding(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Gives Mob permission to place entity and places it in object placement mode.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.PlacementManager.StartBuildingTile(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Gives Mob permission to place tile and places it in object placement mode.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.PlacementManager.CancelBuilding(Robust.Shared.GameObjects.EntityUid)">
            <summary>
             Revokes open placement Permission and cancels object placement mode.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.PlacementManager.AssignBuildPermission(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Gives a mob a permission to place a given Entity.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.PlacementManager.AssignBuildPermissionTile(Robust.Shared.GameObjects.EntityUid,System.Int32,System.String,System.String)">
            <summary>
             Gives a mob a permission to place a given Tile.
            </summary>
        </member>
        <member name="M:Robust.Server.Placement.PlacementManager.RevokeAllBuildPermissions(Robust.Shared.GameObjects.EntityUid)">
            <summary>
             Removes all building Permissions for given mob.
            </summary>
        </member>
        <member name="T:Robust.Server.Player.IPlayerManager">
            <summary>
                Manages each players session when connected to the server.
            </summary>
        </member>
        <member name="T:Robust.Server.Player.PlayerManager">
            <summary>
                This class will manage connected player sessions.
            </summary>
        </member>
        <member name="M:Robust.Server.Player.PlayerManager.Initialize(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Server.Player.PlayerManager.NewSession(System.Object,Robust.Shared.Network.NetChannelArgs)">
            <summary>
                Creates a new session for a client.
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:Robust.Server.Player.PlayerManager.EndSession(Robust.Shared.Network.NetUserId)">
            <summary>
                Ends a clients session, and disconnects them.
            </summary>
        </member>
        <member name="T:Robust.Server.Reflection.ServerReflectionManager">
            <summary>
            Implementation of <see cref="T:Robust.Shared.Reflection.ReflectionManager"/>
            that defines <code>Robust.Server</code> and <code>Robust.Shared</code>
            as valid prefixes for <see cref="M:Robust.Shared.Reflection.ReflectionManager.GetType(System.String)"/>
            </summary>
        </member>
        <member name="M:Robust.Server.Replays.IServerReplayRecordingManager.Update">
            <summary>
            Processes pending write tasks and saves the replay data for the current tick. This should be called even if a
            replay is not currently being recorded.
            </summary>
        </member>
        <member name="M:Robust.Server.ServerIoC.RegisterIoC(Robust.Shared.IoC.IDependencyCollection)">
            <summary>
            Registers all the types into the <see cref="T:Robust.Shared.IoC.IDependencyCollection"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Robust.Server.ServerOptions.Sandboxing" -->
        <member name="P:Robust.Server.ServerOptions.MountOptions">
            <summary>
                Lists of mount options to mount.
            </summary>
        </member>
        <member name="P:Robust.Server.ServerOptions.ContentModulePrefix">
            <summary>
                Assemblies with this prefix will be loaded.
            </summary>
        </member>
        <member name="P:Robust.Server.ServerOptions.ContentBuildDirectory">
            <summary>
                Name of the content build directory, for game pack mounting purposes.
            </summary>
        </member>
        <member name="P:Robust.Server.ServerOptions.AssemblyDirectory">
            <summary>
                Directory to load all assemblies from.
            </summary>
        </member>
        <member name="P:Robust.Server.ServerOptions.PrototypeDirectory">
            <summary>
                Directory to load all prototypes from.
            </summary>
        </member>
        <member name="P:Robust.Server.ServerOptions.ResourceMountDisabled">
            <summary>
                Whether to disable mounting the "Resources/" folder on FULL_RELEASE.
            </summary>
        </member>
        <member name="P:Robust.Server.ServerOptions.LoadContentResources">
            <summary>
                Whether to mount content resources when not on FULL_RELEASE.
            </summary>
        </member>
        <member name="P:Robust.Server.ServerOptions.LoadConfigAndUserData">
            <summary>
                Whether to load config and user data.
            </summary>
        </member>
        <member name="T:Robust.Server.ServerStatus.IFullHybridAczProvider">
            <summary>
            Provides additional game files for use on top of Hybrid ACZ.
            </summary>
            <seealso href="https://docs.spacestation14.com/en/robust-toolbox/acz.html"/>
        </member>
        <member name="M:Robust.Server.ServerStatus.IFullHybridAczProvider.Package(Robust.Packaging.AssetProcessing.AssetPass,Robust.Packaging.AssetProcessing.AssetPass,Robust.Packaging.IPackageLogger,System.Threading.CancellationToken)">
            <summary>
            Run Full Hybrid ACZ packaging.
            This function is expected to calculate the asset graph with the provided passes and inject its own files.
            After the function finishes, Hybrid ACZ files are injected which should finish the packaging process.
            </summary>
            <param name="hybridPackageInput">
            The asset pass that will receive the files from the Hybrid ACZ package.
            You probably want to pass these through to the output directly.
            </param>
            <param name="output">
            The final output pass that all packaged game files should be sent to.
            </param>
            <param name="logger">A logger for logging of log messages you may want to log.</param>
            <param name="cancel">Cancellation token to abort packaging if necessary.</param>
            <returns>An asynchronous task.</returns>
        </member>
        <member name="P:Robust.Server.ServerStatus.IStatusHandlerContext.RequestBody">
            <summary>
            Stream that reads the request body data,
            </summary>
        </member>
        <member name="E:Robust.Server.ServerStatus.IStatusHost.OnStatusRequest">
            <summary>
                Invoked when a client queries a status request from the server.
                THIS IS INVOKED FROM ANOTHER THREAD.
                I REPEAT, THIS DOES NOT RUN ON THE MAIN THREAD.
                MAKE TRIPLE SURE EVERYTHING IN HERE IS THREAD SAFE DEAR GOD.
            </summary>
        </member>
        <member name="E:Robust.Server.ServerStatus.IStatusHost.OnInfoRequest">
            <summary>
                Invoked when a client queries an info request from the server.
                THIS IS INVOKED FROM ANOTHER THREAD.
                I REPEAT, THIS DOES NOT RUN ON THE MAIN THREAD.
                MAKE TRIPLE SURE EVERYTHING IN HERE IS THREAD SAFE DEAR GOD.
            </summary>
        </member>
        <member name="M:Robust.Server.ServerStatus.IStatusHost.SetAczInfo(System.String,System.String[])">
            <summary>
            Set information used by automatic-client-zipping to determine the layout of your dev setup,
            and which assembly files to send.
            </summary>
            <param name="clientBinFolder">
            The name of your client project in the bin/ folder on the top of your project.
            </param>
            <param name="clientAssemblyNames">
            The list of client assemblies to send from the aforementioned folder.
            </param>
        </member>
        <member name="M:Robust.Server.ServerStatus.IStatusHost.SetFullHybridAczProvider(Robust.Server.ServerStatus.IFullHybridAczProvider)">
            <summary>
            Sets a provider for extra asset files if Hybrid ACZ is available.
            </summary>
            <remarks>
            <para>
            If called multiple times, the previous provider is replaced. This only applies if ACZ is ran again later.
            <see cref="M:Robust.Server.ServerStatus.IStatusHost.InvalidateAcz"/> must be called manually for this to have an effect if ACZ has already been built.
            </para>
            <para>
            It is valid to have both a Full Hybrid ACZ provider
            and a Magic ACZ provider (via <see cref="M:Robust.Server.ServerStatus.IStatusHost.SetMagicAczProvider(Robust.Server.ServerStatus.IMagicAczProvider)"/>) set at the same time.
            The Full Hybrid provider is used if Hybrid ACZ is available, otherwise the Magic ACZ provider is used.
            </para>
            </remarks>
            <param name="provider">The provider to use.</param>
            <seealso href="https://docs.spacestation14.com/en/robust-toolbox/acz.html"/>
        </member>
        <member name="M:Robust.Server.ServerStatus.IStatusHost.InvalidateAcz">
            <summary>
            Invalidate the cached ACZ package.
            This causes it to be re-generated the next time a client attempts to download the ACZ
            (or requests the information for it).
            </summary>
        </member>
        <member name="F:Robust.Server.ServerStatus.StatusHost.DownloadStreamHeaderFlags.PreCompressed">
            <summary>
            If this flag is set on the download stream, individual files have been pre-compressed by the server.
            This means each file has a compression header, and the launcher should not attempt to compress files itself.
            </summary>
        </member>
        <member name="T:Robust.Server.ServerStatus.StatusHost.AczManifestInfo">
            <param name="ManifestData">Data for the content manifest</param>
            <param name="ManifestHash">Hex BLAKE2B 256-bit hash of <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestData"/>.</param>
            <param name="ManifestEntries">Manifest -> zip entry map.</param>
        </member>
        <member name="M:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.#ctor(System.Byte[],System.Boolean,System.String,System.Byte[],Robust.Server.ServerStatus.StatusHost.AczManifestEntry[],System.Boolean)">
            <param name="ManifestData">Data for the content manifest</param>
            <param name="ManifestHash">Hex BLAKE2B 256-bit hash of <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestData"/>.</param>
            <param name="ManifestEntries">Manifest -> zip entry map.</param>
        </member>
        <member name="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestData">
            <summary>Data for the content manifest</summary>
        </member>
        <member name="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestHash">
            <summary>Hex BLAKE2B 256-bit hash of <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestData"/>.</summary>
        </member>
        <member name="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestEntries">
            <summary>Manifest -> zip entry map.</summary>
        </member>
        <member name="T:Robust.Server.ServerStatus.StatusHost.AczManifestEntry">
            <param name="BlobLength">Length of the uncompressed blob.</param>
            <param name="DataOffset">Offset into <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestBlobData"/> that this blob's (possibly compressed) data starts at.</param>
            <param name="DataLength">
            Length in <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestBlobData"/> for this blob's (possibly compressed) data.
            If this is zero, it means the file is not stored uncompressed and you should use <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestEntry.BlobLength"/>.
            </param>
        </member>
        <member name="M:Robust.Server.ServerStatus.StatusHost.AczManifestEntry.#ctor(System.Int32,System.Int32,System.Int32)">
            <param name="BlobLength">Length of the uncompressed blob.</param>
            <param name="DataOffset">Offset into <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestBlobData"/> that this blob's (possibly compressed) data starts at.</param>
            <param name="DataLength">
            Length in <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestBlobData"/> for this blob's (possibly compressed) data.
            If this is zero, it means the file is not stored uncompressed and you should use <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestEntry.BlobLength"/>.
            </param>
        </member>
        <member name="P:Robust.Server.ServerStatus.StatusHost.AczManifestEntry.BlobLength">
            <summary>Length of the uncompressed blob.</summary>
        </member>
        <member name="P:Robust.Server.ServerStatus.StatusHost.AczManifestEntry.DataOffset">
            <summary>Offset into <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestBlobData"/> that this blob's (possibly compressed) data starts at.</summary>
        </member>
        <member name="P:Robust.Server.ServerStatus.StatusHost.AczManifestEntry.DataLength">
            <summary>
            Length in <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestInfo.ManifestBlobData"/> for this blob's (possibly compressed) data.
            If this is zero, it means the file is not stored uncompressed and you should use <see cref="P:Robust.Server.ServerStatus.StatusHost.AczManifestEntry.BlobLength"/>.
            </summary>
        </member>
        <member name="T:Robust.Server.ServerStatus.StatusHostHelpers">
            <summary>
            Helper functions for dealing with <see cref="T:Robust.Server.ServerStatus.StatusHost"/>.
            </summary>
        </member>
        <member name="M:Robust.Server.ServerStatus.StatusHostHelpers.AddLink(System.Text.Json.Nodes.JsonNode,System.String,System.String,System.String)">
            <summary>
            Add an info link to the body of an info request.
            </summary>
            <param name="infoObject">
            The main body of the info request.
            This should be the value from the parameter on <see cref="E:Robust.Server.ServerStatus.IStatusHost.OnInfoRequest"/>.
            </param>
            <param name="name">The name of the link to add.</param>
            <param name="url">The URL to open when the link is clicked.</param>
            <param name="icon">
            The icon to show next to the button.
            See https://docs.spacestation14.io/config-reference for valid icons.
            </param>
        </member>
        <member name="M:Robust.Server.ServerStatus.WatchdogApi.ShutdownHandler(Robust.Server.ServerStatus.IStatusHandlerContext)">
            <remarks>
            This function is used by https://github.com/tgstation/tgstation-server
            Notify the project maintainer(s) if this API is changed.
            </remarks>
        </member>
        <member name="T:Robust.Server.ServerWarmup">
            <summary>
            Logic for "warming up" things like slow static constructors concurrently.
            </summary>
        </member>
        <member name="T:Robust.Server.Upload.GamePrototypeLoadManager">
            <summary>
                Manages sending runtime-loaded prototypes from game staff to clients.
            </summary>
        </member>
        <member name="M:Robust.Server.Upload.NetworkResourceManager.ResourceUploadMsg(Robust.Shared.Upload.NetworkResourceUploadMessage)">
            <summary>
                Callback for when a client attempts to upload a resource.
            </summary>
            <param name="msg"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:Robust.Server.Upload.UploadedContentManager">
            <summary>
            Responsible for sending uploaded content to clients when they connect.
            </summary>
        </member>
        <member name="M:Robust.Server.ViewVariables.ViewVariablesSession.#ctor(Robust.Shared.Network.NetUserId,System.Object,System.UInt32,Robust.Server.ViewVariables.IServerViewVariablesInternal,Robust.Shared.Serialization.IRobustSerializer,Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Log.ISawmill)">
            <param name="playerUser">The session ID of the player who opened this session.</param>
            <param name="o">The object we represent.</param>
            <param name="sessionId">
                The session ID for this session. This is what the server and client use to talk about this session.
            </param>
            <param name="host">The view variables host owning this session.</param>
        </member>
        <member name="T:Robust.Server.ViewVariables.ViewVariablesTrait">
            <summary>
                Traits define what behavior an object can have that VV cares about.
                So like, is it enumerable, does it have VV accessible members. That kinda deal.
                These are the "modular" way of extending VV.
                Server traits are bound to one <see cref="T:Robust.Server.ViewVariables.ViewVariablesSession"/>, AKA one object.
            </summary>
        </member>
        <member name="M:Robust.Server.ViewVariables.ViewVariablesTrait.DataRequest(Robust.Shared.ViewVariables.ViewVariablesRequest)">
            <summary>
                Invoked when the client requests a data blob from the session this trait is bound to,
                Using <see cref="T:Robust.Shared.Network.Messages.MsgViewVariablesReqData"/>.
            </summary>
            <param name="viewVariablesRequest">
                The request meta object, equivalent to the <see cref="P:Robust.Shared.Network.Messages.MsgViewVariablesReqData.RequestMeta"/> object.
            </param>
            <returns>
                <see langword="null"/>If this trait doesn't care about this request, a meaningful blob otherwise.
                No, not the game mode, the other kind of blob.
            </returns>
        </member>
        <member name="M:Robust.Server.ViewVariables.ViewVariablesTrait.TryGetRelativeObject(System.Object,System.Object@)">
            <summary>
                Tries to get an object relative to the object handled by this trait.
                This is for doing the whole "this guy wants to open a VV window on a sub object" deal.
            </summary>
            <param name="property">
                The first element of a property index list as described by <see cref="P:Robust.Shared.ViewVariables.ViewVariablesSessionRelativeSelector.PropertyIndex"/>
                <para>
                    "Why is this the first only?" Well my idea was that it should get the first level of the index,
                   and then if it were like a tuple the session would handle the rest of the indices.
                    Whether that will work out in practice when the next person comes along to implement that is probably uncertain,
                    so if you wanna change that future person go ahead.
                </para>
                <!--
                    My god that's the first time I've used <para> in a doc comment.
                    Hey man at least my stuff is deeply commented so you have an explanation WHY things are half-assed and where the half assing is.
                -->
            </param>
            <param name="value">The to-be value of the object if this trait managed to retrieve it.</param>
            <returns>True if we retrieved a value, false otherwise.</returns>
        </member>
        <member name="M:Robust.Server.ViewVariables.ViewVariablesTrait.TryModifyProperty(System.Object[],System.Object)">
            <summary>
                TRY to modify a property on this trait.
                For example <see cref="T:Robust.Server.ViewVariables.Traits.ViewVariablesTraitMembers"/> tries to modify the object's members here.
            </summary>
            <param name="property">
                A list of objects that your trait might understand to figure out what to modify.
                See <see cref="P:Robust.Shared.ViewVariables.ViewVariablesSessionRelativeSelector.PropertyIndex"/> for an explanation.
            </param>
            <param name="value">
                The new value of the object.
            </param>
            <returns>True if this trait can and did modify the property, false otherwise.</returns>
        </member>
        <member name="M:Robust.Server.ViewVariables.ViewVariablesTrait.MakeValueNetSafe(System.Object)">
            <summary>
                Swaps values like references over to reference tokens to prevent issues.
            </summary>
        </member>
        <member name="M:Robust.Server.ViewVariables.ViewVariablesTrait.MakeNullValueNetSafe(System.Type)">
            <summary>
                Swaps null values for net safe equivalents depending on type.
                Will return null for types where null is considered net safe.
            </summary>
        </member>
        <member name="T:PostGridSplitEvent">
            <summary>
                Event raised on a grid after it has been split but before the old grid has been cleaned up.
            </summary>
        </member>
        <member name="F:PostGridSplitEvent.OldGrid">
            <summary>
                The grid it was part of previously.
            </summary>
        </member>
        <member name="F:PostGridSplitEvent.Grid">
            <summary>
                The grid that has been split.
            </summary>
        </member>
        <member name="T:GridSplitEvent">
            <summary>
                Event raised on a grid that has been split into multiple grids.
            </summary>
        </member>
        <member name="F:GridSplitEvent.NewGrids">
            <summary>
                Contains the IDs of the newly created grids.
            </summary>
        </member>
        <member name="F:GridSplitEvent.Grid">
            <summary>
                The grid that has been split.
            </summary>
        </member>
    </members>
</doc>
